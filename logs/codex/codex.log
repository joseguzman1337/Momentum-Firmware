Submitting Issue #56: Storage: Choose filesystem when formatting SD to Codex...
OpenAI Codex v0.77.0 (research preview)
--------
workdir: /Users/x/x/Momentum-Firmware
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: none
reasoning summaries: auto
session id: 019b683f-6c5e-7723-b81d-7e1cc65dc793
--------
user
Fix and resolve Issue #56: Storage: Choose filesystem when formatting SD
mcp startup: no servers

thinking
**Searching for AGENTS file**
exec
/bin/zsh -lc ls in /Users/x/x/Momentum-Firmware succeeded in 98ms:
AGENTS.md
CHANGELOG.md
CLAUDE.md
CODING_STYLE.md
CONTRIBUTING.md
GEMINI.md
LICENSE
Momentum-Firmware
Momentum-Firmware.code-workspace
ReadMe.md
SConstruct
SECURITY.md
WARP.md
applications
applications_user
assets
build
codex.log
dist
documentation

thinking
**Searching for AGENTS instructions**
exec
/bin/zsh -lc 'cat AGENTS.md' in /Users/x/x/Momentum-Firmware succeeded in 90ms:


thinking
**Searching for issue 56**
exec
/bin/zsh -lc 'rg -n "Issue #56|issue 56|filesystem|formatting SD|format sd|SD" issues_all.txt pending_issues_codex.txt documentation -g"*"' in /Users/x/x/Momentum-Firmware succeeded in 115ms:
pending_issues_codex.txt:1:Issue #56: Storage: Choose filesystem when formatting SD
pending_issues_codex.txt:28:Issue #29: Duress PIN (panic/erase) to wipe device + SD
pending_issues_codex.txt:32:Issue #25: SDcard issues and crashing
issues_all.txt:9:Fix issue #56: Storage: Choose filesystem when formatting SD
issues_all.txt:36:Fix issue #29: Duress PIN (panic/erase) to wipe device + SD
issues_all.txt:40:Fix issue #25: SDcard issues and crashing
documentation/CustomFlipperName.md:5:2. Enter your new custom name for your flipper and click `Save`, **name will be saved on microSD card, and will stay same after firmware updates**
documentation/FuriHalDebugging.md:28:## FuriHalSD
documentation/FuriHalDebugging.md:30:`--extra-define=FURI_HAL_SD_SPI_DEBUG` enables SD card SPI bus logging.
documentation/SubGHzSettings.md:17:Edit user settings file located on your microSD card - `subghz/assets/setting_user` (remove .example from name to use config)
documentation/HardwareTargets.md:3:Flipper's firmware is modular and supports different hardware configurations in a common code base. It encapsulates hardware-specific differences in `furi_hal`, board initialization code, linker files, SDK data and other information in a _target definition_.
documentation/HardwareTargets.md:15:* `sdk_header_paths`: list of strings, folder paths relative to current target folder to gather headers from for including in SDK.
documentation/HardwareTargets.md:20:* `sdk_symbols`: filename of a .csv file containing current SDK configuration for this target.
documentation/HardwareTargets.md:24:* `excluded_headers`: list of headers from the inherited configuration(s) NOT to be included in generated SDK.
documentation/SubGHzCounterMode.md:19:1. Locate your `.sub` file (in `/ext/subghz/` on your Flipper Zero SD card)
documentation/AppsOnSDCard.md:52:## How Flipper runs an app from an SD card
documentation/AppsOnSDCard.md:54:Flipper's MCU cannot run code directly from external storage, so it needs to be copied to RAM first. That is done by the App Loader responsible for loading the FAP from the SD card, verifying its integrity and compatibility, copying it to RAM, and adjusting it for its new location.
documentation/AppsOnSDCard.md:73:API versioning is mostly automated by `fbt`. When rebuilding the firmware, `fbt` checks if there are any changes in the API exposed by headers gathered from `SDK_HEADERS`. If so, it stops the build, adjusts the API version, and asks the user to go through the changes in the `.csv` file. New entries are marked with a "`?`" mark, and the user is supposed to change the mark to "`+`" for the entry to be exposed for FAPs, or to "`-`" for it to be unavailable.
documentation/OTA.md:17:So, before taking any action on the firmware, we back up the current configuration from `/int` into a plain tar archive on the SD card.
documentation/OTA.md:33:If the update package contains an additional resources archive, it is extracted onto the SD card.

thinking
**Searching for formatting code related to sd**
exec
/bin/zsh -lc 'rg -n "format.*sd|sd.*format|filesystem|fs_type|fat|exfat|extfs|mkfs|f_mkfs|format" applications furi lib drivers -g"*"' in /Users/x/x/Momentum-Firmware succeeded in 459ms:
drivers/install_awus1900_tahoe.py:46:    """Handles formatted output for the installation process."""
drivers/create_all_installers.sh:125:               -ov -format UDZO \
lib/nanopb/pb_decode.h:147:/* Decode an integer in the varint format. This works for enum, int32,
lib/nanopb/pb_decode.h:155:/* Decode an integer in the varint format. This works for enum, int32,
lib/nanopb/pb_decode.h:159:/* Decode a bool value in varint format. */
lib/nanopb/pb_decode.h:162:/* Decode an integer in the zig-zagged svarint format. This works for sint32
drivers/src/RTL88xxAU.h:68:    // Device information
lib/nanopb/pb_encode.h:139:/* Encode an integer in the varint format.
lib/nanopb/pb_encode.h:147:/* Encode an integer in the zig-zagged svarint format.
drivers/SDK_FIX_README.md:84:Result: `fatal error: cyclic dependency in module 'CoreServices'`
furi/core/string.h:58: * Initialize and set a string to the given formatted value.
furi/core/string.h:60: * @param      format     The printf format
furi/core/string.h:61: * @param[in]  ...        args to format
furi/core/string.h:65:FuriString* furi_string_alloc_printf(const char format[], ...)
furi/core/string.h:66:    _ATTRIBUTE((__format__(__printf__, 1, 2)));
furi/core/string.h:70: * Initialize and set a string to the given formatted value.
furi/core/string.h:72: * @param      format  The printf format
furi/core/string.h:73: * @param      args    The format arguments
furi/core/string.h:77:FuriString* furi_string_alloc_vprintf(const char format[], va_list args);
furi/core/string.h:233:/** Format in the string the given printf format

thinking
**Searching for formatting code in storage service**
exec
/bin/zsh -lc 'rg -n "format" applications furi lib drivers --glob "*storage*"' in /Users/x/x/Momentum-Firmware succeeded in 164ms:
lib/mbedtls/framework/scripts/mbedtls_framework/psa_storage.py:29:            self.string = '{0:#0{1}x}'.format(content, digits + 2)
lib/mbedtls/framework/scripts/mbedtls_framework/psa_storage.py:114:    """The latest version of the storage format."""
lib/mbedtls/framework/scripts/mbedtls_framework/psa_storage.py:142:        """Pack the given arguments into a byte string according to the given format.
applications/system/js_app/modules/js_usbdisk/mass_storage_scsi.c:81:        data[0] = 0x70; // fixed format sense data
applications/system/js_app/modules/js_usbdisk/mass_storage_scsi.c:84:        data[3] = 0; // information
applications/system/js_app/modules/js_usbdisk/mass_storage_scsi.c:85:        data[4] = 0; // information
applications/system/js_app/modules/js_usbdisk/mass_storage_scsi.c:86:        data[5] = 0; // information
applications/system/js_app/modules/js_usbdisk/mass_storage_scsi.c:87:        data[6] = 0; // information
applications/system/js_app/modules/js_usbdisk/mass_storage_scsi.c:89:        data[8] = 0; // command specific information
applications/system/js_app/modules/js_usbdisk/mass_storage_scsi.c:90:        data[9] = 0; // command specific information
applications/system/js_app/modules/js_usbdisk/mass_storage_scsi.c:91:        data[10] = 0; // command specific information
applications/system/js_app/modules/js_usbdisk/mass_storage_scsi.c:92:        data[11] = 0; // command specific information
applications/system/js_app/modules/js_usbdisk/mass_storage_scsi.c:96:        data[15] = 0; // sense key specific information
applications/system/js_app/modules/js_usbdisk/mass_storage_scsi.c:97:        data[16] = 0; // sense key specific information
applications/system/js_app/modules/js_usbdisk/mass_storage_scsi.c:98:        data[17] = 0; // sense key specific information
applications/system/js_app/modules/js_usbdisk/mass_storage_scsi.c:119:            data[3] = 0x02; // response data format
lib/mbedtls/docs/architecture/mbed-crypto-storage-specification.md:6:This document contains historical information both from before and after this merge.
lib/mbedtls/docs/architecture/mbed-crypto-storage-specification.md:11:1. This document retains historical information about all past released versions. Do not remove information from this document unless it has always been incorrect or it is about a version that you are sure was never released.
lib/mbedtls/docs/architecture/mbed-crypto-storage-specification.md:28:* [Persistent transparent keys](#key-file-format-for-0.1.0) designated by a [slot number](#key-names-for-0.1.0).
lib/mbedtls/docs/architecture/mbed-crypto-storage-specification.md:29:* [Nonvolatile random seed](#nonvolatile-random-seed-file-format-for-0.1.0) on ITS only.

thinking
**Searching for sd_format in storage app**
exec
/bin/zsh -lc 'rg -n "format" applications -g"*storage*" -g"*.c" -g"*.h"' in /Users/x/x/Momentum-Firmware succeeded in 235ms:
applications/debug/rpc_debug_app/rpc_debug_app.c:25:    rpc_debug_app_format_hex(const uint8_t* data, size_t data_size, char* buf, size_t buf_size) {
applications/debug/rpc_debug_app/rpc_debug_app.c:62:        rpc_debug_app_format_hex(
applications/main/u2f/u2f.c:41:    uint8_t format;
applications/debug/locale_test/locale_test.c:36:    locale_format_time(tmp_string, &datetime, locale_get_time_format(), false);
applications/debug/locale_test/locale_test.c:39:    locale_format_date(tmp_string, &datetime, locale_get_date_format(), "/");
applications/system/findmy/findmy_state.c:7:#include <flipper_format/flipper_format.h>
applications/system/findmy/findmy_state.c:16:        FlipperFormat* file = flipper_format_file_alloc(storage);
applications/system/findmy/findmy_state.c:20:            if(!flipper_format_file_open_existing(file, FINDMY_STATE_PATH)) break;
applications/system/findmy/findmy_state.c:21:            if(!flipper_format_read_header(file, str, &tmp)) break;
applications/system/findmy/findmy_state.c:25:            if(!flipper_format_read_bool(file, "beacon_active", &state.beacon_active, 1)) break;
applications/system/findmy/findmy_state.c:27:            if(!flipper_format_read_uint32(file, "broadcast_interval", &tmp, 1)) break;
applications/system/findmy/findmy_state.c:30:            if(!flipper_format_read_uint32(file, "transmit_power", &tmp, 1)) break;
applications/system/findmy/findmy_state.c:33:            if(!flipper_format_read_uint32(file, "tag_type", &tmp, 1)) {
applications/system/findmy/findmy_state.c:35:                flipper_format_rewind(file);
applications/system/findmy/findmy_state.c:39:            if(!flipper_format_read_bool(file, "show_mac", &state.show_mac, 1)) {
applications/system/findmy/findmy_state.c:42:                flipper_format_rewind(file);
applications/system/findmy/findmy_state.c:45:            if(!flipper_format_read_hex(file, "mac", state.mac, sizeof(state.mac))) break;
applications/system/findmy/findmy_state.c:47:            if(!flipper_format_read_hex(
applications/system/findmy/findmy_state.c:54:        flipper_format_free(file);
applications/system/findmy/findmy_state.c:148:    FlipperFormat* file = flipper_format_file_alloc(storage);

thinking
**Opening storage settings code**
exec
/bin/zsh -lc 'ls applications/settings/storage_settings/scenes' in /Users/x/x/Momentum-Firmware succeeded in 105ms:
storage_settings_scene.c
storage_settings_scene.h
storage_settings_scene_benchmark.c
storage_settings_scene_benchmark_confirm.c
storage_settings_scene_config.h
storage_settings_scene_factory_reset.c
storage_settings_scene_format_confirm.c
storage_settings_scene_formatting.c
storage_settings_scene_internal_info.c
storage_settings_scene_sd_info.c
storage_settings_scene_start.c
storage_settings_scene_unmount_confirm.c
storage_settings_scene_unmounted.c
storage_settings_scene_wipe_device.c

thinking
**Opening formatting files**
exec
/bin/zsh -lc 'cat applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c' in /Users/x/x/Momentum-Firmware succeeded in 110ms:
#include "../storage_settings.h"

static void
    storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
    StorageSettings* app = context;

    view_dispatcher_send_custom_event(app->view_dispatcher, result);
}

void storage_settings_scene_format_confirm_on_enter(void* context) {
    StorageSettings* app = context;
    DialogEx* dialog_ex = app->dialog_ex;

    FS_Error sd_status = storage_sd_status(app->fs_api);

    if(sd_status == FSE_NOT_READY) {
        dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
        dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
        dialog_ex_set_text(
            dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);

thinking
**Formatting scene**
exec
/bin/zsh -lc 'cat applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c' in /Users/x/x/Momentum-Firmware succeeded in 116ms:
#include "../storage_settings.h"
#include <notification/notification.h>
#include <notification/notification_messages.h>
#include <power/power_service/power.h>

static const NotificationMessage message_green_165 = {
    .type = NotificationMessageTypeLedGreen,
    .data.led.value = 165,
};

static const NotificationSequence sequence_set_formatting_leds = {
    &message_red_255,
    &message_green_165,
    &message_blue_0,
    &message_do_not_reset,
    NULL,
};

static const NotificationSequence sequence_reset_formatting_leds = {
    &message_red_0,

thinking
**Searching for SD format function**
exec
/bin/zsh -lc 'rg -n "storage_sd_format|sd_format|sd.*format" furi applications lib drivers' in /Users/x/x/Momentum-Firmware succeeded in 512ms:
drivers/usb-tree-ioreg.txt:11:  |   "IOKitDiagnostics" = {"Instance allocation"=16172464,"Container allocation"=9938341,"Pageable allocation"=2620358944,"Classes"={"AppleJPEGWrapperControlV8"=2,"KDISecondaryEncoding"=0,"RTBuddyFirmwareBundle"=0,"ApplePMPThermal"=0,"IOSkywalkPacketPoller"=0,"IOGPUKernelMappedMemory"=1,"IOAVBStreamCaptureUserClient"=0,"IOPMPowerStateQueue"=1,"ExclavesAudioProxyInputStreamDriverInterface"=0,"AppleSPUVD6287"=0,"AppleConvergedIPCDevice"=1,"IosaEnhancementPipeUnitMSR9"=0,"IOPMServiceInterestNotifier"=175,"IOPerfControlWorkContext"=250,"IOAVService"=0,"IOBlockStorageDriver"=3,"IO80211NoneProtocol"=0,"IOGPUBufferMemoryDescriptor"=2255,"IODTPlatformExpert"=1,"AppleAOPVoiceTriggerController"=1,"AppleT8122PCIeCPort"=3,"AFKFirmwareService"=1,"IOTimeSyncUnicastUDPv4EtEPort"=0,"ApplePassThroughBakuBTM"=0,"IOMobileFramebufferAP"=1,"IOGPUCommandDescriptor"=1,"AppleMesaARMFunction"=0,"IOThunderboltSwitchIntelJHL8440"=0,"OSArray"=42690,"IOImageLoaderHashstore"=0,"IOThunderboltConfigXDomainLinkChangeRequestCommand"=0,"IOAccessoryManagerAID"=0,"ApplePCIEHostBridge"=2,"AppleEmbeddedButtonController"=1,"AUAInputTerminalDictionary"=0,"AppleNVMeController"=1,"IOCommandGate"=2270,"AppleT8132USBXHCICommandRing"=0,"IOSerialBSDClient"=5,"AppleParadeDP825TCON"=0,"IosaColorManager"=1,"KDIUDIFCacheBuffer"=0,"IosaPrescaler3x3PipeUnitMSR9"=0,"IO80211TimeSyncPeersDatabase"=0,"AGXIOFenceData"=16,"AppleT8122DPTXPort"=0,"ApplePMGRFunctionStartS2RTimer"=2,"IOGPUClientSharedMachine"=44,"TaggedMemoryDescriptor"=0,"IOThunderboltSRAMLog"=0,"AppleGPIOICController"=1,"AppleTCControllerType2"=0,"AGXHardwareBufferBase"=2,"AppleT8112USBXHCICommandRing"=0,"AppleSEPSharedMemoryChannel"=1,"IOUSBMassStorageUASDriver"=0,"IOThunderboltXDomainPath"=0,"IOThunderboltConfigXDomainResponseCommand"=18,"AppleUSBSerial"=1,"AppleUVDMAceInterface"=0,"IOPortUserClient"=0,"IOWorkLoop"=564,"AppleT8132USBXHCI"=0,"AGXMemoryMap"=1,"IORegistryIterator"=0,"ISPErrorEventSource"=1,"ApplePCIECLegacyIntController"=3,"AGXRenderTargetMemoryG15"=25,"IOGPUGroupMemory"=1,"HSAIDUserClientHost"=0,"ApplePPMDroopController"=1,"AppleEmbeddedNVMeNVRAM"=0,"AppleBCMWLANTimeSyncEngine"=0,"AUAEffectUnitDictionary"=0,"AICInterruptTimestampFunction"=1,"AppleARMCPUPerformanceServiceNub"=0,"IO80211TrafficNotification"=0,"AppleSEPDebugService"=0,"IOThunderboltConfigWriteCommand"=20,"IOTimeSyncDomainUserClient"=0,"AppleThunderboltNHITransmitRing"=1,"IO80211NeighborCacheManager"=0,"IOUSBInterfaceUserClientV3"=0,"AppleATCDPPort"=2,"OSAction_IOUserNetworkEthernet__RxSQDataAvailable"=0,"AppleExternalPowerManager"=14,"RTBuddyEndpoint"=133,"IO80211RealTimePeerManager"=0,"AppleTypeCRetimerReporter"=0,"IOPortTransportAIDBus"=0,"AppleEmbeddedUSBDeviceSupport"=0,"IOSKMemoryBuffer"=444,"CommonGlue"=0,"DCPAVAudioDMADelegate"=3,"AGXStatistics"=1,"CoreAnalyticsMessenger"=1,"AppleARMSPMIDeviceUserClient"=0,"HIDAlwaysNotifyingIODataQueue"=1,"AppleBCMWLANItemRing"=0,"AppleM2ScalerCSCHalMSR22"=0,"IosaFirmwareControl"=0,"DigitizerTransducer"=0,"IOWatchdogUserClient"=1,"AppleThunderboltNHIReceiveRingType5"=12,"IOUnifiedAddressTranslator"=58,"IOThunderboltConfigErrorCommand"=4,"IOGPUDeviceUserClient"=1,"M2ScalerCSCColorConversionControlMSR23"=0,"AppleConvergedPCI"=1,"AppleSPUCT724"=0,"AppleThunderboltNHIReceiveRingType7"=0,"MCCommand"=0,"IOPlatformDevice"=32,"AppleARMFunctionMCA2Config"=3,"IODPPortAnalyticsCollector"=10,"AppleTCControllerType11"=0,"CoreKDLUserClient"=1,"AppleIPAppender"=1,"IOHIDevice"=0,"AGXLegacyGart"=0,"AppleMCA2SerDes"=2,"AIDQueueEventSource"=1,"AppleHIDTransportIODataQueue"=0,"AppleOnboardSerialSkywalkInterface"=0,"IOFramebufferSharedUserClient"=0,"AppleUSBUserHCIUserClient"=0,"com_apple_driver_FairPlayIOKitUserClient"=2,"AppleMultitouchInputHIDEventDriver"=1,"IODPVirtualDevice"=0,"IOMbufLittleMemoryCursor"=0,"HibiscusFunctions"=0,"IosaFilmGrainControlMSR16"=1,"AIDReporterState"=0,"AppleBCMWLANPCIeSkywalkMulticastQueue"=0,"IOHistogramReporter"=120,"AppleMCCUserClient"=0,"IODPRXPort"=0,"AGXFamilyAccelerator"=1,"IOBioPool"=0,"AppleBCMWLANChipManagerPCIe4377"=0,"IOHIDEventService"=3,"AppleBluetoothModuleUserClient"=0,"IONVMeBlockStorageDevice"=1,"WCLGASManager"=0,"AppleAOPAudioSpeakerClientManager"=0,"IODispatchSource"=2,"AppleJPEGWrapperControlV11"=0,"AppleBatteryAuth"=0,"OSOrderedSet"=599,"AUAControlDictionary"=0,"AppleBTMPMUAgent"=1,"AppleUserHIDDevice"=6,"AppleT8122USBXDCI"=3,"IOAVServiceUserClient"=0,"IOThunderboltCommand"=5,"AppleHIDTransportHIDDevice"=6,"IOGPUCommandQueue"=1,"CoreAnalyticsUserClient"=1,"IOBioPoolItemFactory"=0,"IOPortFeaturePowerSourceOption"=1,"AppleUSB20HostController"=0,"AppleDCPLinkService"=1,"AppleT8140USBXHCI"=0,"InterruptEventSourceBridge"=39,"IOBiometricUserClient"=0,"IOUserNetworkLogicalLink"=0,"IOTSAEITimeSyncHandler"=0,"AIDCircularBuffer"=0,"AHTFunctionExecutor"=0,"AppleUSBSortableConfigurationDescriptor"=8,"AppleCLPCWorkLoop"=1,"RTBuddyPatchBay"=1,"AppleProResHW"=1,"AppleSPUProfileDriverUserClient"=0,"M2ScalerSrcDestCfgControlMSR19"=0,"IOHITablet"=0,"BinaryEncoder"=0,"AppleARMBacklight"=1,"IO80211ThroughputCache"=0,"OSValueObject<KeyboardReserved>"=0,"OSAction_IOHIDEventService__CopyEvent"=0,"RTBuddyService"=14,"IOReporter"=3,"IO80211LQMCrashTracer"=0,"AppleBringUpPMGR"=0,"AppleAOPAudioServiceBase"=1,"IOTBTTunnelUSBType2ClientInterface"=0,"AppleAOPAudioUserClient"=1,"IO80211RNGAgent"=0,"AppleGCResource"=1,"IOAccessoryHSAIDBusTransport"=0,"ApplePPMEntity"=5,"AppleBSDKextStarter"=2,"IOSurfaceSharedEvent"=16,"AppleUSBXHCI"=2,"IOAVRegisterSet"=0,"IO80211NANDataPathResponder"=0,"IOServiceMessageUserNotification"=465,"IOSharedInterruptController"=5,"IOThunderboltSet"=209,"AppleASMediaUSBXHCIDevice"=0,"AppleT8101GPIOIC"=4,"ACMKernelService"=6,"IOAVAudioLinkDelegate"=0,"AppleDockChannelUserClient"=0,"IOProviderPropertyMerger"=1,"IOBluetoothTimerEventSource"=0,"IOHIKeyboardMapper"=0,"AppleAGXFunctionMetrology"=0,"IO80211DataPathInformAgent"=0,"RTBuddyRouteOnly"=0,"PMGRDispCtrl"=0,"AppleDisplayConnection"=0,"IOStorage"=4,"IONetworkMedium"=15,"AppleSPUDispADCUserClient"=0,"AppleSMCChargerPS"=0,"IOThunderboltConfigXDomainROMChangedRequestCommand"=0,"IO80211EventSource"=0,"AUCWorkloop"=1,"AppleATVAintreeBTM"=0,"ApplePassthroughPPM"=1,"WCLBGCommonFsm"=0,"IOHDCP2LocalMessageTransport"=0,"IOPMWorkQueue"=1,"AppleSEPPanicBuffer"=1,"AppleASCWrapV6"=12,"OSValueObject<H13ISPOverrideNVMParams>"=1,"AGXCLChannelSKU"=1,"AppleI2CPagedAudio"=0,"AppleSandDollar"=1,"AGXHWParamBufferManager"=25,"IosaChannelConfig"=0,"AppleTDMBlockStorageServices"=0,"IODPSwitchAllocationState"=2,"AppleARMFunctionCharger"=0,"RTBuddyKdebugEndpoint"=7,"IOUSBDeviceInterface"=12,"AppleARMLightEmUp"=1,"IOBluetoothSCOMemoryDescriptorRetainer"=0,"AppleSPU"=12,"RTBuddySlaveMemoryDescriptor"=14,"AppleSmartIOCommandPool"=9,"BTDebug"=1,"IOAccessoryPowerSourceItemPDPlatformCurrentLimit"=0,"AppleT8130USBXDCI"=0,"IOGPUWorkQueue"=1,"AppleCotaBTM"=0,"AppleSMCChargerFunction"=0,"AppleS8000AESAccelerator"=1,"AppleM2ScalerCSCDriverFilters"=1,"AppleBCMWLANChipManagerPCIe4364"=0,"AGXTAChannelSKU"=1,"IOThunderboltConfigMultiReadCommand"=5,"AppleUSBDeviceNCMControl"=6,"ANEClientDevice"=0,"IOSKRegionMapper"=50,"AppleFermiumBTM"=0,"AppleT8132DisplayCrossbar"=0,"IOHIDResource"=1,"IOTimeSyncTimedEdgeGeneratorUserClient"=0,"IORSMMemoryDescriptorArray"=0,"AppleThunderboltNHIMemoryBlock"=2,"IORSMCommand"=0,"IosaDPEControlMSR19"=0,"AppleThunderboltHALGenericACIO"=1,"IOCPU"=1,"DitherControlMSR7"=1,"AppleBCMWLANNANInterface"=0,"IOTimeSyncDaemonServiceBase"=1,"IOMachPort"=4825,"ApplePMGRFunctionPerfCycleCount"=2,"IOWorkGroup"=0,"AppleARMMIPIDSIController"=0,"AppleT6030PCIe"=1,"AGXPerfCtrSampler"=1,"AGXCLWorkQueue"=5,"IOThunderboltConfigXDomainPathTeardownRequestCommand"=0,"AppleTCS3490"=0,"AGXFastRenderTarget"=1,"AppleThunderboltIPConnection"=0,"AppleUSBHostDARTDMACommand"=15,"MogulAuthI2CRelayInterface"=0,"IODPEventLog"=0,"IOAccessoryPowerSourceItemUSB_TypeC_Current"=0,"IODTNVRAMDiags"=1,"IOThunderboltSwitchType7"=0,"IOSCSIPeripheralDeviceNub"=1,"AppleUSBXHCISparseRequestPool"=0,"AppleSystemPolicy"=1,"IOPCIDevice"=13,"IOPolledFilePollers"=1,"IODTNVRAMVariables"=2,"IOPortTransportStatePCIe"=1,"IOUserNetworkPacketQueue"=4,"AppleBCMWLANCommandMonitor"=0,"AppleMCA2MCLK"=4,"IOAudioEngine"=0,"AppleEmbeddedSimpleSPINORFlasherDriverUC"=0,"IOSurfaceWiredSendRight"=0,"AppleEmbeddedHIDEventService"=5,"StatusDescriptorRingMSR23"=0,"ANEScheduler"=1,"OSValueObject<PMAssertStruct>"=32,"APFSOSNumberAtomic"=4544,"HSAIDReceivePacket"=0,"IODPVirtualPortService"=0,"AppleT6030SOCTuner"=1,"AppleConvergedIPCBTIDevice"=0,"IosaRdmaControlMSR11"=1,"AppleHPM"=2,"AppleARMPWMBacklight"=0,"IOGPUFenceMachine"=1,"OSValueObject<void*>"=0,"ApplePMPv2UserClient"=0,"AppleIntelUSBXHCICommandRing"=1,"AUAASEndpointDictionary"=0,"IOHIDEventDummyService"=0,"IOCryptoAccelerator"=1,"AppleH13CamInFrameReceiverBufferPool"=0,"AppleBPIC"=0,"AppleSPUTimesyncV1"=0,"IOFramebufferParameterHandler"=0,"AppleSetDroopUtilizationControlEffortFunction"=0,"IOThunderboltAbstractPath"=1,"AppleBiometricSensor"=1,"KDIShadowedDiskImage"=0,"SalviaFunctions"=0,"AppleHPMInterfaceType16"=0,"AppleARMFunctionAssertReset"=1,"IOAccessoryPowerSourceItemDebounce"=0,"IOHIDSystem"=1,"IOSEPBiometricService"=1,"IOUSBDeviceController"=1,"AppleHIDTransportProtocol"=1,"HSAIDTransmitCommand"=0,"AppleHPMARM"=1,"M2ScalerScalingASEControlMSR10"=1,"IOGPU"=1,"IOTimeSyncNetworkPortUserClient"=0,"IOThunderboltFrameList"=18,"AppleMCA2Switch_Selector"=5,"AGXParameterManagementVirtual"=25,"ApplePCIePIODMA"=1,"M2ScalerScalingASEControlMSR23"=0,"IOAVCommandGate"=5,"MesaAccessoryIntReportError"=0,"DCPAVServiceProxyUserClient"=0,"IOPortTransportComponentCCUSBPDSOPp"=2,"AGX3DChannelGen2"=1,"AGXRepeatedMemoryDescriptor"=0,"AppleBCMWLANBusSkywalk"=0,"ANEMessage"=0,"IOAVVideoInterfaceConcreteUserClient"=0,"AppleBTM"=1,"IOThunderboltNub"=2,"AppleM2ScalerCSCHalMSR16"=1,"AppleUSB30XHCICardReaderPort"=0,"IOThunderboltStatistics"=3,"IOAESAcceleratorUserClient"=0,"IODPHDMIPortController"=1,"IosaDPEControlMSR16"=1,"IOSurface"=1106,"AppleSmartIOPerf"=1,"IOHIPointing"=0,"HSAIDAckPacket"=0,"M2ScalerScalingControlMSR2"=0,"AppleSPUFirmwareService"=1,"IOAudioTimeIntervalFilter"=0,"AppleParadeDP865TCON"=0,"WCLTrafficPatternAgent"=0,"TSNITimeSyncHandler"=0,"IOI2CInterface"=0,"RoswellAuthI2CRelayInterface"=0,"AppleBCMWLANCommander"=0,"IOUSBMassStorageUFIDriver"=0,"IO80211PacketDescriptor"=0,"IOThunderboltDebugBlock"=1,"AIDCircularWriteBufferShared"=0,"IODeblocker"=0,"ApplePMGRFunctionGetValidPerfState"=0,"IO80211BssManager"=0,"IOHDCPMessageTransport"=1,"AppleUSBHostDMACommandPool"=4,"ACMRestrictedModeKernelService"=1,"IosaInternalPipe"=1,"IOFastPathField"=0,"AGXLateEvalEventFence"=0,"IOSCSIMultipathedLogicalUnit"=0,"IOSkywalkBSDClient"=2,"IosaFilmGrainPipeUnitMSR16"=0,"IODPCECController"=0,"IOThunderboltConnectionManagerType5"=3,"AppleStockholmRingBuffer"=0,"AppleBCMWLANIO80211APSTAInterface"=0,"OSValueObject<ANECoredumpSection>"=0,"AppleThunderboltNHIReceiveRingManager"=1,"H13ISPSharedClientBufferArgs"=0,"AppleFairplayTextCrypter"=1,"SEPEpoch"=0,"IO80211NANSubscribeServiceDescriptor"=0,"IOTimeSyncUnicastUDPv6EtEPort"=0,"AGXArmFirmware"=1,"IOThunderboltJTAG"=3,"MSR23ChromaDownsampleFilter"=0,"AppleMultiFunctionPlatformExternal"=0,"IOFDiskPartitionScheme"=0,"AppleANEPerfCounterReadFunction"=0,"AppleUSBUserHCIResources"=1,"AppleGPIOUserClient"=0,"IOTimeSyncNanosecondSnapshotService"=0,"DCPDPDeviceProxyUserClient"=0,"IODARTVMSpace"=923,"IosaWdmaControlMSR23"=0,"IISAudioIsolatedStreamECProxy"=0,"IOUserNetworkTxCompletionQueueCompat"=0,"AppleSDXCBlockStorageDevice"=1,"IOThunderboltConnectionManager"=1,"AppleTypeCRetimerCrashReport"=0,"IOGPUResource"=1,"AppleBCMWLANCallbackEventSource"=0,"IORangeAllocator"=422,"WCLController"=0,"IosaFilmGrainControl"=1,"IOAccessoryIDBusTransport"=0,"TSNPacketPool"=0,"M2ScalerSrcDestCfgControlMSR7"=1,"RTBuddyBinaryLogHandler"=13,"IODPDeviceConcreteUserClient"=0,"AppleThunderboltHALType5"=3,"IOAccessoryIDBusBulkData"=0,"AppleUSBAudioPlugin"=0,"IOTimeSyncTimeSyncTimePort"=1,"AppleUSB20XHCITypeCPort"=1,"ApplePCIeCPIODMA"=3,"IOAVAUPPacket"=0,"AppleSPUALSSealionDriver"=0,"IOTimeSyncUserFilteredServiceDaemonClient"=0,"IOCECUserClient"=0,"IosaPowerManagerMSR20"=0,"IosaFirmwareControlMSR23"=0,"AppleASMedia3142USBXHCIUserClient"=0,"IOPortTransportProtocolAppleUVDM"=0,"AppleBCMWLANTimeTrace"=0,"IosaTiledCompressedMemMSR8"=1,"AppleARMNORFlashDevice"=3,"AppleTDMAKSCommand"=0,"IOAccessoryIDBusSystemStates"=0,"AppleUSB30Hub"=2,"AppleSmartBatteryUserClient"=0,"AppleThunderboltNHIType7"=0,"IOWorkQueue"=1,"FilmGrainSynthesizer"=1,"IOInterleavedMemoryDescriptor"=0,"IO80211InfraPeer"=0,"IOAccessoryIDBusHIDDevice"=0,"AEARuntimeRegisterPatchForI2C"=2,"IOTimeSyncDomain"=1,"AppleMCA2Switch"=1,"AppleSecondaryAudioFunction"=1,"IOAudioPort"=0,"AppleSPIBiometricSensor"=1,"AppleSPIMCControllerStats"=3,"AppleBCMWLANPCIeSkywalkRxCompletionQueue"=0,"IOHIDAccelElementProcessor"=0,"AppleUSBXDCIARM"=1,"IosaTunableControlMSR22"=0,"AppleASMedia1042USBXHCI"=0,"AppleOLYHALPlatformFunction"=1,"OSValueObject<ANEInDebugWorkProcessorRPCRequest>"=0,"IOAudioTimeIntervalFilterIIR"=0,"IOTimeSyncTranslationPMGR"=0,"AppleImage4"=1,"IOUSBDeviceControlRequest"=3,"IOGPUDeviceAssertion"=0,"HSAIDUserClientAccessory"=0,"KopsiaFunctions"=0,"IOUserEthernetController"=0,"IODARTVMAllocatorMPM"=0,"IOSkywalkRxSubmissionQueue"=5,"IOFilterScheme"=0,"AppleThunderboltNHIReceiveRingManagerType5"=1,"AppleSPUCT725"=0,"IODPPortUserClient"=0,"IOUSBHostDevice"=17,"AppleUSBXHCITransferRing"=39,"IOThunderboltDispatchContextAbstract"=1,"IosaRevertPipeUnit"=0,"AppleDialogPMUUserClient"=0,"M2ScalerSrcDestCfgControlMSR17"=1,"ANEHWDevice"=1,"IOAVEventLog"=3,"ApplePMGRUserClient"=0,"AppleT8112USBXDCI"=0,"AIDUserClientLogger"=1,"AppleUSBACMData"=1,"AppleEmbeddedNVMeDiagnostics"=0,"IOSerialStreamSync"=3,"IORS232SerialStreamSync"=0,"RegStream"=1,"IOThunderboltSwitch"=2,"IOAVVideoColorElement"=0,"IOTimeSyncSyncUserClient"=0,"AUCUserClient"=0,"AppleT603XDisplayCrossbar"=1,"IOServiceNotificationManager"=31,"MogulAuthSMCRelayInterface"=0,"AppleT8142ATCDPXBAR"=0,"IOAudioControl"=0,"MailBox"=0,"IOPort"=3,"ApplePMPv2"=1,"IOThunderboltTransmitCommand"=3,"IOPowerConnection"=464,"IODisplay"=0,"AppleBCMWLANCommand"=0,"IOHIDUserDevice"=1,"ANENotificationMsg"=0,"AppleUSBUserHCI"=0,"IOGPUVnioDesc"=0,"AppleMCA2Tx"=4,"AppleDiagnosticDataAccessReadOnly"=1,"IOHIDKeyboardDevice"=0,"IO80211HistogramReporter"=0,"IOThunderboltTracebuffer"=9,"AGXLateEvalEventTable"=1,"AppleRSMChannelTestClient"=0,"WCLConfigManager"=0,"AppleSPUALSSealionAccessoryDriver"=0,"IOAccessoryPowerSourceItemBehavior"=0,"AppleARMPerformanceControllerFunctionCPUIdle"=0,"AppleAOPAudioHallDevice"=0,"IOSerialDriverSync"=0,"AppleMMIOSerial"=1,"OSValueObject<SMCNotification>"=8,"FrameDescriptorRing"=0,"AppleHIDTransportManagement"=1,"AppleSPUFastpathDriver"=0,"IODataQueueDispatchSource"=26,"AppleSMCClient"=6,"IOThunderboltXDPropertiesDirectory"=6,"IOMobileFramebuffer"=1,"RTBuddyFirmware"=11,"IODPSACAggressorTable"=0,"IOTimeSyncService"=2,"AGXRestartReport"=0,"AppleOLYHALUART"=1,"APCIECPortControlFunction"=0,"IOGPUSegmentResourceList"=1,"IOCatalogue"=1,"IONVMeEffaceableDevice"=0,"SCSITaskUserClient"=0,"AppleTDMAKSServices"=0,"IOPlatformExpertDevice"=1,"AppleHPMUserClient"=4,"AppleMemCacheController"=1,"AppleUSBHostUserClient"=0,"AppleBCMWLANPowerManager"=0,"AppleSmartIODMAController"=1,"AGXSecureGart"=1,"IO80211NANPeer"=0,"AppleSPUALSSunfishDriver"=0,"AppleMxWrapACIO"=3,"IOTimeSyncReverseSync"=0,"AppleUSB20XHCILightningPort"=0,"AHTFunctionInfo"=3,"RTBuddyTraceKitMessageEncoder"=18,"RTBuddyTimeDecoder"=14,"AppleAOPAudioAssetManagerDevice"=0,"ANEClientHints"=1,"AppleM2ScalerCSCHalMSR6"=1,"AppleUSB20Hub"=6,"IOUSBMassStorageDriverUFIDevice"=0,"IOECStateNotifier"=0,"AppleUSBHostBusCurrentClient"=3,"CCFaultReport"=0,"IosaDPEControlMSR10"=1,"IOSCSIPrimaryCommandsDevice"=1,"IOThunderboltReceiveQueue"=1,"AppleBCMWLANNearbyDeviceDiscoveryAdapter"=0,"AppleActuatorDevice"=1,"IOUSBHostPipe"=1,"ANEProgramLegacyResource"=0,"RTBuddyCrashlogDecoder"=14,"IO80211Buffer"=0,"AppleS8000DWIBacklightFunction"=0,"AppleRSMChannelServerClient"=0,"IOStateNotificationItem"=4,"RTBuddyScmDecoder"=14,"AppleSEPCoreBuffer"=0,"AppleExternalPowerProvider"=15,"AppleMobsiTmpSADC"=0,"AppleEmbeddedAudioGroup"=0,"IOBluetoothWorkLoop"=0,"AppleBCMWLANLogger"=0,"OSString"=51850,"AppleUSBXHCIRequest"=296,"IOSurfaceMemoryPool"=0,"AppleSEPDiscovery"=1,"IOHIDOOBReportDescriptor"=0,"IOSlaveProcessor"=2,"IOAccessoryPowerSourceItemUSB_DataContactDetect"=0,"IOThunderboltHopSet"=166,"IOBluetoothHCIUserClient"=1,"IOTimeSyncgPTPManagerUserClient"=0,"AppleHPMInterfaceType10"=3,"AppleSMCPMU"=1,"IOTextCrypter"=1,"IOHDIXHDDriveOutKernelUserClient"=0,"ANEInVMAllocator"=0,"IosaAxi2AfControl"=1,"IOSurfaceDeviceCache"=1000,"AppleARMNORPanicLog"=0,"ApplePMGRFunctionEnablePSDService"=0,"AppleAPFSContainerScheme"=3,"AppleGasGaugeUpdate"=0,"AppleDieTempControllerUserClient"=0,"AppleSPUSingleShotReporter"=0,"AppleTCControllerType12"=0,"AppleBacklightDisplay"=0,"AppleASCWrapV6SISP"=0,"AppleBCMWLANRxByteRing"=0,"EndpointSecurityDriver"=1,"_IOServiceInterestNotifier"=392,"AGXFirmware"=1,"IOBlockStorageServices"=1,"IOThunderboltArray"=20,"AppleHPMCommandGate"=5,"AGXEnergyAttributor"=1,"ApplePMGRFunctionSetATCDpClockSource"=0,"M2ScalerScalingControlMSR7"=1,"IosaColorManagerMSR9"=0,"AppleSynopsysDRDUSBXHCI"=0,"IOPortTransportComponentCC"=1,"IOHIDButtonElementProcessor"=0,"IOAVAudioInterfaceUserClient"=0,"AppleInterruptControllerUserClient"=0,"AppleSmartBattery"=1,"RTBuddyCL4Coredump"=0,"AppleSARTMarconi"=0,"IOGPUSysMemory"=1,"IOAccessoryEAInterface"=0,"AppleVTempDispatcher"=0,"IOPortFamily"=4,"AppleAPFSVolumeBSDClient"=12,"IOSkywalkPacketBufferPool"=2,"ANEDriver"=1,"IOBiometricSensorInterface"=1,"BootPolicyUserClient"=10,"AppleUSBHostResourcesTypeC"=1,"AppleUIOPCI"=0,"IOPortTransportComponent"=1,"AppleFirmwareUpdateKext"=1,"AppleHPMDevice"=11,"IO80211ApFeatureConfig"=0,"InterruptCommand"=72,"WCLTimerFactory"=0,"AppleM2ScalerCSCHalMSR13"=1,"IO80211RoamProfile"=0,"AppleEmbeddedPCIEPort"=1,"AppleSocHot"=0,"AGXLateEvalEventResourceManager"=1,"RTBuddyBinaryLogEntryHandlerSysLog"=6,"AppleSPUHapticsManagerUserClient"=0,"IOTimeSyncPort"=1,"AppleDialogSPMIPMUFunction"=0,"NVMeSEPNotifier"=1,"AppleEmbeddedNVMeController"=1,"AppleOLYHALPortInterfacePCIe"=1,"AppleBTMDataClientSMC"=0,"IOTimeSyncgPTPManager"=1,"IOAccessoryManagerOrion"=0,"ApplePPMPredictivePmax"=44,"AppleCallbackPowerSourceProvider"=1,"AppleSPUCoexParams"=0,"IOHITabletPointer"=0,"IO80211ColocatedGroup"=0,"AGXAcceleratorG15X"=1,"IOGPUResourceSet"=2,"IOTimeSyncTimeLineFilter128"=0,"AppleCSI2CAudio"=0,"IORTC"=0,"WCLBSSBeacon"=0,"IOAudio2DeviceUserClient"=7,"AFKRemoteSMCClient"=0,"AppleBCMWLANChipManagerPCIe4350"=0,"IOAccessoryHSAIDBulkData"=0,"AppleHIDKeyboardEventDriver"=0,"CommonFsmManager"=0,"IosaColorManagerMSR11"=1,"AppleNVMeTranslationSMARTUserClient"=0,"AppleMCA2Switch_ClockGenCfg"=4,"AppleConvergedIPCLogger"=0,"AHTFunction"=3,"AppleARMWatchdogTimerFunctionExpireWatchdog"=0,"IOSimpleReporter"=817,"IosaRdmaPipeUnitMSR23"=0,"AppleT6030PMGR"=1,"IOHIKeyboard"=0,"M2ScalerScalingControl"=1,"BinaryEncoderManager"=0,"IOSurfaceShared"=48,"AppleBCMWLANChipManagerPCIe4388"=0,"ApplePMGRFunctionROSC"=0,"AppleThunderboltNHIReceiveRing"=1,"AppleARMDMAAudioDevice"=1,"AppleUSBXDCITRBPool"=6,"IOHIDParamUserClient"=4,"AppleThunderboltDPOutAdapterOS"=0,"IOPMGR"=1,"IosaRdmaControlMSR25"=0,"IOAudioTimerEvent"=0,"OSValueObject<IOAccessoryIDBusTransport::TransferData>"=0,"IOUserNetworkPacketQueueCompat"=0,"AppleThunderboltNHITransmitRingGenericACIO"=1,"IOMobileFramebufferLegacy"=0,"AppleAOPAudioDeviceProvider"=0,"IOPanicPlatform"=0,"IOHIDPowerSourceController"=1,"AFKEPInterfaceServiceKextV2"=39,"IOSkywalkController"=0,"IosaFirmwareControlMSR23Rtk"=0,"OSMetaClass"=0,"ApplePMPControlFunction"=0,"AIDUserClient"=0,"ApplePPMPolicyCPMSPowerServo"=1,"IODPControllerConcreteUserClient"=0,"AppleSPUGpioUnplugDriver"=0,"IO80211SkywalkInterface"=0,"AppleMultiFunctionManagerLogger"=0,"AppleT600XATCDPXBAR"=0,"OSValueObject<H13CamInChannelDataFileParams>"=0,"HSAIDPacket"=0,"AppleUSBIORequest"=380,"AppleT8112DisplayCrossbar"=0,"IO80211Stopwatch"=0,"AGXPerfCtrSamplerGen15"=1,"AppleBCMWLANSkywalkRxCompletionQueue"=0,"AppleAOPAudioPCMAssetManagerUserClient"=0,"AppleAOPAudioCodecRequestCompletionFunction"=0,"IOUSBDevicePipe"=12,"IOThunderboltFamilyUserClient"=0,"AppleParadeDP835TCONI2CPLS"=0,"AppleConvergedIPCPool"=3,"AppleMemCacheDataSetsFunction"=6,"AGXUSCPrivMemFList"=16,"AppleARMQuadSPIDeviceUserClient"=0,"IOHDCPInterface"=1,"AGXUniqueResourceSet"=0,"IosaColorManagerMSR18"=0,"AppleConvergedIPCRTIDevice"=1,"ApplePPMCPMSSystemCapabilityMonitor"=1,"IosaInternalPipeMSR"=1,"StockFunctions"=0,"IO80211ControllerMonitor"=0,"IOAVSerializer"=23,"IOHIDAction"=0,"AppleConvergedIPCMemoryPolicyInfo"=1,"IOThunderboltTRMPolicy"=1,"IOThunderboltTransmitQueue"=1,"IOAVAudioInterface"=0,"IODisplayWrangler"=1,"AUAADC3ClassSpecificDescriptorFetcher"=0,"IOWatchdog"=1,"IODPDeviceUserClient"=0,"AppleT8101USB20XHCILightningPort"=0,"IOThunderboltTimerCommandQueue"=3,"IOPortTransportStateSD"=1,"KDIReadWriteDiskImage"=0,"IOSkywalkInterface"=2,"AppleThunderboltNHISubMemoryBlock"=27,"IOAVBControllerHelper"=0,"ApplePMGRFunctionPLLOffMode"=0,"AppleConvergedIPCMemoryCommandPool"=3,"ApplePMGR"=1,"IosaInternalPipeMSR15"=1,"AppleUSBECMDataNC"=0,"AppleMAXI2CAudio"=0,"IO80211FaultReporter"=0,"AppleTrustedAccessoryAnalytics"=1,"IOAccessoryManagerUSBC"=1,"AppleUSBXHCIInterrupter"=13,"AppleConvergedIPCControl"=1,"AppleSEPLoggerService"=0,"SMState"=234,"IOHIDActionQueue"=0,"IOTimeSyncDaemonUserClient"=1,"IO80211StaticBufferPool"=0,"IOUserNetworkTxSubmissionQueue"=14,"IO80211AWDLProtocol"=0,"AppleThunderboltPCIUpAdapter"=7,"AppleMxWrap"=1,"AppleUSBXHCIEndpointSoftRetry"=0,"DCPDPDeviceProxy"=3,"AppleAuthCPI2C"=0,"AppleUSBXHCIRequestPool"=5,"AUC"=1,"GTraceBuffer"=3,"ANEClientInterface"=0,"AppleSEPTraceBuffer"=0,"IOUSBMassStorageDriver"=1,"AppleDPTXPort"=0,"ApplePPMEntityCLPC"=2,"IOHDIXControllerUserClient"=0,"AppleThunderboltPCIDownAdapter"=8,"AppleMCA2MCLKPin"=4,"AUASelectorUnitDictionary"=0,"AppleConvergedIPCUserClient"=0,"com_apple_AppleFSCompression_AppleFSCompressionTypeDataless"=1,"MesaAccessoryManager"=1,"AppleT8006GPIOIC"=0,"AppleS5L8960XGPIOIC"=0,"IOSCSIBlockCommandsDevice"=1,"WCLWnmAgent"=0,"RTBuddyEndpointService"=106,"IO80211TimerSource"=0,"AGXAllocationList2"=18,"AppleT8130USBXHCICommandRing"=0,"RequestTimeOutInfo"=0,"ApplePPMEntityBaseband"=0,"AppleMCA2Switch_TxCfg"=8,"AppleH13CamInFrameReceiver"=0,"AppleUSB20AccessoryHub"=0,"AppleThunderboltDPOutAdapterBase"=1,"ApplePMGRFunctionGetServiceState"=0,"IOPortFeaturePowerSource"=3,"USBStringIndex"=3,"IosaInternalPipeMSR6"=1,"GTCondition"=3,"AppleHIDTransportStats"=1,"PhloxFunctions"=0,"MCClient"=4,"ApplePMGRFunctionSetTouchClockSource"=0,"M2ScalerSrcDestCfgControlMSR15"=1,"AppleHPMInterfaceType17"=0,"IOThunderboltConfigXDomainLinkStatusRequestCommand"=0,"IOCommandPool"=90,"IOSlaveMemory"=1,"IOTimeSyncEthernetConcreteControllerAdapter"=0,"AppleEmbeddedPCIEUserClient"=0,"AppleThunderboltNHITransmitRingType5"=12,"AppleUSBHostCompositeDevice"=8,"IOHIDEventRepairDriver"=0,"AppleBaseAudioController"=1,"AppleBCMWLANPCIeSkywalkTxSubmissionQueue"=0,"AppleFirmwareUpdateUserClient"=0,"IOSystemStateNotification"=1,"BellisFunctions"=0,"AppleMCA2Cluster"=1,"IOHIDEventQueue"=0,"IOAccessoryIDBusEA"=0,"AppleUSB30XHCITypeCPort"=1,"AppleThunderboltNHITransmitRingType7"=0,"DIFracturedMemoryMap"=0,"ApplePMPUserClient"=0,"AppleCLCD2"=0,"AppleAuthCPAID"=0,"AGXLegacyGartG15"=0,"AppleASMediaUSBXHCIIsochronousRequest"=0,"AppleUSBSparseArray"=6,"IOAVControlInterfaceUserClient"=0,"IOKDP"=0,"IOPortTransportStateUSB"=1,"IOThunderboltSwitchType1"=0,"IOThunderboltReceiveCommand"=16,"IOAccessoryTransport"=0,"IOHIDDeviceElementContainer"=23,"AppleBCMWLANDynamicRingOperationContext"=0,"KDIBackingStore"=0,"IORegistryPlane"=8,"AppleSPUCT726"=0,"AppleSPUHIDDevice"=8,"IOThunderboltConfigXDomainRequestCommand"=0,"CCDataPipeBlob"=0,"IOAVSimpleVideoInterface"=0,"IOFramebufferUserClient"=0,"AppleARMPerformanceControllerFunctionCLPCEnabled"=0,"AppleARMFunction"=55,"CCCapture"=0,"AppleBCMWLANPCIeSkywalkPacketPool"=0,"AFKEndpointInterfaceClient"=42,"AppleConvergedIPCOLYBTCoreDumpProvider"=1,"OSValueObject<int>"=0,"ApplePPMSystemCapabilityMonitor"=1,"TSNBSDTestInterface"=0,"APCIECPort"=1,"IOAccessoryIDBusPD"=0,"IOUSBDeviceInterfaceReserved"=0,"_IOOpenServiceIterator"=0,"AppleAPFSSnapshot"=1,"AppleUSBECMData"=0,"IOThunderboltConfigXDomainPathSetupRequestCommand"=0,"AGXWorkQueue"=3,"IOAVBValidate"=1,"_IOMemoryDescriptorMixedData"=7113,"IOSurfaceRoot"=1,"CCDataPipeBlobOD"=0,"ApplePPMCPMSPowerInputHelperBatteryFirmware"=0,"IOThunderboltConfigXDomainPathCapabilitiesRequestCommand"=0,"IODiskImageBlockStorageDeviceInKernel"=0,"AppleHPMARMI2C"=0,"AppleUSBUserHCIIsochronousTransferQueue"=0,"AppleSimpleUARTCommand"=32,"AUCAsynchronousScheduler"=1,"AppleM68Buttons"=1,"OSSerialize"=1,"AppleT8112DPTXPort"=0,"IOTimeSyncTimeOfDayAnchorPort"=0,"AppleARMCPU"=12,"IOAVUserClient"=0,"AppleCT711"=0,"DitherControlMSR23"=0,"IOHIDEventServiceUserClient"=141,"AGXTAChannelGen2"=1,"IOHIDEventSystemUserClient"=1,"IOSlaveMemoryBuffer"=26,"IOHIDRootElementProcessor"=0,"AppleSMCFamily"=1,"IOGPUNotificationQueue"=18,"IO80211WorkSource"=0,"AppleThunderboltNHIDARTVMAllocator"=72,"AppleBiometricSensorEmulatorBaseClass"=0,"IOTimeSyncIntervalFilterIIR128"=0,"IONVRAMController"=1,"AppleCplBTM"=1,"OSValueObject<ANEProgramToANEMapping>"=0,"IOHIDTranslationEventReq"=0,"OSValueObject<ANEFirmwareCommandState>"=0,"ApplePPMPolicyCPMS"=1,"AGXAsyncGrowEngine"=16,"AppleMultitouchHIDEventService"=0,"AppleEmbeddedExternalAudioObject"=0,"AppleGasGaugeUpdateUserClient"=0,"AppleUSBUserHCITransferStructPool"=0,"AppleSPURemoteCrashdump"=0,"IOAccessoryPowerSourceItemCurrentBase"=0,"AppleARMPMUSensor"=2,"IO80211NeighborCache"=0,"KDIURL"=0,"AppleARMFunctionPerfAdvise"=0,"IOUserEthernetInterface"=0,"AFKEPKextBaseV2"=1,"AppleM2ScalerCSCHalMSR10"=1,"IOThunderboltCallbackEventSource"=5,"AppleUSBXDCI"=1,"AppleATCDPNativePort"=2,"MesaCachedSystemConfig"=1,"IOThunderboltConfigCompareSwapCommand"=5,"IOPortFeatureLDCMUserClient"=3,"IOUserNetworkRxSubmissionQueue"=2,"IOAccessoryAuthProtocolInterface"=0,"IORSMChannel"=0,"IOThunderboltProtocolListener"=3,"AppleBCMWLANSkywalkMulticastQueue"=0,"AppleUSBXHCIARRequestPool"=0,"KDIDiskImageNubUserClient"=0,"AGX3DWorkQueue"=25,"IOUSBMassStorageUFIDriverNub"=0,"IosaDPEControlMSR21"=0,"AIDQueueEventSourceWorkItem"=0,"AppleParadeDP835TCON"=0,"MesaAccessoryIntReportImageInfo"=0,"AVE_Thread"=1,"IOInterruptEventSource"=304,"AppleHIDTransportBootloaderCBOR"=1,"AppleH13CamInFrameReceiverBuffer"=0,"AppleUSBHostInterfaceUserClient"=0,"IONVMeLifeboatBlockDevice"=0,"AUAFeatureUnitDictionary"=0,"IOTimeSyncPortManager"=0,"AppleMCA2Switch_ClockGenSel"=1,"IOAVAsyncEventSource"=5,"IO80211PeerBssSteeringManager"=0,"IOSurfaceAcceleratorClient"=0,"AGXCLChannelGen2"=1,"OSAction"=166,"AppleUSBXHCIPipe"=39,"IO80211AWDLPeerManager"=0,"IOPlatformIO"=1,"_IOServiceJob"=0,"IOBluetoothACPIMethods"=1,"AGXCommandDescriptor"=1,"AppleUSBUserHCIPort"=0,"AppleThunderboltNHITransmitRingManagerGenericACIO"=1,"IOKitDiagnosticsClient"=0,"AIDCircularReadBufferShared"=1,"TextCrypterSession"=0,"IosaDirectionalScalingPipeUnit"=0,"AppleBCMWLANStopwatch"=0,"IosaTunableControlMSR23"=0,"IOUSBHostHIDDevice"=0,"AppleTDMType00"=0,"AppleDiskImageDevice"=0,"AppleUSB30XHCIPort"=3,"H13ISPClientMappedSurface"=0,"DCPDPServiceProxy"=3,"IODPLegacyDualDVIService"=0,"AppleHIDTransportBootloaderFlatPack"=0,"TSNWiFiControlInterface"=0,"IosaWdmaControlMSR11"=1,"AFKOOBMsgDescriptor"=0,"TSNWiFiInterface"=0,"IOAccessoryOOBPairingInterface"=0,"AppleDockChannel"=1,"AMCTempSensor"=0,"AppleSPUDispADCDriver"=0,"IOPortTransportStateIIC"=0,"IO80211NANServiceDescriptor"=0,"IONetworkController"=1,"AppleARMFabricTrace"=0,"AppleButtonsDispatchFunction"=1,"IOAccessoryPort"=0,"IODPTXPortEventLog"=14,"PMTraceWorker"=1,"AppleGCResourceDeviceUserClient"=1,"IOAVTransactionLog"=0,"AppleARMNORNVRAM"=1,"IODPHDMIPortUserClient"=0,"AppleBTMDataClientPPM"=0,"KDIFileBackingStore"=0,"OSValueObject<AsyncCommitParam>"=0,"AppleAOPAudioFWdtAssetManagerDevice"=0,"H1xANELoadBalancerClient"=0,"IOAVElementArray"=0,"CoreKDLDriver"=1,"IOPMRequestQueue"=2,"IODTNVRAMPlatformNotifier"=1,"IODARTPIOAllocatorGeneric"=0,"HIDMTQueueEventSource"=1,"OSLiveNumber"=12,"AppleSPUAppDriver"=1,"IOI2CInterfaceUserClient"=0,"AppleBCMWLANChipManagerPCIe4387"=0,"AppleASMediaUSBXHCIStreamingEndpoint"=0,"AppleS5L8920XPWM"=0,"AppleARMTraceController"=0,"IO80211NANPowerManager"=0,"IOAppleLabelScheme"=0,"IOUSBDeviceUserClientV2"=0,"AppleSMCDockUSB_UFP"=0,"IODPServiceAUXOnly"=0,"DCPAVPowerControllerProxy"=1,"AppleUSBXHCIARRequest"=0,"IOEventLink"=0,"AppleARMSPMIControllerUserClient"=0,"M2ScalerScalingControlMSR10"=1,"OSOrderedSetEquality"=34,"IO80211AWDLMulticastPeer"=0,"ConnectionWatchdog"=0,"AppleThunderboltNHIGenericACIO"=1,"IODPAgileLinkRateTable"=0,"IOTimeSyncIntervalFilter"=0,"IosaDirectionalScalingPipeUnitMSR23"=0,"IOAccessoryOOBPairingInterfaceUserClient"=0,"AppleSPUMesaDriver"=0,"IOPacketQueue"=0,"IosaCSCPipeUnit"=0,"AppleASMediaUSBXHCI"=0,"RTBuddyAutoBKPDecoder"=14,"AppleHPMEmbedded"=1,"AppleATCDPAltModePort"=3,"AppleIPDormancyHandler"=1,"IOServiceNotificationDispatchSource"=0,"IosaRequestPipeUnitMSR23"=0,"AppleBCMWLANNetAdapter"=0,"IOTimeSyncDaemonClientBase"=4,"IOPerfControlClient"=6,"KDIUDIFCacheObject"=0,"IO80211DriverCommandDescriptor"=0,"IOEthernetController"=3,"IOMemoryDescriptor"=2,"IO80211TimeSyncPeer"=0,"AppleStockholmDebugDevice"=0,"AppleT8122PCIePort"=1,"AppleFairplayTextCrypterSession"=0,"IosaPipeUnit"=0,"IOGUIDPartitionScheme"=1,"IOGPUDeviceShmem"=127,"AppleGPIODevice"=15,"KDIUDIFDiskImage"=0,"IOAudioDevice"=0,"ApplePPM"=1,"AFKSharedDataQueue"=1,"AppleUSBHub"=2,"AGXPeakPowerManager"=1,"ACMBridgeKernelService"=0,"AppleM2ScalerCSCHalMSR7"=1,"IosaRdmaPipeUnit"=0,"AppleUVDMPDControllerInterface"=0,"IO80211GASFsm"=0,"AppleUSBAudioStream"=0,"IOSlaveCPU"=1,"CCFaultReporter"=0,"BTDebugService"=2,"AppleBTMFunction"=3,"AppleUSB30XHCIARMPort"=3,"ACMAccessoryCacheKernelService"=1,"AppleConvergedIPCOLYBTControl"=1,"AppleSEPEndpointService"=1,"AGXLegacySharedGartTableBacking"=0,"IODataQueue"=1,"IOSkywalkPacket"=4160,"AppleAOPAudioPDM2Device"=1,"IO80211NANDiscoveryEngine"=0,"AGXUSCPrivMemPool"=1,"UserTimerEventSource"=3,"IOPortTransportProtocol"=0,"ApplePMGRFunctionAvoidPerfState"=0,"AppleT8103PCIeCPort"=1,"IODPServiceUserClient"=0,"AppleANEMPMUnmapMemoryFunction"=0,"IOThunderboltNHITransmitRing"=1,"AppleM2ScalerCSCHalMSR23"=0,"IOAccessoryManagerHSAID"=0,"AppleS8000DWIVoltageFunction"=0,"IOAESAcceleratorCommand"=32,"AppleFileSystemDriver"=0,"AppleThunderboltIPTransmitter"=0,"AppleS8000DWI"=1,"AppleThunderboltDPOutAdapterDelegate"=1,"IO80211ColocatedGroupManager"=0,"IOSkywalkLogicalLink"=5,"AppleHPMInterfaceType11"=1,"OSAction_IOHIDEventService__SetLED"=0,"AppleBCMWLAN11beAdapter"=0,"RTBuddy64"=0,"ANERequest"=0,"AppleBCMWLANWnmAdapter"=0,"AppleParadeDP865TCONSPI"=0,"IODPDevice"=0,"IOUSBHostIOSource"=1,"AppleThunderboltDPInAdapterCM"=1,"AppleBCMWLANChipManagerPCIe0x4377b"=0,"IOAccessoryHIDDeviceEndpoint"=0,"IOAVHandler"=0,"IO80211LinkRecovery"=0,"AppleUSBHostControllerIsochEndpoint"=0,"IOAVAudioChannelLayoutElement"=9,"IOSARTMapper"=0,"IODPTXPort"=2,"IORSMReceiveQueueEntry"=0,"AppleT602XDPTXPort"=0,"IOPCI2PCIBridge"=8,"AppleT8030USBXDCI"=0,"AppleDisplayCrossbar"=1,"M2ScalerCSCColorConversionControlMSR"=1,"AppleJPEGHal"=2,"IOAccessoryBulkDataEndpoint"=0,"ACMKeybagKernelService"=0,"IOMediaBSDClient"=7,"AppleAudioSequenceOperation"=0,"AGXRenderTargetMemory"=1,"IOAVController"=0,"IOTimeSyncInterfaceAdapter"=0,"AppleMemCacheEvent"=0,"AppleThunderboltIPReceiveCommand"=0,"IOAVBTimeSyncCaptureUserClient"=0,"AppleUSBUserHCIRequest"=0,"IOThunderboltPort"=91,"AppleAuthCPMGAID"=0,"RTBuddyNativeSlaveMemoryDescriptor"=0,"AppleSMCPowerOut"=0,"AppleT6020SOCTuner"=0,"mDNSOffloadUserClient"=0,"IOThunderboltI2CCommand"=8,"AppleTII2CAudio"=1,"AppleMultitouchHIDService"=0,"IOUserBlockStorageDevice"=0,"M2ScalerSrcDestCfgControlMSR13"=1,"IO80211QueueCall"=0,"RTBuddyProductVersionDecoder"=14,"IOAccessoryPowerSourceItemPD"=0,"OSObject"=298,"IOHDIXHDDriveNub"=0,"IO80211NANRangingManager"=0,"AGXUATMux"=58,"AppleH13CamInFrameMetadata"=0,"AppleASMediaUSBXHCIIsochronousRequestPool"=0,"IO80211NetworkPacket"=0,"AppleCSCodecMikey"=1,"AppleBCMWLANChanSpec"=0,"IOGPUSubMemoryDescriptor"=0,"IOBluetoothHCIController"=1,"AppleSOCDInterface"=0,"IO80211NANSyncEngine"=0,"IOUSBMassStorageCBIDriver"=0,"AppleBCMWLANHashtable"=0,"AppleMCA2Switch_TxCtl"=8,"AGXAccelerator"=1,"ANEPrivilegedVMAccess"=0,"AppleMCA2Switch_SyncGenCtl"=4,"AppleSystemPolicyUserClient"=2,"RTBuddyNvramDecoder"=14,"IOKitDiagnostics"=1,"IosaColorManagerMSR15"=1,"IOTimeSyncEthernetPort"=0,"WCLJoinManager"=0,"AppleDieTempController"=0,"WCLGASFsm"=0,"AGXBlockFence"=1,"AppleSEPBooter"=1,"AppleBCMWLANChipConfigSpace"=0,"IOUSBHostInterfaceIterator"=0,"IOTimeSyncEthernetModernInterfaceAdapter"=0,"WCLJoinCandidateSelector"=0,"RTBuddySyslogEndpoint"=10,"IO80211NANProtocol"=0,"IOSurfaceMemoryRegion"=1,"OSValueObject<ANEClientContext>"=1,"AppleM2ScalerCSCHalMSR"=1,"AppleBCMWLANSkywalkRxSubmissionQueue"=0,"IOTimeSyncTimeOfDayPort"=0,"IOAVValueSet"=0,"AppleEmbeddedAudio"=2,"com_apple_AppleFSCompression_AppleFSCompressionTypeZlib"=1,"AppleUSBXHCIStream"=0,"CCPipe"=2,"AppleAPFSMediaBSDClient"=3,"AppleAOPAudioButtonOutputDevice"=0,"WCLNetManager"=0,"IOHIDTranslationEvent"=0,"IOGPUIOCommandBuffer"=0,"AppleIOP"=1,"WCLScanCacheStore"=0,"IOAccessoryIDBusSystemStatesUserClient"=0,"ApplePPMPolicyCPMSPowerServoLowerLayerCEs"=1,"IOUserNetworkTxSubmissionQueueCompat"=0,"IOThunderboltTunnelDriver"=4,"IOAVCECInterface"=0,"AppleUSBCDCCompositeDevice"=2,"AGXVirtualMemory"=0,"IOExclaveProxy"=0,"AppleH13CamInUserClient"=1,"IOAVHandlerInternalDisplay"=0,"AppleARMFunctionSlowAdaptiveClockingAggressor"=2,"OSValueObject<ANEDriverRequestParams>"=0,"IOFastPathDescriptor"=0,"AGXGPUMemBlockPool"=0,"AppleSerialShim"=1,"IO80211FlowQueueDatabase"=0,"AppleKeyStoreUserClient"=104,"AppleAMDUSBXHCIPCI"=0,"AppleT6020PCIePIODMA"=2,"AppleUSBAudioEngine"=0,"AppleBCMWLANKeepAliveOffload"=0,"IOPortFeaturePowerIn"=4,"ApplePMGRFunctionISPRefClock"=0,"AppleATCDPOUTAdapterPort"=0,"AppleANS2CGv2Controller"=1,"AGXArmFirmwareASC"=1,"IOThunderboltSwitchI2CCommandQueue"=1,"AppleUSBXHCIPort"=2,"AppleBCMWLANGCRAdapter"=0,"AppleNVMeNamespaceUC"=0,"AppleSmartIOControl"=1,"IOPolledInterface"=2,"IOHIDPointingDevice"=0,"AppleHIDTransportSMCNotifier"=0,"IOHIDProviderPropertyMerger"=0,"IOThunderboltSideband"=1,"IOUserNotification"=2,"AGXParameterBufferBlock"=1,"AppleUSBXHCISparseRequest"=0,"IOUSBDeviceConfigurator"=3,"IOAccessoryManagerUserClient"=0,"AppleTypeCPhyUSBInterface"=12,"IOThunderboltSwitchOS2"=0,"VictimUserClient"=0,"IOHDIXController"=1,"AppleSMCEmbeddedFunction"=12,"AppleMCA2Switch_i2sSel"=1,"AppleConvergedIPCOLYBTLogProvider"=1,"PMSettingHandle"=2,"IOTimeSyncUnicastLinkLayerEtEPort"=0,"RTBuddyRtkitDecoder"=14,"IOGPUBlockFencePort"=18,"OSAction_IOHIDDevice__CompleteReport"=0,"AppleSPUALSDriver"=0,"AppleStockholmSPMI"=1,"ApplePMGRFunctionVideoClock"=0,"AppleUSBHostBusCurrentPool"=0,"IosaPremultiplyAlphaMultiplyPipeUnit"=0,"IOGPUMemoryInfoUserClient"=0,"ACMRestrictedModeAnalyticsKernelService"=1,"IOGraphicsSystemWorkLoop"=1,"IOBioUtils"=0,"AppleARMGPIOFunction"=14,"IONetworkUserClient"=0,"AppleEmbeddedUSBDevice"=0,"IO80211PeerManager"=0,"IOAccessoryIDBusProxyPD"=0,"IOThunderboltIECSNub"=7,"IOAccessoryHSAIDBulkDataEndpoint"=0,"AppleBCMWLANTimeKeeper"=0,"IOPortFeatureLDCM"=1,"IO80211InterfaceMonitor"=0,"IOHIDEventServiceFastPathUserClient"=0,"AppleARMPassthroughPowerSource"=0,"AppleARMSPMIController"=1,"IOMbufNaturalMemoryCursor"=0,"IosaFirmwareControlMSR24Rtk"=0,"AppleAOPAudioLEAP"=0,"AppleARMSFRManifest"=1,"AppleNVMeNamespaceDevice"=2,"IOTimeSyncTimeLineFilter"=0,"ApplePMGRFunctionReconfigTrigger"=0,"IOHIDEventSource"=23,"SEPHibernatorService"=1,"OSValueObject<H13ISPCommandArgs>"=0,"AppleUSBHostFrameworkClient"=1,"IODMAController"=2,"IOAVBNub"=1,"IOAVAudioDMADelegate"=1,"IOPortTransportStateOrderedSet"=1,"DCPAVCECInterfaceProxy"=0,"IO80211WorkQueue"=0,"IOTimeSyncDomainDaemonClient"=1,"AppleUSBNetworkingHostCommandPool"=0,"_HACK_RingBuffer"=0,"AbstractPMGR"=0,"IOMemoryCursor"=0,"AppleUSBCDCControl"=1,"IOGraphicsDevice"=0,"AppleHIDTransportInterface"=7,"OSKext"=393,"IOThunderboltXDLocalPropertiesCache"=3,"IOGPUSurfaceMTL"=0,"AGXSoKGrowEngine"=0,"AppleTDMControlLUN"=0,"IOResources"=1,"IOServiceStateNotificationDispatchSource"=0,"_IOUserServerCheckInCancellationHandler"=0,"IOConditionGate"=2,"IOThunderboltSwitchDelegate"=1,"ApplePMGRFunctionSetPerfState"=0,"RTBuddyMailboxDecoder"=14,"IOUSBInterface"=1,"AppleBCMWLANWorkOrder"=0,"AppleAPFSGraft"=31,"AppleUSBDeviceNCMPrivateEthernetInterface"=3,"IOUSBMassStorageUASDriverCommand"=0,"IOAVBNubUserClient"=0,"AppleARMIICController"=1,"AUAEndpointDictionary"=0,"IOTimeSyncUserFilteredService"=0,"RTBuddyCoredump"=7,"AppleThunderboltNHITransmitRingManagerType5"=1,"AppleTypeCRetimer"=3,"IOAVAudioElement"=9,"IOAccessoryPowerSourceItemExternal"=0,"RTBuddyHeapDecoder"=14,"IosaDegammaPipeUnit"=0,"IOSkywalkPacketQueue"=5,"IOThunderboltLocalNode"=3,"AppleARMPMUTempSensor"=44,"AppleARMFunctionIISActive"=0,"AppleHPMInterfaceType18"=0,"AppleBakuBTM"=0,"AIDSnifferInterface"=0,"AppleMCA2Controller_T6030"=4,"IOServiceStateNotificationEventSource"=0,"AppleBCMWLANHistogram"=0,"AppleUSBXHCITR"=1,"AppleM2ScalerCSCDriver"=1,"IOMemoryMap"=8231,"AppleBTMBatteryDataAgent"=0,"IONetworkData"=22,"AppleTICD2E22"=0,"AppleUIOPCIUserClient"=0,"IOUserNetworkPacketBufferPool"=2,"IOThunderboltData"=3,"AUAConfigurationDictionary"=0,"M2ScalerScalingControlMSR8"=1,"AppleARMSPIDevice"=3,"IOBioSharedMemoryTransferQueue"=0,"AppleUSBAudioComposite"=0,"M2ScalerSrcDestCfgControlMSR6"=1,"AppleRSMChannelControllerClient"=1,"IOUSBMassStorageResource"=1,"AppleSPUMarconiFunction"=0,"AppleTempSensorUserClient"=0,"AppleATCDPXBAR"=1,"IOPortTransportStateUSB2"=11,"AppleT8103USBXDCI"=0,"RTBuddyRoute"=1,"BTDebugReporter"=1,"ApplePPMUserClient"=1,"AUAProcessingUnitDictionary"=0,"AppleSynopsysDRDUSBXHCICommandRing"=0,"AppleT8027USBXHCI"=0,"AGXResource"=4052,"AFKAsyncRequestV2"=0,"IOAudioToggleControl"=0,"AppleLIFSUserClient"=1,"IOGPUMemoryMap"=1,"IOImageLoaderRequest"=0,"IosaWdmaControlMSR25"=0,"AppleHPMBusDevice"=0,"AppleUSBHostBusCurrentAllocator"=42,"IOPCIHostBridge"=2,"DIDeviceCreatorUserClient"=0,"AGXGartG15"=58,"AppleNotificationQueue"=17,"SEPApNonce"=0,"IOThunderboltXDomainLink"=0,"AGXEventMachine"=1,"AppleT8150USBXDCI"=0,"RTBuddySlaveMemoryBuffer"=66,"IOHIDEventDriver"=3,"AppleMesaAccessory"=0,"AppleHPMDeviceHALType3"=4,"HSAIDTransmitCommandPool"=0,"IOSimpleMbufMemoryDescriptor"=0,"IosaRegammaPipeUnit"=0,"AppleM2ScalerCSCHalMSR20"=0,"ApplePassThroughEstBTM"=0,"IOTimeSyncServiceDaemonClient"=5,"IOAVSplitDisplay"=0,"IOThunderboltAbstractMicro"=2,"IOThunderboltCommandQueue"=11,"EventElementCollection"=0,"IO80211NANDataPathSession"=0,"FPMemoryDescriptor"=0,"AppleUSBSerialUserClient"=0,"IOBluetoothLocalUtilityEventSource"=0,"DCPAVAudioInterfaceProxyUserClient"=0,"IOThunderboltCableState"=12,"IOSCSICommandGate"=3,"AppleThunderboltNHIReceiveRingManagerType7"=0,"AppleBCMWLANInfraProtocol"=0,"AppleSEPXARTService"=2,"AppleBCMWLANChipBackplane"=0,"AGXUnifiedAddressTranslator"=0,"WCLBssManager"=0,"AppleUSBUserHCIDevice"=0,"AppleBiometricServices"=1,"TSNAssistedInterface"=0,"ApplePMGRFunctionAssertReset"=9,"AppleEmbeddedSimpleSPINORFlasherDriver"=1,"IOTimeSyncTimeLineFilterIIR"=0,"MesaAccessoryIntReportFingerState"=0,"IOUserNetworkMemorySegment"=472,"AppleMultitouchHIDEventDriver"=0,"ANEClientHintsUserClient"=0,"AppleMCA2Switch_ClockGenCtl"=4,"BootPolicy"=1,"IosaDPEControlMSR17"=1,"AGXCLCommandDescriptor"=0,"AppleOnboardSerialBusInterface"=1,"AHTMemoryDumpExtractor"=0,"IOCECService"=0,"IOCECMergeProperties"=0,"IOUserNetworkPacket"=0,"IOAVDisplayMemoryUserClient"=0,"IODARTVMAllocatorGeneric"=39,"CCLogPipe"=2,"AppleT6000USBXHCICommandRing"=0,"IOPartitionScheme"=2,"IOSkywalkNetworkController"=0,"DCPLink"=3,"KDIUDIFEncoding"=0,"AppleNVMeRequestPool"=1,"IOEthernetInterface"=8,"AppleHIDTransportProtocolNone"=0,"AppleUSB20Hub_32789"=0,"AppleNVMeWorkLoop"=2,"AHTRTBuddyFirmwareService"=0,"KDIDiskImage"=0,"AppleBCMWLANCommandQueue"=0,"AFKBufferMemoryDescriptor"=0,"IO80211AsyncEventUserClient"=0,"IOThunderboltConfigNotifyAckCommand"=4,"IOThunderboltConfigReadCommand"=24,"IOGPUMTLLateEvalEvent"=0,"AppleActuatorHIDEventDriver"=1,"ACMLockdownModeKernelService"=1,"AppleAVE2Driver"=1,"RTBuddyVisibleMemoryImpl"=38,"IOTimeSyncRootService"=1,"IOUSBMassStorageCBIDriverNub"=0,"RTBuddyUnknownDecoder"=14,"AppleMCA2NCO"=1,"AppleTCControllerType1"=0,"IODispatchQueue"=128,"WCL11axManager"=0,"AppleSMCCharger"=0,"ApplePPMSMCInterface"=0,"AppleSPMIController"=7,"IOThunderboltConfigPollQuadletCommand"=0,"IO80211IOUCEventPipe"=0,"AppleThunderboltDPAdapterFamily"=0,"AppleConvergedIPCBTIInterface"=0,"ApplePMGRFunctionWaitForDeviceEvent"=1,"AppleBCMWLANBusInterface"=0,"AppleAVE2UserClient"=0,"AppleNVMeBuffer"=5,"IOTimeSyncUnicastUDPv4PtPPort"=0,"AppleUSB30AccessoryHub"=0,"AppleARMSPIController"=1,"AppleSEPDebugArgs"=0,"AppleMultitouchHIDEventDriverV2"=1,"DCPPowerManager"=3,"IosaTunableControlMSR24"=0,"IOThunderboltConfigXDomainPathControlRequestCommand"=0,"PerfControlClient"=1,"AppleUSBXHCIAR"=0,"AppleConvergedIPCControlUserClient"=0,"IosaRdmaControlMSR10"=1,"ApplePMGRFunctionPDMClockBypass"=0,"IOAccessoryDockUSB_UFP"=0,"AppleSEPLogger"=0,"HibernationService"=1,"TSNUserWiFiControlInterface"=0,"AppleH15PlatformErrorHandler"=1,"AppleBCMWLANPCIeIO"=0,"M2ScalerSrcDestCfgControlMSR24"=0,"AppleUSBRealtek8153Patcher"=1,"IOCommand"=305,"IOAVDeviceUserClient"=0,"IOAudio2Device"=2,"AppleARMIO"=1,"IO80211NANRadioResourceManager"=0,"WCLScanManager"=0,"CoreAnalyticsHub"=1,"IOThunderboltControllerType7"=0,"WCLRoamManager"=0,"AppleT602XATCDPXBAR"=4,"AppleBCMWLANByteRing"=0,"IODARTMapperNub"=113,"IO80211InfraInterface"=0,"MesaAccessoryIntReport"=0,"PassthruInterruptController"=1,"IOAccessoryPowerSourceItemCurrentOffset"=0,"IosaFilmGrainControlMSR23"=0,"IOPortTransport"=0,"IOUSBMassStorageInterfaceNub"=1,"OSCollectionIterator"=245,"AppleBCMWLANTxBuffer"=0,"AppleSMCBinaryLogDriver"=0,"AppleDCPExpert"=3,"IOThunderboltXDPropertiesImmediateValue"=27,"AppleUSBXHCIIsochronousTransferRing"=0,"OSValueObject<ISPCoredumpSection>"=0,"IOUserNetworkWLAN"=4,"AppleARMFunctionIISRoute"=6,"IOThunderboltSwitchOS"=1,"AppleSPUAppInterface"=4,"CommonTimerFactory"=0,"AppleANS3NVMeController"=0,"AppleSmartIOEndpoint"=3,"IODARTMapperClient"=0,"IOHIDDeviceShim"=0,"IODPCECInterface"=0,"AppleMultitouchMouseHIDEventDriver"=0,"IOStateReporter"=299,"AppleSSE"=1,"H13ISPSharedMemorySurfaceParams"=6,"IOAVDisplayConnectionManager"=1,"IOGPUSharedEventFence"=0,"AppleOLYHAL"=1,"IOHIDTranslationServiceClient"=0,"IOBasicOutputQueue"=0,"IOAccessoryPortIDBus"=0,"AppleT8027USBXHCICommandRing"=0,"HSAIDTransmitPacket"=0,"AppleI2CRangedMultipleAudio"=0,"IosaRdmaControl"=1,"AppleProResUserClient"=0,"com_apple_filesystems_apfs"=1,"AppleMesaCommand"=1,"OSEntitlements"=1550,"AppleNVMeRequestPoolTagReserve"=1,"AppleHPMARMSPMI"=4,"AudioDMAController"=2,"AppleSMCACAMUserClient"=0,"IORSMReceiveQueue"=0,"M2ScalerScalingControlMSR23"=0,"AppleUSBAudioIsocFrameList"=0,"IOTimeSyncClockManager"=1,"AppleATCDPOUTAdapterPortBase"=0,"M2ScalerScalingControlMSR15"=1,"IOHIDPointing"=0,"IOSurfaceDescriptorComponent"=0,"AppleThunderboltNHIBufferMemoryBlock"=10,"com_apple_filesystems_nfs"=1,"AppleDisplayConnectionManager"=1,"ApiodmaRegStreamMSR11"=1,"IOImageLoader"=0,"ApplePIODMARequest"=80,"IOSkywalkLegacyEthernet"=2,"ExclavesAudioProxyDebugInterface"=0,"AppleT8142USBXHCI"=0,"AppleAOPSMCFunction"=0,"IO80211NANDataProtocol"=0,"OSValueObject<ANEClientResource*>"=0,"AppleThunderboltDPConnectionManager"=3,"IOThunderboltSwitchType5"=3,"BinaryEncoderHCC2x"=0,"IOBluetoothL2CAPSupervisoryFrameMemoryBlock"=0,"ApplePMP"=0,"AppleSPUHIDInterface"=8,"AppleBCMWLANTaskmaster"=0,"ApplePMGRFunctionEnableAutoClockGate"=0,"ANEProgramRTResource"=0,"IOThunderboltControlPath"=3,"IOThunderboltXDPropertiesLeafText"=6,"AppleThunderboltNHITransmitRingManager"=1,"AppleAOPAudioDeviceControllerObject"=2,"AppleM2ScalerCSCHalMSR8"=1,"DIDeviceRequestPool"=0,"IOAVBTimeSyncCapture"=0,"AppleARMPerformanceController"=0,"AppleNVMeEAN"=1,"IOGPUMappingCommandDescriptor"=0,"AppleT700XTempSensorDisableSensorFunction"=0,"CCLogStream"=2,"AppleTypeCPhyCIOInterface"=3,"IOPMPowerSourceList"=0,"IOUserResources"=1,"IODARTClient"=0,"IOAVBRingBufferMemoryDescriptor"=0,"IOAudioSelectorControl"=0,"ApplePMGRFunctionEnableTouchClock"=0,"AppleThunderboltDPPathManager"=0,"ANEProcess"=0,"IOAVVideoInterfaceUserClient"=0,"IONetworkInterface"=1,"AppleThunderboltUSBDownAdapter"=3,"AppleARMSPICommand"=48,"OSValueObject<ANESharedMemorySurfaceParams>"=2,"IOAccessoryIDBusBulkDataEndpoint"=0,"OSValueObject<ANEInDebugWorkProcessorParams>"=0,"AppleSMC"=1,"IOAccessoryPortIDBusSNTP"=0,"AppleCLPC"=1,"IOThunderboltTRMPolicyRoot"=3,"IO80211PoolMgr"=0,"IOAVIISAudioLinkDelegate"=0,"IOSCSITargetDevice"=0,"IOHIDConsumer"=0,"AppleBCMWLANObjectQueue"=0,"AppleEmbeddedKeyboard"=1,"AppleAOPAudioLPMicInDevice"=1,"AppleBCMWLANBusInterfacePCIe"=0,"RTBuddyEndpointPSEventSource"=14,"AppleARMSlowAdaptiveClockingManager"=1,"IOGPUEventMachine"=1,"IOAccessoryPowerSourceItem"=0,"IODPHDCPMessageTransportDelayContentType"=0,"AGXCLChannel"=1,"AFKLocalMemoryDescriptorManager"=3,"IODPTXVirtualPort"=0,"AppleTCControllerType14"=0,"IOGeneralMemoryDescriptor"=1182,"IOHIDInterface"=23,"AppleUSBUserHCIPipe"=0,"AppleAuthCPUserClient"=0,"IOAccessoryPowerSourceItemUSB_ChargingPort"=0,"CCDataSession"=0,"AGXSharedGartTableBacking"=1,"AppleOnboardSerialBSDClient"=2,"AppleANEPowerOnOffFunction"=0,"AIDLogger"=2,"AppleActuatorDeviceUserClient"=1,"AppleActuatorSecondaryAudio"=0,"AppleAPFSVolume"=12,"AppleBCMWLANPCIeFlowQueue"=0,"AGXUSCPrivMemPoolUMA"=16,"IOUserClient2022"=15,"IO80211ServiceRequestDescriptor"=0,"AppleSmartBatteryHFDataClient"=0,"AppleSmartIOCommand"=240,"IosaReshapePipeUnit"=0,"AppleSPUSpkAmpStateFunction"=0,"IosaDPEControlMSR11"=1,"TSNInterface"=0,"TSNBSDInterface"=0,"AppleUSBAudioControlInterface"=0,"AppleT8132USBXDCI"=0,"IOMedia"=7,"AppleT8101USBXHCI"=0,"TAAsyncReport"=0,"IOAVWAVRecorder"=0,"IOEmbeddedNVMeBlockDevice"=1,"OSValueObject<H13ISPClientContext>"=1,"IOUSBMassStorageDriverRequestTimer"=0,"AppleS5L8920XFPWM"=2,"AppleBCMWLANChipManagerPCIe4357"=0,"IO80211LQMData"=0,"IOThunderboltController"=1,"IOPortTransportStateCIO"=7,"IOThunderboltPath"=5,"IOHIDClientData"=141,"IOSurfaceSharedEventNotificationPort"=15,"AppleTypeCPhy"=1,"USBConfiguration"=3,"IOThunderboltI2CCommandQueue"=1,"IOSKArena"=56,"M2ScalerSrcDestCfgControlMSR2"=0,"IosaPrescaler3x3PipeUnitMSR23"=0,"AppleHIDTransportBootloaderUserClient"=0,"IosaPowerManager"=1,"IORegistryEntry"=3,"AFKACIPCEndpoint"=0,"ANEPrivilegedVMAccessUserClient"=0,"IONotifier"=3,"AppleHDCPManager"=1,"AppleJPEGWrapperControlLegacy"=0,"IOFBController"=0,"IOUserEthernetResourceUserClient"=0,"IOBluetoothDevice"=2,"IOAccessoryPowerSourceItemUSBHost"=0,"IOSkywalkEthernetInterface"=1,"AIDReporters"=2,"AppleSEPXART"=2,"AppleAPFSMedia"=3,"IAGXUSCPrivMemGrowEngine"=1,"AppleBCMWLANProximityInterface"=0,"AppleSEPDeviceService"=12,"AGXAllocation"=4154,"ApplePMGRFunctionPowerGate"=1,"AppleT8122USBXHCICommandRing"=3,"IOTimeSyncClockMapping"=2,"IOHDIXHDDriveOutKernel"=0,"IOReportUserClient"=13,"AppleSmartIO"=1,"AppleSPUHIDDriverUserClient"=2,"RTBuddyCrashlogSectionDecoder"=16,"AppleUSBECMControl"=0,"IOAccelGPURestartReport"=0,"IOUSBHostInterface"=26,"AppleMCA2Switch_i2sCfg"=4,"AFKRTBuddyHelper"=39,"AppleStockholmControlUserClient"=0,"AppleConvergedIPCBTAdapter"=0,"AppleFabricTraceUserClient"=0,"IOAVInterface"=0,"DCPDPServiceProxyUserClient"=0,"IOHIDElementProcessor"=0,"AppleTrustedAccessoryInterface"=0,"ANEProgramResource"=0,"IOSkywalkNetworkBSDClient"=5,"AppleAVDUserClient"=0,"AGXLateEvalEvent"=0,"IOGPUMappingFence"=0,"AppleCallbackPowerSource"=0,"AppleARMIODevice"=155,"IOThunderboltXDomainTransmitPath"=0,"IO80211InfraProtocol"=0,"AppleThunderboltDPInAdapterBase"=1,"AppleT8140USBXDCI"=0,"IOUserNetworkRxCompletionQueueCompat"=0,"IOHIDLibUserClient"=1,"WCLCoreDbg"=0,"AppleI2CAudio"=1,"AppleFDEKeyStoreUserClient"=0,"AppleAOPAudioPCMAssetManagerDevice"=0,"AppleARMBootPerf"=1,"AFKMemoryDescriptorManagerBase"=1,"AppleThunderboltNHIType5"=3,"AGX3DChannel"=1,"AGXLegacySharedGartTableBackingG15"=0,"STUCWorkLoopLock"=0,"OSAction_IOUserNetworkEthernet__DataAvailable"=8,"AppleBCMWLANApFeatureConfig"=0,"AppleBTMBPICAgent"=0,"ANEPatchedWeightInfo"=0,"IOThunderboltConfigXDomainUUIDRequestCommand"=4,"IO80211NANRangingSession"=0,"IOThunderboltXDomainServiceClientManagerMergeProperties"=0,"IOInterruptController"=9,"AppleAOPAudioSawDevice"=0,"IOTimeSyncFDEtEPort"=0,"AppleSEPHDCPManager"=1,"CachedUserContext"=1,"ANEPowerOnMsg"=0,"AppleNVMeRequest"=253,"IOTBTTunnelDriverInterfaceType3"=0,"IosaInternalPipeMSR8"=1,"AppleSeraBTMiPad"=0,"AppleSeraBTM"=1,"IOGPUChannel"=2,"IOHIDDevice"=6,"WCLJoinCandidate"=0,"AFKMemoryDescriptor"=0,"IOUSBMassStorageResourceUserClient"=0,"client_log_buffer_t"=0,"KDIRAMBackingStore"=0,"AppleMCA2Switch_TxSel"=1,"IOMobileFramebufferShim"=3,"AppleI2CRangedAudio"=1,"IOThunderboltString"=186,"IosaTiledCompressedMem"=1,"IOTimeSyncTimedEdgeGenerator"=0,"M2ScalerScalingControlMSR4"=1,"IOInterruptDispatchSource"=1,"IosaEnhancementPipeUnit"=0,"AppleMCA2Regs"=17,"IosaColorManagerMSR10j"=0,"AppleConvergedIPCRequestPool"=1,"IosaDPEControl"=1,"AppleBCMWLANProvisioningManager"=0,"ApplePMGRNub"=3,"IOPortTransportUserClient"=0,"DaisyFunctions"=0,"IO80211SimpleReporter"=0,"ModularDefaultFilter"=2,"IosaColorManagerMSR8"=1,"AppleAOPAudioAmpStateFunction"=0,"IOSCSIHierarchicalLogicalUnit"=0,"AppleConvergedIPCIOCommandPool"=1,"M2ScalerScalingControlMSR"=1,"AppleUSBACMControl"=1,"IOThunderboltXDomainServiceClientManager"=3,"IxoraFunctions"=2,"AppleLEAPController_T6030"=2,"AppleSDXCWorkLoop"=1,"IOThunderboltConfigReadQuadletCommand"=8,"IosaRdmaControlMSR8"=1,"AppleBCMWLANConfigManager"=0,"AppleSDXCSlot"=1,"IOGPUTask"=1,"AppleUVDMUserClient"=0,"IO80211ActionFrameDescriptor"=0,"IosaDegammaPipeUnitMSR23"=0,"IosaPipeControl"=8,"IOGPUMTLFence"=0,"M2ScalerSrcDestCfgControlMSR22"=0,"AppleARMCFIFlashController"=0,"OSValueObject<ANEIOReporter*>"=0,"IOAVBGPIOEdgeTimeCapture"=0,"AFKEndpointInterfaceUserClient"=1,"ApplePPMCPMS"=1,"AGXGFXDVAccessor"=0,"com_apple_driver_AppleUSBMassStorageInterfaceNub"=0,"AppleUSB20XHCIPort"=3,"IOSKMapper"=30,"CryptoBufferDescriptor"=0,"IosaPolyphaseScalingPipeUnit"=0,"AppleARMFunctionChargerMux"=0,"AppleUSBRequestPool"=2,"AppleBCMWLANPCIeCompletionRing"=0,"ApplePMGRFunctionEnableCPUCore"=0,"AppleARM64ErrorHandler"=1,"IOSurfaceSharedEventListener"=7,"ExclavesAudioProxyEndpoint"=0,"AppleUSBHostResources"=1,"ApplePPMCPMSPowerInputHelper"=0,"OSNumber"=101068,"IOThunderboltSwitchIntelJHL9580"=0,"AppleAPFSUserClient"=4,"AppleMCA2Fifo"=4,"AppleHIDTransportDRAMUsageStats"=1,"IO80211ScanCacheStore"=0,"RTBuddyBinaryLogEntryHandlerTraceKit"=6,"IOTimeSyncUnicastUDPv6PtPPort"=0,"AppleJPEGDriverUserClient"=0,"IOPortTransportProtocolCCUSBPDSSAM"=0,"OSValueObject<ANEClientMappedSurfacePR>"=0,"AppleBCMWLANPCIeSkywalkTxCompletionQueue"=0,"IO80211BufferSlab"=0,"AppleCLPCUserClient"=4,"IOHIDResourceDeviceUserClient"=1,"AppleSDXCCommand"=64,"IosaFirmwareControlMSR25Rtk"=0,"IOServiceUserNotification"=716,"IO80211NANServiceManager"=0,"IOSkywalkStatisticsReporter"=32,"IO80211BufferPool"=0,"TransducerState"=0,"IOHDCP2TransmitterAuthSession"=1,"AppleUSBUserHCITransferQueue"=0,"DisplayScalerFilter"=0,"IOAVCommandDelegateService"=0,"OSValueObject<ANEClientMappedSurface>"=0,"AppleARMPMUAccessoryPS"=0,"IOGDiagnosticUserClient"=0,"IOHIDWorkLoop"=1,"IO80211ScanManager"=0,"IOWatchDogTimer"=0,"AppleThunderboltDPAdapterFamilyBase"=2,"IOThunderboltSwitchType2"=0,"IOGPUObject"=16,"AppleT8122USBXHCI"=3,"IOSkywalkRxCompletionQueue"=5,"IOAudioStream"=0,"IOFenceTransaction"=13,"IOUserClient"=37,"CommonFaultReporter"=0,"IOEventSource"=28,"IOGPUStatistics"=1,"IOAccessoryIDBusPDSupplyData"=0,"AGXLegacyMemoryMap"=0,"AppleUSBRequest"=1,"IO80211NANPublishServiceDescriptor"=0,"AppleM2ScalerCSCHalMSR2"=1,"APFSCryptoContext"=0,"IOHIDPowerSource"=1,"AppleM2ScalerCSCHalControl"=8,"AGXBlockedArray"=0,"AppleConvergedIPCSkywalkPacketPool"=5,"IODART"=1,"SEPHibernator"=1,"ANEDriverEventSource"=1,"AppleMesaSEPDriverInterface"=1,"AVE_WorkPool"=1,"IOAVAudioPattern"=0,"IO80211NANDataPeer"=0,"SMTransition"=390,"AppleAuthCPDock"=0,"IOBiometricService"=1,"AppleHPMDeviceHALType5"=0,"AppleARMSPIFlashController"=1,"AppleSOCD"=0,"AppleJPEGDriver"=1,"AppleSEPGenericTransfer"=3,"IOUserSerial"=2,"AppleConvergedIPCInterface"=1,"AppleSPUCT720"=0,"AppleIISAudioLinkDelegate"=0,"AIDInterface"=1,"IOUSBMassStorageDriverUFIStorageServices"=0,"AGXShared"=44,"IOAudioClientBufferSet"=0,"AppleARMWatchdogTimer"=1,"IOBioShareableMemoryObject"=0,"IOMFBSwapIORequest"=0,"IODPSwitch"=1,"OSKextSavedMutableSegment"=17,"ApplePMGRFunctionUSBClock"=0,"AppleUSBXHCIIsochronousRequestPool"=4,"AGXCommandQueue"=18,"AppleSPUControl"=0,"M2ScalerSrcDestCfgControlMSR9"=0,"AGXInternalResource"=273,"IOPortTransportComponentCCUSBPDSOP"=2,"AppleCS42L84Mikey"=1,"AppleSDXC"=1,"IOTimeSyncTranslationMach"=1,"IOFastPathUserClient"=0,"AppleHPMInterface"=2,"AppleHPMIECS"=7,"IOGPUMultiMemoryDescriptor"=0,"AppleBCMWLANTxItemRing"=0,"IO80211P2PDataPathManager"=0,"DitherControlMSR4"=0,"MSR23DefaultFilter"=0,"IO80211CommandGate"=0,"IOSurfaceDescriptor"=0,"AppleEmbeddedNVMeTemperatureSensor"=1,"AppleBakuBTM2"=0,"IOCoastGuardSARTMapper"=1,"AppleM2ScalerCSCHalMSR11"=1,"CCIOReporterLogStream"=0,"IOThunderboltConfigXDomainCommand"=2,"AppleUSBXHCIInterrupterMSI"=3,"ClientObject"=0,"RTBuddyUserClient"=0,"IOAccessoryPortUserClient"=0,"AppleBCMWLAN11axAdapter"=0,"IOMobileFramebufferUserClient"=9,"DCPAVControllerProxy"=5,"AGXSharedGartTableBackingG15"=1,"RTBuddyCallStackDecoder"=14,"IOTimeSyncUserFilteredServiceUserClient"=0,"IOThunderboltConfigXDomainPathSetupCompleteRequestCommand"=0,"AppleT8130USBXHCI"=0,"AppleUSBDeviceNCMData"=6,"AppleGCSyntheticDevice"=0,"AppleDCPLinkServiceSoC"=3,"IOAVSliceVideoInterface"=0,"AppleImage4UserClient"=1,"AppleMCA2Switch_Configurator"=4,"CCIOService"=50,"AGXArmFirmwareMapper"=1,"IOSkywalkNetworkKDPPoller"=0,"IOCancelationWrapper"=0,"AppleThunderboltGenericHAL"=1,"ApplePCIEMSIController"=1,"IOGateLock"=1,"IOThunderboltConfigCommand"=11,"AppleBTMDataClient"=0,"IODPServiceConcreteUserClient"=0,"IOThunderboltMultiMapper"=0,"AppleUSBXHCIIsochronousRequest"=20,"OSValueObject<AltInfo>"=18,"ApplePMGRFunctionResetPSDService"=0,"IOSurfaceDeviceMemoryRegion"=1,"IOAVControlInterfaceConcreteUserClient"=0,"IOPMClientAck"=0,"IosaTunableControlMSR25"=0,"AppleUSBAudioStreamNode"=0,"IONVMeController"=1,"AppleSMCAcamLogHandler"=0,"AppleMCA2Switch_MCAConfig"=1,"IosaRdmaControlMSR18"=0,"AppleHPMInterfaceType1"=0,"IOHIDTranslationService"=0,"AppleUSBAudioInterruptPipe"=0,"ApplePPMKernelClient"=3,"AGXParameterManagement"=1,"IOMesaCaptureDataLocal"=0,"AppleOnboardSerialSync"=1,"IOUSBInterfaceUserClient"=0,"SPUCommand"=12,"IOUserSCSIPeripheralDeviceType00"=0,"IOThunderboltDispatchContextBlock"=0,"ANEPerfRequest"=0,"AppleThunderboltPCIDownAdapterType5"=3,"AppleUSBXHCIARMEndpointSoftRetry"=0,"IOSlaveEndpoint"=2,"IOUserSCSIPeripheralDeviceType07"=0,"AGXScheduler"=1,"VADResourceArbiterUserClient"=0,"AGX3DChannelG15"=25,"AppleAVD"=1,"AGXFenderScratchRAM"=1,"IosaPipe"=0,"IosaDPEControlMSR22"=0,"AGXSpillBufferManager"=0,"AppleConvergedIPCIOCommand"=48,"AppleBCMWLANChipMemory"=0,"AppleUSBXHCIIsochronousEndpoint"=0,"AppleH13CamIn"=1,"IOSKMemoryArray"=0,"IosaColorManagerMSR5"=0,"AppleARMNORPanicLogDevice"=0,"AppleARMCPUPerformanceArbiter"=0,"AppleH13CamInWorkLoop"=1,"AppleSN012776Amp"=1,"IOUserNetworkQueueSet"=0,"IODARTVMAllocator"=1,"AGXLateEvalWait"=0,"IODMAEventSource"=16,"AppleEffaceableStorageUserClient"=0,"AppleUSBXHCIStreamingEndpoint"=0,"AppleCSHTDCodecMikey"=1,"AUAClockSourceDictionary"=0,"AppleHPMLDCM"=1,"IOHIDComplexEventDriver"=0,"IODARTMapper"=119,"AppleMCA2Switch_SerDesCfg"=2,"AppleMobileFileIntegrityUserClient"=0,"IOSurfaceRootUserClient"=48,"ApplePMGRFunctionCLPCEnabled"=0,"AppleIPAppenderUserClient"=0,"IOBioArrayQueue"=1,"IO80211Controller"=0,"AppleBiometricSensorEventSource"=1,"AppleFDEKeyStore"=1,"ApplePMGRFunctionCPUIdle"=0,"IOPortTunnelingTransportState"=1,"AppleARMFunctionEventTimestamp"=1,"AppleUSBNetworkingCommandPool"=12,"IOThunderboltDispatchCallback"=1,"IOPMRequest"=0,"AppleBCMWLANJoinAdapter"=0,"com_apple_filesystems_hfs_encodings"=1,"IOHIDThumbstickElementProcessor"=0,"IosaPrescalerControl"=1,"AppleUSBRequestCompleter"=1,"IOOutputQueue"=0,"AUAOutputTerminalDictionary"=0,"AppleMultiFunctionPlatformEmbedded"=1,"AppleStockholmControlConfig"=1,"IOSKRegion"=132,"ApiodmaRegStreamMSR15"=1,"OSSerializer"=559,"AppleTCController"=1,"AppleThunderboltIPTransmitCommand"=0,"DitherControlMSR"=1,"AppleSMCSensorDispatcherUserClient"=1,"IOAccessoryIDBusUserClient"=0,"AppleUSBHostControllerIsochListElement"=0,"AppleThunderboltIPPort"=3,"ApiodmaRegStream"=1,"IOPortTransportComponentCCUSBPD"=2,"AUAMixerUnitDictionary"=0,"AppleSEPTestingService"=0,"IOGPUIOCommandDescriptor"=0,"IOThunderboltConfigPrepareToSleepCommand"=1,"AppleM2ScalerCSCHalMSR9"=0,"IOUSBDeviceInterfaceUserClient"=0,"AppleTimerQueueEventSource"=2,"IOServicePM"=527,"AudioDeviceCommandFunction"=0,"IOAVAudioInterfaceConcreteUserClient"=0,"IOSkywalkTxCompletionQueue"=5,"RTBuddySavedSegment"=0,"AppleAudioFirmwareDownloader"=0,"AppleParadeDP835TCONI2CTps65177"=0,"IOPortTransportState"=6,"IOSkywalkQueueSet"=5,"ApplePMPThermalUserClient"=0,"IOCharacterDevice"=0,"AppleSPUDCPDriver"=0,"IOTBTTunnelDriverInterfaceType2"=3,"IOAudioEngineEntry"=0,"AppleDialogPMU"=0,"IO80211APIUserClient"=0,"AppleTunneledPCIEUserClient"=0,"AppleM2ScalerCSCHalMSR24"=0,"IODisplayAssertionUserClient"=0,"AppleEmbeddedPCIE"=1,"AppleOnboardSerialPool"=2,"AppleMCA"=2,"IOAESAccelerator"=1,"AppleSPUProfileFirmwareDriver"=0,"AppleThunderboltDPOutAdapter"=0,"WCLFsmManager"=0,"AGXTAChannel"=1,"IOServiceCompatibility"=4,"AppleT8103USB30XHCIPort"=0,"IOHIDKeyboard"=0,"AppleIntelUSBXHCI"=1,"AppleSPUGrimaldiDriver"=0,"APCIECMSIController"=3,"IOThunderboltNHIReceiveRing"=1,"AppleMCA2Switch_RxCfg"=8,"ApplePMPEvent"=0,"IOGDiagnosticGTraceClient"=0,"AppleTCControllerType15"=0,"IosaColorManagerMSR16"=1,"MCCommandQueue"=1,"IOPortFeature"=2,"AppleARMI2CEEPROM"=0,"H13ISPLoggerEventSource"=1,"IORSMCommandQueue"=0,"RTBuddyTraceDataEncoder"=1,"ApplePPMDaemonIPC"=0,"AppleThunderboltDPInAdapterOS2"=0,"IOTimeSyncTimeLineFilterIIR128"=0,"AppleParadeDP835TCONI2C"=0,"IOHIDUserClient"=1,"IOSurfaceTransaction"=0,"IO80211NANDataPathInitiator"=0,"IOAccessoryUSBPowerSourceDetect"=0,"IOAVCECService"=0,"IOPMinformeeList"=527,"AppleUSBXHCITDPool"=4,"M2ScalerSrcDestCfgControlMSR20"=0,"AppleSmartBatteryManager"=1,"TAGateLock"=2,"IOImageDescriptor"=0,"AppleSEPManager"=1,"AppleExternalSecondaryAudio"=2,"HSAIDReceivePacketPool"=0,"SCSITask"=0,"IosaChromaDownsamplePipeUnitMSR23"=0,"AppleNVMeFWNamespaceDevice"=0,"IOAccessoryPowerSourceItemBrickID"=0,"AppleARMQuadSPIController"=0,"ANEDartAllocationInfo"=0,"AppleARMBacklightPCCUpdateFunction"=0,"ApplePMGRFunctionSEPSleepPrep"=0,"IosaWdmaControlMSR10"=1,"OSValueObject<ANEGroupResource*>"=0,"AppleAOPAudioHapticLEAP"=0,"IOSkywalkTxSubmissionQueue"=5,"IosaDPEControlMSR10j"=0,"IOTBTTunnelDriverInterface"=10,"IOTimeSyncIntervalFilter128"=0,"IO80211FlowQueueLegacy"=0,"IOFastPathService"=0,"IOMobileFramebufferService"=1,"DCPDPControllerProxy"=5,"AppleMultitouchEventDriverWrapper"=1,"AppleBCMWLANBonjourOffload"=0,"AGXFastRenderTargetG15"=18,"IOBluetoothMemoryBlockQueue"=2,"IODiskImageBlockStorageDeviceOutKernel"=0,"AppleHIDTransportDeviceDummy"=0,"AppleBCMWLANPCIeSkywalkFlowQueue"=0,"IOPCIBridge"=2,"IOThunderboltFindCapabilityCommand"=5,"AppleTypeCRetimerCrashReportSection"=0,"IOAccessoryUSBTypeCCurrentDetect"=0,"AppleBCMWLANSkywalkTxSubmissionQueue"=0,"AGXFirmwareKextG15RTBuddy"=1,"AppleXsanDevice"=0,"WCLDeviceConfiguration"=0,"IOGPUMTLEvent"=0,"IOSurfaceMTLSharedEventFence"=0,"AGXSecureMonitorG15"=0,"IODMACommand"=3452,"RTBuddyManagementEndpoint"=11,"IODPService"=0,"IOHDIXHDDriveInKernel"=0,"IOSkywalkKernelPipeBSDClient"=5,"IOPCIMessagedInterruptController"=2,"IOUserIterator"=222,"AIDLoggerUserClient"=0,"AppleThunderboltDPOutAdapterUserClient"=0,"AppleBCMWLANRoamAdapter"=0,"IORegFlex"=1,"AppleMCA2Switch_Reginfo"=3,"IOSurfaceMemoryTag"=1105,"DCPAVVideoInterfaceProxy"=3,"RTBuddyVersionDecoder"=14,"IOThunderboltDispatchQueue"=57,"DCPAVProxy"=13,"AppleMemCachePanicFunction"=1,"AGXMTLCounterSampler"=1,"AppleBCMWLANCommandWithXTLV"=0,"RTBuddySlaveBuffer"=2,"AppleEmbeddedAudioDevice"=2,"TAAccessoryEvent"=0,"AppleBCMWLANPCIeSkywalkMemorySegment"=0,"AppleHPMLDCMType3"=0,"IosaRdmaControlMSR15"=1,"AppleUSBXDCITRBBlock"=408,"AGXDeviceUserClient"=44,"IOSkywalkCloneableNetworkPacket"=0,"IOPortTransportStateDisplayPort"=3,"AppleDiskImagesController"=1,"IOSurfaceSharedEventNotification"=1,"CachedSystemConfig"=1,"AGXDebugBufferShmem"=1,"AppleUSBXHCIEndpoint"=39,"AppleT8112USBXHCI"=0,"AppleUSBUserHCIRequestPool"=0,"WCLDebugManager"=0,"IOAVSplitDisplayVideoInterface"=0,"IosaPrescaler3x3PipeUnit"=0,"IOGPUAllocationInfo"=0,"IO80211PeerExtendedStats"=0,"AppleARMIISController"=1,"AppleBCMWLANCoreFirmwareLoader"=0,"ACMPersistentStoreKernelService"=1,"IosaPixelAveragingPipeUnitMSR6"=0,"IosaRequestPipeUnit"=0,"IOUSBDeviceUserClient"=0,"AppleThunderboltDPInAdapter"=0,"AGXUSCPrivMemBlock"=104,"IOFastPathHIDLEDService"=0,"AppleA7IOPNub"=15,"IOPCIHostBridgeData"=4,"IOUserEthernetResource"=1,"AppleUSBHostControllerListElement"=0,"IO80211P2PDFSProxyManager"=0,"AppleARMIISCommand"=96,"AFKMemoryDescriptorManager"=1,"IOMultiMemoryDescriptor"=0,"AppleSEPFirmware"=0,"IOSlowAdaptiveClockingDomain"=2,"AppleBCMWLANPCIeSkywalk"=0,"IOTimeSyncEdgeTimeCapture"=0,"AppleCSSPIv2Audio"=0,"IOBioQueue"=1,"IOPortTransportStateCC"=4,"AppleSPUTimesync"=1,"IosaColorManagerMSR2"=1,"AppleA7IOP"=2,"AppleARMPMUCharger"=0,"IosaPrescalerControlMSR8"=1,"IO80211NANAttributeTx"=0,"AppleSPUAppDriverUserClient"=0,"OSSetEquality"=11,"M2ScalerSrcDestCfgControlMSR5"=1,"IOInterruptQueueEventSource"=9,"IOAVVideoTimingElement"=0,"WCLRoamProfile"=0,"AFKIOServiceClient"=0,"AppleSPUHapticsManagerDriver"=0,"KDIEncoding"=0,"IOThunderboltPacketLoggerNub"=0,"IO80211TimerFactory"=0,"IOFastPathHIDAccelService"=0,"DCPPowerCallback"=3,"IOImageLoaderImageDictionary"=0,"IOBigMemoryCursor"=0,"CCDataPipeUserClient"=0,"IO80211ScanSanitizer"=0,"AppleThunderboltDPOutAdapterCM"=14,"MailBoxMSR23"=0,"IOThunderboltConfigCMOverrideCommand"=4,"AppleLVBOOST"=0,"IODP13Service"=0,"IOThunderboltSwitchUSB4"=1,"AppleThunderboltNHIReceiveRingGenericACIO"=1,"AppleJPEGWrapperControlV14"=0,"IOSurfaceSendRight"=4,"IOAVDeviceConcreteUserClient"=0,"AppleConvergedIPCSkywalkInterface"=5,"IOMesaCaptureDataQueue"=1,"AppleSPUCT721"=0,"AppleHIDTransportBootloaderPassive"=1,"IOUSBMassStorageDriverNub"=1,"AppleAuthCPHSAID"=0,"AppleUSBHostIORequestPool"=39,"AppleSPUUserClient"=0,"IOTimeSyncPersistentUserClockMapping"=0,"IOTimeSyncNetworkPort"=0,"IODTNVRAM"=1,"IOFramebuffer"=0,"AppleCSSPIAudio"=0,"AppleDCPDPTXRemotePortProxy"=4,"AppleT604XATCDPXBAR"=0,"AppleUSBHostPort"=2,"MesaAccessoryIntReportImage"=0,"H1xANELoadBalancerDirectPathClient"=0,"AppleHPMAIDType1"=0,"IOThunderboltDispatchContext"=2,"RTBuddyRouteProvider"=0,"AGXUSCPrivMemHWMetrics"=55,"CCIOReporterHub"=0,"IOAccessoryEAInterfaceUserClient"=0,"AppleEventLogHandler"=1,"ApplePMGRv2"=0,"AppleSEPPairing"=0,"IOHIDReportElementQueue"=0,"AppleMCA2Controller"=1,"IOSkywalkMemorySegment"=110,"AppleOLYHALPlatformFunctionEventTimestamp"=0,"AppleUSBHostResourcesBusPowerClient"=0,"AFKMemoryDescriptorManagerUserClient"=0,"IOMesaCaptureDataAccessory"=0,"AppleUSBXHCIARIsochronousRequestPool"=0,"IOPCIEventSource"=9,"IOGPUWorkQueueState"=0,"IOModemSerialStreamSync"=0,"AppleBCMWLANChipManagerPCIe4355"=0,"IosaInternalPipeMSR23"=0,"AIDEventLogger"=2,"OSValueObject<ANEResource*>"=0,"AppleRSMChannelController"=1,"IOHIDElementContainer"=1,"IOSurfaceDescriptorContext"=0,"AppleTCControllerSingleTransport"=0,"AppleBCMWLANPCIeSkywalkPacket"=0,"AppleUSBXHCIFL1100"=0,"IOECTimeSyncHandler"=0,"AppleSMCSensorDispatcher"=1,"AppleEstBTM"=0,"RTBuddyBuiltinEndpoint"=3,"AppleSEPEndpoint"=13,"IOMesaCaptureData"=0,"IOAVDMACommand"=12,"IOBioSEPSharedBufferFactory"=0,"IOThunderboltSwitchLC"=1,"AppleBCMWLANGASAdapter"=0,"IOAVElement"=2,"RTBuddyCoredumpMapEntry"=104,"GTGateLock"=3,"AppleT600xDisplayCrossbar"=0,"IOFastPathHIDGyroService"=0,"ApplePMGRBase"=1,"AGXSecureMonitor"=0,"IOUserNetworkEthernet"=7,"IOGPUWeakResourceSet"=216,"AppleBCMWLANRxItemRing"=0,"IOSCSIProtocolInterface"=2,"IOHIDAsyncReportQueue"=0,"AppleThunderboltDPPathManagerOS"=8,"OSDictionary"=32700,"RTBuddyRegisterFrameDecoder"=14,"AppleMCA2Switch_Control"=4,"IOFastPathHIDService"=0,"IOPortTransportStateUSB3"=0,"ApplePassthroughPPMSystemCapabilityMonitor"=1,"AppleTypeCPhyDisplayPortInterface"=10,"IO80211IORecursiveLock"=0,"AppleUSBDescriptor"=87,"AppleM2ScalerCSCHalMSR18"=0,"com_apple_filesystems_hfs"=1,"AGXAttributionIndexManager"=18,"RTBuddyOSLogSegmentSlice"=0,"AppleASMedia3142USBXHCI"=0,"IOTimeSyncUnicastLinkLayerPtPPort"=0,"AudioDMAChannelStateMachine"=1,"AppleLEAPController"=1,"IosaPrescalerControlMSR23"=0,"AGXSecureMemoryMap"=3549,"AppleT8020MTRTempSensor"=0,"IOTimerEventSource"=1123,"IOThunderboltXDomainService"=0,"IOTimeSyncClockManagerUserClient"=0,"AppleHIDTransportDevice"=1,"ApplePPMPolicy"=1,"BlockDescriptorRegStreamMSR23"=0,"IOAccessoryPowerSourceItemBrickLimit"=0,"IOHIDForceSensorElementProcessor"=0,"AppleMesaResources"=1,"DCPAVRemoteSACControllerProxy"=1,"LegacyFunctions"=0,"EndpointSecurityDriverClient"=1,"AppleUSBHostDMACommand"=1,"WCLDeauthDisassoc"=0,"IosaConvertPipeUnit"=0,"CoreAnalyticsEventRatePolicy"=1,"AppleDeviceManagementHIDEventService"=1,"AppleMobileApNonce"=1,"IOUSBDevice"=1,"AppleT8110DART"=30,"AppleT602XDisplayCrossbar"=1,"AppleConvergedIPCMemoryCommand"=12,"IOTimeSyncSyncDaemonClient"=1,"ApplePMGRFunctionVoteCriticalLltMode"=0,"MCDataStreamInfoObject"=6,"IOAccessoryDock9Pin"=0,"AppleM2ScalerCSCHalMSR21"=0,"AppleSEPTesting"=0,"AppleBCMWLANPCIeMMIOHistory"=0,"IOUserServerCheckInToken"=12,"USBInterfaceAssociation"=0,"AppleDCPDPTXRemoteHDCPInterfaceProxy"=5,"IOThunderboltNumber"=1816,"AppleARMGPICFunction"=0,"IO80211NANInfraManager"=0,"AppleBCMWLANTimeSyncClockInfo"=0,"AIDReporter"=1,"AppleUSBXDCIEndpoint"=0,"IOThunderboltControllerType5"=3,"AFKWorkloop"=98,"AppleI2CMultipleAudio"=1,"com_apple_driver_FairPlayIOKit"=1,"IOAccessoryPowerSourceItemLowVoltageLimit"=0,"RTBuddyIOReportingEndpoint"=9,"AppleSPUCT709"=0,"AppleBCMWLANPowerStateAdapter"=0,"IosaChromaUpsamplePipeUnitMSR9"=0,"AppleM2ScalerCSCHal"=1,"AFKEPInterfaceKextV2"=59,"AppleHIDTransportInterfaceUserClient"=0,"M2ScalerCSCColorConversionControlMSR10"=1,"AppleT8015TempSensor"=0,"IOHIDEvent"=0,"AppleDisplay"=0,"WCLBCNMuteMitigation"=0,"AppleUSBHostRequest"=2,"IOPortFeatureRFCoEx"=0,"HSAIDTransmitPacketPool"=0,"IOHIDLEDConstellationElementProcessor"=0,"IOTimeSyncDaemonService"=1,"AppleParadeDP815TCON"=0,"IOConditionLock"=0,"GMetricsRecorder"=0,"AppleKeyStoreCommand"=2,"AppleARMBacklightFunction"=0,"DCPAVDeviceProxy"=3,"IOKitRegistryCompatibility"=1,"IOAccessoryPowerSourceSupplyData"=0,"IOBluetoothHIDChannel"=0,"AppleATCDPINAdapterPortBase"=1,"AppleUSBTDMMassStorageClass"=0,"AppleTCControllerAssignableTransport"=0,"AppleThunderboltHALType7"=0,"AppleNVMeFWNamespaceUC"=0,"AHTSCMMessage"=3,"IOSlaveFirmware"=1,"AGXChannel"=3,"AppleT8122PCIe"=1,"IOAVAudioDriver"=1,"IOThunderboltConfigModifyQuadletCommand"=0,"IosaPolyphaseScalingPipeUnitMSR23"=0,"AppleUSBXDCIEventHandler"=0,"AppleBCMWLANScanAdapter"=0,"WCLBulletinBoard"=0,"AppleMultiFunctionPlatform"=1,"AppleSmartIODMA"=7,"RTBuddySegmentSlice"=0,"WCLAdaptiveRoam"=0,"AppleSimpleUARTSync"=2,"IOPMrootDomain"=1,"AGXParameterMemoryVirtual"=5,"AppleMultitouchDeviceUserClient"=1,"AppleEmbeddedPCIEBarrier"=0,"AppleTrustedAccessoryManagerInterface"=1,"AppleARMNMI"=0,"AppleTCON"=1,"RTBuddySmbDecoder"=14,"AppleConvergedIPCMemoryPolicy"=9,"AppleARMPerformanceControllerFunctionClockGate"=0,"EndpointSecurityExternalClient"=6,"IOThunderboltLinkController"=21,"IOGPUNamespace"=396,"IORootParent"=1,"RootDomainUserClient"=118,"AppleARMPerformanceControllerFunctionAssertReset"=0,"IOThunderboltSwitchLegacy"=1,"AppleBCMWLANSkywalkInterface"=0,"M2ScalerScalingASEControlMSR20"=0,"AppleHPMInterfaceType3"=0,"TADetachedAccessory"=0,"WCLTimerSource"=0,"AppleMCA2Switch_RxCtl"=8,"IODPController"=0,"IOBreaker"=0,"AppleBCMWLANTxCommandBuffer"=0,"AudioDMAChannel"=56,"AppleBCMWLANSensingAdapter"=0,"AppleSPUGNSSDriverUserClient"=0,"IOTimeSyncLocalClockPort"=1,"AppleMultiFunctionManager"=1,"AppleARMPerformanceControllerFunctionPerfAdvise"=0,"AppleSPUHIDDeviceUserClient"=1,"AppleOLYHALPlatformFunctionEmbedded"=0,"AppleSPUTimesyncV2"=1,"AppleBCMWLANChipImage"=0,"OSAction_IOUserClient_KernelCompletion"=6,"AppleT8103PCIeC"=1,"StatusDescriptorRing"=0,"AppleSMCKeysEndpoint"=1,"AppleTunneledPCIE"=1,"RadishFunctions"=0,"IOSkywalkNetworkPacket"=0,"HSAIDCommand"=0,"AppleSEPSharedMemoryBuffer"=1,"AppleBCMWLANPCIeTransmitFlowRing"=0,"CCDataPipeBlobMD"=0,"IOImageLoaderUserClient"=0,"_Message"=0,"IOThunderboltControllerGenericACIO"=1,"APCIEPortControl"=3,"AGXDiagnosisReport"=0,"RTBKeyObjectPair"=516,"IOAVAbstractVideoInterface"=0,"IO80211BonjourOffloadAgent"=0,"IOThunderboltXDPropertiesCache"=1,"IOThunderboltEEPROM"=8,"IONetworkStackUserClient"=1,"IOAccessoryConfigStreamInterface"=0,"IOUserNetworkRxSubmissionQueueCompat"=0,"DitherControl"=1,"RingBuffer"=0,"AppleMCA2DeviceClock"=4,"M2ScalerCSCColorConversionControl"=1,"AppleDialogSPMIPMU"=2,"IOAccessoryDock0PinBuiltin"=0,"AppleHPMDeviceHAL"=1,"AppleHIDTransportDeviceUserClient"=0,"PMHaltWorker"=0,"IODPPortService"=10,"AppleUSB2RepeaterIICDevice"=0,"AppleARMMIPIDSIDevice"=0,"AppleThunderboltDPOutAdapterDelegateNonLegacy"=2,"RTBuddyEntropyEndpoint"=0,"AGX3DChannelSKU"=1,"RTBuddyBinaryLogEntryHandlerOSLog"=6,"IOSkywalkPacketBuffer"=4480,"AppleDialogSPMIPMURTC"=1,"IODPLinkRateRangeTable"=0,"BlockDescriptorRegStream"=0,"AppleNANDConfigAccess"=0,"IOBluetoothMemoryDescriptorRetainer"=0,"ANECoreInterface"=2,"IOThunderboltConfigWriteQuadletCommand"=8,"OSValueObject<AppleH13CamInFirmwareWorkProcessorRPCRequest>"=0,"AppleHPMBusController"=0,"IOGPUMemory"=3,"AppleMesa"=1,"AppleSEPDebug"=0,"AppleXsanDriver"=0,"RTBuddySegment"=147,"AppleAOPAudioLEAPClientManager"=0,"AppleARMIISSwitch"=1,"IOAVDisplayConnection"=0,"IOGPUBlockFence"=1,"AppleUSBAudioDevice"=0,"SCSISubsystemGlobalsUserClient"=0,"IOSurfaceClient"=1568,"IO80211P2PSupervisor"=0,"AppleSPUVD6286"=1,"AppleBCMWLANIOReportingPerSlice"=0,"M2ScalerScalingASEControl"=1,"IosaTunableControl"=0,"TSNBSDStackInterface"=0,"AppleT8030USBXHCICommandRing"=0,"AppleSPUFastpathCaptureObject"=0,"SMEvent"=234,"M2ScalerCSCColorConversionControlMSR15"=0,"IONetworkStack"=1,"AppleBCMWLANSkywalkPacketPool"=0,"ApiodmaRegStreamMSR19"=0,"IOAccessoryConfigStreamUserClient"=0,"AGXSecureSharedGartTableBacking"=1,"DCPAVCECController"=0,"WCLMngFrameRouter"=0,"AppleNVMeEANUC"=1,"AppleUSB20CameraKitHub"=0,"SCSITaskUserClientIniter"=0,"IOThunderboltSwitchType6"=0,"IOHIDEventServiceQueue"=19,"IosaColorManagerMSR13"=1,"AppleMesaShim"=1,"AppleCredentialManagerUserClient"=8,"AppleAOPAudioDeviceNode"=5,"IOPMCompletionQueue"=1,"AVE_HwC"=1,"AppleSPUFastpathClientObject"=0,"IOSubMemoryDescriptor"=29,"IOBluetoothObject"=1,"IOService"=332,"IOAVVSDBElement"=0,"AppleHDCPInterface"=10,"AppleAudioSequenceList"=0,"IOThunderboltTimerCommand"=8,"H1xANELoadBalancer"=1,"IOAVBValidateUserClient"=0,"AppleALSColorSensor"=0,"AppleUSBHostRequestCompleter"=17,"OSCollection"=6,"AppleMCKAudio"=0,"AppleSPUAONPTDDriver"=0,"IOThunderboltNHI"=1,"AppleAOPAudioAmpManagerDevice"=0,"RTBuddyCoredumpDecoder"=14,"IOHIDPowerSourceClient"=0,"IOTimeSyncClockTestUserClient"=0,"AppleEffaceableStorage"=0,"AppleUSBHostBulkHIDDevice"=0,"IOHDIXCommandPool"=0,"AppleUSBXHCIARM"=1,"RTBuddyFirmwareService"=3,"AppleThunderboltIPService"=3,"IOSCSIPeripheralDeviceType00"=1,"AEARuntimeRegisterPatch"=1,"FrameDescriptorRingMSR23"=0,"AppleRSMCommand"=0,"IosaInternalPipeMSR10"=1,"AppleUSBHostPacketFilter"=0,"IOReportLegend"=24,"AppleHPMInterfaceType14"=0,"AppleHIDTransportDeviceFIFO"=1,"IOAVDisplayMemory"=1,"AppleSEPUserClient"=0,"AppleSamsungSerial"=2,"AppleNVMeRequestTimer"=1,"AppleT8112ATCDPXBAR"=0,"AppleSATLSMARTUserClient"=0,"AppleMultitouchTrackpadHIDEventDriver"=1,"AppleUSBHostDeviceUserClient"=0,"AppleSPUMarconiControl"=0,"RTBuddyCoprocDrivenCoredump"=0,"IOHDCP1TransmitterAuthSession"=2,"UPAsynchronousScheduler"=39,"M2ScalerSrcDestCfgControlMSR14"=0,"CoreAnalyticsPipe"=1,"AppleCS42L84Audio"=1,"AppleMobileFileIntegrity"=1,"AIDReporterSimple"=2,"IO80211RangingManager"=0,"AppleAOPAudioController"=1,"AppleSmartIODMANub"=1,"IOUSBHostStream"=0,"AppleAOPSMCDriver"=0,"OSValueObject<AppleH13CamInFirmwareWorkProcessorParams>"=1,"IOSCSILogicalUnitNub"=1,"IO80211RangingManagerExt"=0,"AppleM2ScalerCSCHalMSR15"=1,"ApplePMGRTempSensor"=0,"_IOServiceNotifier"=1042,"IOAudioTimeIntervalFilterFIR"=0,"IO80211AssociationJoinSnapshot"=0,"AppleT8103ATCDPXBAR"=0,"DIDeviceIOUserClient"=0,"IO80211Peer"=0,"CCDataPipe"=1,"IOAVConcreteDisplayMemory"=0,"AHTEeprom"=0,"IOThunderboltSwitchDelegateACIO"=3,"AppleBCMWLANLowLatencyInterface"=0,"IOAVBAudioLoader"=0,"AFKEndpointInterfaceClient_Descriptor"=4,"ApplePMGRFunctionPMPInterrupt"=3,"AppleBCMWLANLeakyApParser"=0,"ANEWorkLoop"=2,"IOGPUWeakNamespace"=5,"RTBuddyTraceKitSession"=3,"IOUSBInterfaceUserClientV2"=0,"AppleUSB30HubPort"=8,"IOTimeSyncFilteredService"=0,"RTBuddyCoreAnalyticsEndpoint"=0,"AppleThunderboltDPInAdapterOS"=6,"DCPAVAudioInterfaceProxy"=1,"AppleAvusBTM"=0,"IosaChromaUpsamplePipeUnit"=0,"AppleAOPAudioClientManager"=2,"IODPEmbeddedDevice"=0,"IOThunderboltConfigResetCommand"=7,"IOHDIXHDDrive"=0,"OSValueObject<__ReportResult>"=0,"IODPControllerUserClient"=0,"IOHIDKeyboardEventDevice"=0,"AppleMemCacheFlushFunction"=1,"SpillBufferMSR23"=0,"AppleHIDTransportProtocolSCMFIFO"=1,"AppleM2ScalerCSCHalMSR10j"=0,"AGXUMAAsyncGrowRequest"=4,"_IOConfigThread"=0,"AppleSMCACAMDriver"=0,"IOUserSerialUserClient"=0,"IOAccessoryPowerSourceItemRestrictions"=0,"AppleBluetoothModule"=1,"WCLJoinRequest"=0,"IODisplayConnect"=0,"IONVMeControllerPolledAdapter"=1,"DCPAVServiceProxy"=3,"M2ScalerSrcDestCfgControlMSR"=1,"AppleStonehengeBPIC"=0,"AppleMesaUserClientBase"=0,"AppleDCPDPTXRemoteHDCPAuthSessionProxy"=4,"IO80211PostOffice"=0,"IOTimeSyncEdgeTimeCaptureUserClient"=0,"AppleUIOMem"=1,"OSValueObject<FWPendingRequest>"=0,"OSSet"=6047,"AppleKeyStoreTest"=1,"AppleMikeyReceiver"=1,"M2ScalerSrcDestCfgControl"=1,"IOTBTTunnelActivationState"=0,"AppleOLYHALPortInterfacePCIeAMFM"=1,"AppleBiometricServicesUserClient"=1,"IOTBTTunnelDPClientInterface"=12,"AppleARMPerformanceControllerCLPCNub"=0,"AppleUSBXHCIDevice"=17,"IOThunderboltConfigXDomainROMReadRequestCommand"=0,"IOThunderboltConfigXDomainPathRequestCommand"=0,"KDIDiskImageNub"=0,"H11ANEInDirectPathClient"=0,"AppleAOPAudioDevice"=3,"IOSurfaceRootParavirtMapperInterface"=0,"IOUserService"=7,"IO80211FlowQueue"=0,"RTBuddyCrashlogEndpoint"=11,"AppleSPUFastpathInterface"=0,"IOBioPoolItem"=0,"IOThunderboltXDPropertiesLeafData"=0,"IO80211CommandQueue"=0,"IOAccessoryPortSerialSync"=0,"IOSCSIPeripheralDeviceType07"=0,"AppleARMIISAudioDevice"=2,"RTBuddyBinaryLogSourceInfo"=2,"IosaColorManagerMSR23"=0,"Hibernator"=1,"AppleOnboardSerialSkywalkPacketPool"=0,"AppleEmbeddedAudioHeadsetSwitch"=0,"CCDataStream"=1,"AppleBCMWLANChipManagerPCIe"=0,"AppleUSBCapabilityDescriptor"=0,"IOBluetoothInactivityTimerEventSource"=0,"AppleSMCKDebug"=1,"AppleMobileApNonceUserClient"=0,"IOHDCP2DPTransmitterAuthSession"=2,"IOAVControllerConcreteUserClient"=0,"AppleAuthCPRelay"=0,"RTBuddyTraceChunkEncoder"=6,"IOThunderboltPortMicro"=0,"AppleBCMWLANPCIeSkywalkRxSubmissionQueue"=0,"RTBuddyRouteAdaptor"=14,"AppleSPUPDMCLKDriver"=0,"AppleCSI2CMultipleAudio"=0,"WCLNetPowerStateAgent"=0,"OSAction_IOUserNetworkEthernet__TxSQDataAvailable"=0,"IosaWdmaPipeUnit"=0,"AppleUVDMEndpoint"=0,"AppleTrustedAccessory"=0,"OSData"=12494,"ApplePMGRFunctionStub"=0,"AppleHPMLDCMType2"=3,"AppleParadeDP855TCON"=1,"IOHIDGyroElementProcessor"=0,"IOFence"=49,"IO80211CagedBuffer"=0,"AppleMultitouchEventDriverV2Wrapper"=1,"IOHIDElement"=1,"AFKTightbeamEndpoint"=0,"IOUserNetworkTxCompletionQueue"=5,"MSR23CurvatureLUT"=0,"AGXUMASharedPoolContainer"=44,"AGX3DCommandDescriptor"=1,"IosaWdmaPipeUnitMSR23"=0,"AppleLockdownMode"=1,"AppleUSBUserHCICommandQueue"=0,"IOPortFeaturePower"=1,"AppleHPMDeviceHALType2"=0,"AppleASCWrapV6SEP"=1,"AppleBCMWLANDMASlab"=0,"IOGPUMappingCommand"=0,"AppleHapticsExternalSecondaryAudio"=0,"AppleUSBHostMergeProperties"=1,"IOThunderboltXDomainServiceClient"=0,"IOBluetoothACLMemoryDescriptor"=0,"AppleSEPControl"=1,"IOBioSEPSharedBuffer"=0,"AUAUnitDictionary"=0,"IOTimeSyncgPTPManagerDaemonClient"=1,"AppleSecondaryAudio"=3,"AppleBCMWLANBssManager"=0,"AppleARMSoftIICController"=0,"AGXAcceleratorG15"=1,"AVE_Drv"=1,"IOAVVideoInterface"=0,"IONaturalMemoryCursor"=0,"AppleARMWatchdogTimerHibernateHandler"=1,"OSSymbol"=32670,"RTBuddyHexDecoder"=16,"AppleEmbeddedAudioButtons"=1,"UnifiedPipeline2"=1,"DCPAVSACController"=1,"IOGraphicsWorkLoop"=1,"OSUserMetaClass"=1136,"IOAVControllerUserClient"=0,"IOThunderboltXDomainReceivePath"=0,"AUAExtensionUnitDictionary"=0,"IOSkywalkNetworkNotificationHelper"=0,"IOHIDTimeSyncService"=0,"AppleUSB20AccessoryHubPort"=0,"AppleSPIMCController"=3,"AppleT6030PCIePort"=2,"OSValueObject<ANEMPMMemoryParams>"=0,"ApplePPMARMFunction"=0,"IO80211BGScanManager"=0,"RTBuddyOSLogEndpoint"=6,"SpillBuffer"=0,"RTBuddyVisibleMemory"=1,"AppleSSEInterface"=1,"AUAStreamDictionary"=0,"IOAudioEngineUserClient"=0,"IOAccessoryTRM"=0,"IOTBTTunnelClientInterfaceManager"=3,"M2ScalerSrcDestCfgControlMSR8"=1,"AppleBCMWLANCore"=0,"OSAction_IOHIDEventService__SetUserProperties"=0,"IOAVDisplayMemoryConcreteUserClient"=0,"AppleNVMeUpdateUC"=0,"AppleSPUFastpathDriverUserClient"=0,"IOAVBStreamCapture"=0,"AGXCommandBuffer"=18,"AIDCircularBufferShared"=1,"AppleARMIICDevice"=12,"AppleInterruptControllerV3"=1,"AppleH15IO"=1,"IO80211P2PSteeringManager"=0,"ANECoredump"=0,"AppleOLYHALPlatformFunctionEmbeddedAMFM"=1,"AppleAOPSMC"=0,"CCStream"=2,"AGXTACommandDescriptor"=1,"IOThunderboltUserObjectExporter"=0,"AggressorUserClient"=0,"IOReportHub"=1,"WCLNeighborCacheManager"=0,"AppleSOCTuner"=1,"IOTBTTunnelClientInterface"=6,"AppleSPUSimpleAsyncEventSource"=14,"DCPAVControllerProxyUserClient"=0,"AppleParadeDP835TCONSPI"=0,"IOHDIXCommandQueue"=0,"AppleUserHIDEventService"=6,"IOLittleMemoryCursor"=0,"IOAccessoryPowerSourceItemUSBDevice"=0,"IOThunderboltDictionary"=12,"IOPortAIDController"=0,"AppleTypeCPhyInterface"=3,"AppleT8030USBXHCI"=0,"AIDService"=4,"WCLLinkDebounce"=0,"AppleWrapperMailbox"=0,"LogManager"=0,"IO80211CoreDbg"=0,"IOThunderboltSwitchType3"=7,"OSValueObject<ANEUnionResource*>"=0,"OSValueObject<client_log_buffer_t>"=0,"RTBuddyVisibleSlaveBuffer"=33,"IOUserServer"=12,"IosaEnhancementPipeUnitMSR23"=0,"AppleSEPCommandPool"=3,"AppleUSBHostFrameworkDeviceClient"=0,"AppleTrustedAccessoryManager"=1,"IO80211NANDataInterfacePeerManager"=0,"EndpointSecurityNoAuthClient"=0,"AppleM2ScalerCSCHalMSR4"=1,"AppleAPFSContainer"=3,"AppleUSBHostPortInterruptEventSource"=42,"ANERequestCompletionMsg"=0,"AppleSMCEventBuffer"=1,"AppleUSBAudioIsocPipe"=0,"AppleAOPAudioDeviceController"=1,"IOBluetoothDataQueue"=0,"AppleS5L8960XNCO"=1,"IOPlatformExpert"=1,"AppleUSBHostBouncedDMACommand"=231,"IO80211AVCAdvisory"=0,"DCPAVVideoInterfaceProxyUserClient"=0,"AppleHIDKeyboardEventDriverV2"=1,"RTBuddyRemoteSlaveMemoryDescriptor"=0,"IOAVBTimeSyncSyncUserClient"=0,"DCPAVRemotePowerController"=0,"AudioKernelClientInterface"=0,"IOThunderboltXDDirectory"=0,"AGXInvalidChannel"=1,"WCLGlue"=0,"AppleAOPAudioMCA2Device"=0,"AppleDockChannelDevice"=1,"AppleSEPHDCPEndpoint"=1,"IO80211InfraPeersDatabase"=0,"AppleEmbeddedPCIEPortControlFunction"=1,"AppleTypeCRetimerUserClient"=0,"IOAVControllerAddDeviceCompletion"=0,"IOHIDResourceQueue"=1,"IOImageLoaderDatastore"=0,"AppleUSBXHCIParkingCommandRing"=0,"AppleARMRTC"=1,"IOTimeSyncIntervalFilterIIR"=0,"IOHIDElementPrivate"=3665,"IOUserUserClient"=16,"ApplePMPFirmware"=1,"AppleANEEPFunction"=3,"IOFilterInterruptEventSource"=140,"ApplePIODMARequestPool"=5,"IOStateNotificationListener"=0,"AppleCredentialManager"=1,"M2ScalerSrcDestCfgControlMSR10j"=1,"IOThunderboltIECSCommand"=0,"IOAccessoryPortSerial"=0,"AppleTCControllerType10"=0,"OSValueObject<AsyncReportParam>"=0,"IOUSBDeviceDMACommand"=0,"IOAVDevice"=0,"AppleBCMWLANTxPowerManager"=0,"AppleSMCInterface"=5,"IOSurfaceMemoryPoolBunch"=0,"IOBacklightDisplay"=0,"IOPortFeatureUserClient"=1,"ApplePIODMA"=2,"WCLBGScanManager"=0,"com_apple_BootCache"=1,"AFKEndpointInterface_DescriptorBase"=1,"RTBuddyStatisticsDecoder"=14,"IOTimeSyncDaemonServiceProcess"=2,"IO80211NANLocaleManager"=0,"AppleMCA2Rx"=4,"AppleMultitouchEventServiceWrapper"=0,"AFKACIPCMemoryDescriptorManager"=0,"AGXIOSurfaceSharedEventCommandDescriptor"=0,"AppleSDXCSDDetect"=1,"IO80211NANPeerManager"=0,"IOHIDBTCETimeSyncService"=0,"IOAccessoryUSBConnectShim"=0,"IOUserNetworkRxCompletionQueue"=5,"AppleUSBHostDMABufferMemoryDescriptor"=66,"IOPortTransportStateSWN"=0,"AppleUSBAudioDictionary"=0,"AGXFirmwareKextRTBuddy"=1,"AppleMesaSEPDriver"=1,"AppleARMSPIDeviceUserClient"=0,"AppleHIDTransportBootloaderHIDDevice"=1,"WCLBeaconDuplicator"=0,"AppleH15MemCacheController"=1,"IosaInternalPipeMSR7"=1,"AppleThunderboltDPOutAdapterDelegateLegacy"=0,"AppleAOPAudioButtonHapticDevice"=0,"AppleT8027USBXDCI"=0,"RTBuddyTraceKitEndpoint"=3,"RTBuddyAscDecoder"=14,"AGXTimeStampQueue"=18,"AppleUSB20XHCIARMPort"=3,"IO80211AWDLPeer"=0,"IOBootFramebuffer"=0,"AppleARMPMUPowerSource"=0,"AppleBCMWLANPCIeLinkChangeEventSource"=0,"AppleMCA2Cluster_T6030"=3,"IOTimeSyncTSNInterfaceAdapter"=0,"IOTimeSyncEthernetSoftDMAInterfaceAdapter"=0,"RTBuddy"=14,"AppleUIOMemUserClient"=0,"IOThunderboltTunnelDriverType2"=0,"AppleARMPWM"=1,"AppleS5L8940XI2CController"=6,"WCLNearbyDeviceDiscoveryManager"=0,"AFKAction"=0,"AppleRSMChannel"=0,"IOFramebufferI2CInterface"=0,"AppleBCMWLANPCIeSubmissionRing"=0,"IosaWdmaControl"=1,"IOHIDSystem_notificationData"=0,"AppleThunderboltIPMSMInterface"=0,"AIDImageDownloader"=3,"com_apple_filesystems_lifs"=1,"IosaColorManagerMSR7"=1,"AppleARMPWMCaptureTimestampFunction"=0,"IOGPUIOCommandQueue"=0,"AGXRemoteNodeCommandDescriptor"=0,"AHTFunctionSequence"=3,"AppleKeyStoreTestUserClient"=0,"DahliaFunctions"=0,"AFKEPKextV2"=1,"AppleBCMWLANLQM"=0,"IOHDCPAuthSession"=2,"IosaRdmaControlMSR6"=1,"AppleMCA2Switch_SyncGenSel"=1,"AppleANS2NVMeController"=1,"AGXCLChannelG15"=5,"AppleARMSPMIDevice"=11,"IOKernelDebugger"=0,"IOAVServiceConcreteUserClient"=0,"AppleT8122PCIeC"=3,"AppleSPUHIDDriver"=8,"_IOFramebufferNotifier"=0,"IOPMPowerSource"=1,"IOAVIISAudioDMAEventSource"=0,"AppleARMPE"=1,"AppleUSBConfigurationDescriptorOrderedSet"=9,"OSDextCrash"=0,"IOThunderboltWorkLoop"=3,"IOMapper"=3,"RTBuddyBinaryLogEntryHandler"=5,"AGXGart"=1,"AppleBTMAONPMUAgent"=0,"iBootAudioVolumeManager"=1,"M2ScalerCSCRequest"=0,"DitherControlMSR8"=1,"AppleUSBHostDeviceIdler"=17,"IO80211QueueDescriptor"=0,"AGXTAChannelG15"=25,"AppleCSDS911CodecMikey"=1,"M2ScalerCSCColorConversionControlMSR4"=1,"IO80211NANDataPathManager"=0,"AppleTDMAKSDriver"=0,"AppleSSEUserClient"=2,"IODPSwitchUFP"=1,"AppleSCCTempSensor"=0,"IOAccessoryHIDDeviceUserClient"=0,"IOAudioControlUserClient"=0,"AppleMCA2SwitchRegs"=3,"OSValueObject<OSKextRequestResourceCallback>"=0,"AppleUSBNetworkingCommand"=24,"AGXPerfCtrSamplerGen11"=1,"IOAppleS8000AESAcceleratorCommand"=32,"RTBuddySlaveMemory"=3,"AppleBCMWLANBGScanAdapter"=0,"WCLScanRequest"=0,"AppleSPUBoraUartDriver"=0,"OSDextStatistics"=19,"AppleASMedia1042USBXHCICommandRing"=0,"AppleUSB20HubPort"=24,"IO80211TrafficMonitor"=0,"AppleMaverickBTM"=0,"IosaColorManagerMSR10"=1,"AppleSPUBattChannelUserClient"=0,"IODPHDCPMessageTransport"=4,"ApplePMPv2RegistryEntry"=392,"AppleBCMWLANChipManager"=0,"IOTimeSyncClockManagerDaemonClient"=2,"TimerEventSourceBridge"=0,"BTDebugAdapter"=0,"HIDMTQueueEventSourceWorkItem"=0,"AppleGCSyntheticDeviceUserClient"=0,"IO80211GASDefragFsm"=0,"AppleUSBXHCIFL1100CommandRing"=0,"IOAccessoryDock30Pin"=0,"AppleUSBHubPort"=2,"AppleBCMWLANBSSBeacon"=0,"ApplePMGRTempUserClient"=0,"AppleAuthCPRelayInterface"=0,"IosaTiledCompressedMemMSR7"=1,"IOAccessoryDock30PinBuiltIn"=0,"RTBuddyStringDecoder"=14,"DCPEndpointV2"=39,"WCLBGScanCore"=0,"AppleARMIISDevice"=6,"IosaRdmaControlMSR23"=0,"CCLogPipeUserClient"=0,"AppleSPUALSColorDriver"=1,"AppleATCDPHDMIPort"=1,"AppleAintreeBTM"=0,"AFKEndpointInterfaceRelay"=0,"ApplePCIECHostBridge"=3,"AppleBCMWLANPCIeDoorbell"=0,"IOBluetoothL2CAPChannel"=0,"M2ScalerCSCColorConversionControlMSR7"=1,"AppleDCPTCON"=0,"LogManagerDevice"=0,"ACMFirstResponderKernelService"=1,"AppleHIDTransportHibernator"=1,"AppleStoweBTMiPad"=0,"AppleBCMWLANCoreDbg"=0,"IOTimeSyncEthernetInterfaceAdapter"=0,"AppleT8122TypeCPhy"=4,"IO80211Glue"=0,"IOHDCP2ReceiverAuthSession"=0,"AppleUSBXHCIARIsochronousRequest"=0,"IosaDPEControlMSR8"=1,"CoreAnalyticsTestUserClient"=0,"M2ScalerCSCColorConversionControlMSR8"=1,"IOBluetoothMemoryBlock"=0,"AppleSPUGNSSDriver"=0,"AppleT6000USBXHCI"=0,"AppleTrustedAccessoryManagerUserClient"=1,"IOThunderboltControlPathListener"=16,"AppleT8103USBXHCI"=0,"IOGPUScheduler"=1,"AppleUSB30AccessoryHubPort"=0,"AppleThunderboltNHIReceiveRingManagerGenericACIO"=1,"H11ANEInUserClient"=0,"IosaDPEControlMSR23"=0,"IOAccessoryHIDDeviceInterface"=0,"OSValueObject<ANEMutableProcessParams>"=0,"IO80211VirtualInterface"=0,"AppleUSBDescriptorCache"=17,"AppleThunderboltDPOutAdapterOS2"=0,"AppleBCMWLANIOReporting"=0,"AppleOnboardSerialDebugDevice"=0,"AppleMCKAudioFunction"=0,"IOThunderboltXDPropertiesEntry"=39,"AppleANS3CGv2Controller"=1,"DCPDPControllerProxyUserClient"=0,"AppleARMQuadSPIDevice"=0,"AFKIOServiceClientBase"=0,"AppleMCA2Switch_RxSel"=1,"IOSurfaceSharedEventReference"=16,"IOExtensiblePaniclog"=0,"AppleUSBXDCIIsocTRBBlock"=0,"AGXParameterBufferBlockVirtual"=550,"AppleConvergedIPCRTIInterface"=6,"IOTimeSyncUserClient"=0,"AppleT700XTempSensorUserClient"=0,"AppleBCMWLANIOReportingCore"=0,"AppleSmartIOUserClient"=0,"AppleBCMWLANChipManagerPCIe4378"=0,"AppleT8150USBXHCI"=0,"IOAudioLevelControl"=0,"OSBoolean"=2,"AppleT8142DisplayCrossbar"=0,"AppleSEPCommand"=20,"IOCPUInterruptController"=0,"AppleM2ScalerCSCHalMSR25"=0,"AppleARMPWMInOutPulseController"=0,"AppleConvergedIPCRequest"=48,"AppleThunderboltIPControlCommand"=0,"IOBlockStorageDevice"=3,"IOWrappedMemoryDescriptor"=0,"AppleHPMInterfaceType15"=0,"AppleSPUBattChannelDriver"=0,"IOMbufBigMemoryCursor"=0,"IosaTiledCompressedMemMSR13"=1,"IOApplePartitionScheme"=0,"IOAsynchronousScheduler"=0,"MSR23BackwardsCompatibleFilter"=0,"IosaTunableControlMSR24d"=0,"_IOServiceStateNotification"=0,"AppleT8142USBXHCICommandRing"=0,"ApplePPMNormalizedResidencyReporter"=4,"AppleBCMWLANUserClient"=0,"SMMachine"=39,"IOAccessoryPowerSourceBehavior"=0,"AppleARMPWMDevice"=1,"AppleS5L8960XNCOFrequencyFunction"=1,"IOSkywalkLegacyEthernetInterface"=2,"IO80211Queue"=0,"AppleSCSISubsystemGlobals"=1,"IDBusTransportPrivate"=0,"AppleUSBHostFrameworkInterfaceClient"=6,"AppleDCPLPDPTXPortProxy"=0,"ApplePPMPTDManager"=1,"WCL11axActionFrameQueue"=0,"RTBuddyCoredumpMap"=13,"AppleARMPWMBacklightControllerUpdateFunction"=0,"AppleStockholmControl"=1,"CCPipeUserClient"=0,"IOHIDTimeSyncClientData"=0,"IOPortFeaturePowerSourceOptionFixed"=6,"mDNSHandoff"=0,"AppleBCMWLANSkywalkTxCompletionQueue"=0,"IOSCSIProtocolServices"=2,"WCLDisconnectSuppression"=0,"AppleT8142USBXDCI"=0,"IOAccessoryPowerSourceItemOrion"=0,"IOBluetoothL2CAPMemoryBlock"=0,"IOGuardPageMemoryDescriptor"=0,"KDIObject"=0,"IOPortTransportAIDBusUserClient"=0,"IO80211MacAddressAgent"=0,"AppleKeyStore"=1,"AIDSerialLogger"=6,"AudioDMATransferCommand"=72,"M2ScalerSrcDestCfgControlMSR4"=1,"IO80211DynamicBufferPool"=0,"AppleThunderboltNHITransmitRingManagerType7"=0,"IOSlowAdaptiveClockingManager"=1,"IO80211LinkQualityMonitor"=0,"DCPAVDeviceProxyUserClient"=0,"WCLSystemStateManager"=0,"IOTimeSyncNetworkPortDaemonClient"=0,"IOGraphicsControllerWorkLoop"=0,"IOHDCP2AuthSession"=1,"TulipaFunctions"=0,"AppleMultitouchDevice"=1,"AppleHCPM"=0,"AFKEPInterfaceEventSourceV2"=45,"IOBluetoothL2CAPInformationFrameMemoryBlock"=0,"AppleNVMeSMARTUserClient"=0,"AppleTDMEffaceableNORDriver"=0,"IOAVControlInterface"=0,"BTDebugUserClient"=0,"IOMobileFramebufferTilingMgr"=1,"IOPCIConfigurator"=4,"IosaFirmwareControlMSR23Dv"=0,"IOSharedDataQueue"=28,"WCLEPNOFsm"=0,"IO80211AsyncUserClientParameters"=0,"IosaColorManagerMSR20"=0,"IosaDPEControlMSR20"=0,"AppleSMCChargerUtil"=4,"WCLPNOFsm"=0,"AppleT8103USBXHCICommandRing"=0,"IOGPUDevice"=1,"cache"=0,"IOAccessoryPortDataQueue"=0,"_IOServiceNullNotifier"=1,"AppleBCMWLANNANDataInterface"=0,"AppleANS2CGNVMeController"=0,"IOPMinformee"=297,"IOAccelerationUserClient"=0,"IosaColorManagerMSR4"=1,"OSValueObject<ANEDriverClientContext>"=0,"IOHIDTestTimeSyncService"=0,"AppleStoweBTM"=0,"IOGatedOutputQueue"=0,"AppleUVDMEndpointInterface"=0,"H11ANEIn"=1,"M2ScalerCSCColorConversionControlMSR10j"=1,"AppleT6030ANEHAL"=1,"AppleAuthCP"=0,"AppleARMParamFIFO"=0,"AppleConvergedIPCReporter"=0,"AppleXsanScheme"=0,"AIDSharedMemoryManager"=1,"AppleARMIICUserClient"=0,"IOThunderboltIECSCommandQueue"=4,"M2ScalerScalingControlMSR6"=1,"ExclavesAudioProxyDebugTightbeam"=0,"IOGPUGLDrawableUserClient"=0,"IO80211SapProtocol"=0,"AppleAOPButtonHapticsServiceUserClient"=0,"EXBrightCalibrationConsumer"=0,"IO80211PeerMonitor"=0,"AFKEndpointInterface"=1,"AppleATCDPINAdapterPort"=6,"IOBufferMemoryDescriptor"=3921,"AppleConvergedIPCControlReporter"=0,"AppleANEMPMMapMemoryFunction"=0,"IOBioCondition"=0,"AppleUSBHostController"=1,"AppleARMFunctionUSBDataMonitor"=0,"AppleThunderboltNHI"=1,"PMSettingObject"=2,"IOHIDPointingEventDevice"=0,"IOAccelerator"=1,"AUAClockMultiplierDictionary"=0,"IOGPUVirtualMemory"=0,"AUAClockSelectorDictionary"=0,"IODisplayParameterHandler"=0,"_FlexWorkLoop"=1,"AppleConvergedIPCOLYBTControlReporter"=0,"IosaPowerManagerMSR"=1,"CCIOReporterDataStream"=0,"AGXCommandQueuePMConfig"=18,"WCLApFeatureConfig"=0,"AppleBCMWLANChipManagerPCIe43452"=0,"AppleSmartBatteryManagerUserClient"=0,"IOTimeSyncFDPtPPort"=0,"PMAssertionsTracker"=1,"IOTimeSyncEthernetControllerAdapter"=0,"AppleHIDTransportBootloaderRTBuddy"=1,"AppleSPUInterface"=2,"ApplePMGRFunctionClockGate"=1,"IO80211BSSBeacon"=0,"IOSkywalkNetworkInterface"=1,"IosaPrescalerControlMSR9"=0,"AppleUSBXHCIPCI"=1,"AppleUSBXHCICommandRing"=2,"AppleTCONComponent"=6,"IOAccessoryPowerSource"=0,"ExclavesAudioProxyInputStreamDriverTightbeam"=0,"IOHIDProximityElementProcessor"=0,"IosaChromaDownsamplePipeUnit"=0,"AppleARMNORFlashController"=1,"IOGPUEventFence"=1,"IosaRdmaControlMSR20"=0,"DCPAVAudioDriver"=1,"IO80211ScanRequest"=0,"IOAGPDevice"=0,"AppleARMFunctionSlowAdaptiveClocking"=1,"AppleSPUProfileDriver"=1,"AppleHDMIPortController"=1,"IOThunderboltCommandGate"=18,"IOFastPathHIDButtonService"=0,"IOMbufMemoryCursor"=0,"AVE_WorkThread"=0,"OSIterator"=2,"AppleMemCacheModeFunction"=2,"IOTBTTunnelUSBClientInterface"=6,"AppleDCPDPTXRemotePortUFP"=4,"AppleAOPVoiceTriggerUserClient"=1,"IODPSwitchEventLog"=1,"ISPCoredump"=0,"AppleAOPAudioService"=1,"AppleHPMDeviceHALType4"=0,"IOAccessoryManager"=1,"AppleT700XTempSensor"=0,"AppleMCA2Switch_SyncGenCfg"=4,"IOMFBEvtMonTrampoline"=0,"IosaPowerManagerMSR23"=0,"M2ScalerSrcDestCfgControlMSR10"=1,"CCDataPipeBlobOS"=0,"VADResourceArbiter"=0,"AppleARMPerformanceControllerFunctionPowerGate"=0,"AppleARMPMUPowerSensor"=78,"IOThunderboltDeficitCommandQueue"=1,"AppleHIDTransportBootloader"=3,"M2ScalerSrcDestCfgControlMSR23"=0},"IOMalloc allocation"=196480346}
applications/services/loader/loader_menu_storage.c:81:                    FS_Error error = storage_sd_format(storage);
applications/services/storage/storage.h:521:FS_Error storage_sd_format(Storage* storage);
applications/services/storage/storage_processing.c:482:static FS_Error storage_process_sd_format(Storage* app) {
applications/services/storage/storage_processing.c:488:        ret = sd_format_card(&app->storage[ST_EXT]);
applications/services/storage/storage_processing.c:788:        message->return_data->error_value = storage_process_sd_format(app);
applications/services/storage/storage_external_api.c:1057:FS_Error storage_sd_format(Storage* storage) {
applications/services/storage/storages/storage_ext.h:13:FS_Error sd_format_card(StorageData* storage);
applications/services/storage/storages/storage_ext.c:208:FS_Error sd_format_card(StorageData* storage) {
applications/services/storage/storage_cli.c:87:            FS_Error error = storage_sd_format(api);
applications/services/desktop/scenes/desktop_scene_pin_input.c:63:            storage_sd_format(storage);
applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c:42:    error = storage_sd_format(app->fs_api);

thinking
**Checking storage_ext.c for filesystem choice**
exec
/bin/zsh -lc "sed -n '180,260p' applications/services/storage/storages/storage_ext.c" in /Users/x/x/Momentum-Firmware succeeded in 118ms:
        FURI_LOG_I(TAG, "card mounted");

#ifndef FURI_RAM_EXEC
        if(furi_hal_rtc_is_flag_set(FuriHalRtcFlagStorageFormatInternal)) {
            FURI_LOG_I(TAG, "deleting internal storage directory");
            error = sd_remove_recursive(STORAGE_INTERNAL_DIR_NAME) ? FSE_OK : FSE_INTERNAL;
        } else {
            error = FSE_OK;
        }
#else
        UNUSED(sd_remove_recursive);
        error = FSE_OK;
#endif
    }

    if(notify) {
        NotificationApp* notification = furi_record_open(RECORD_NOTIFICATION);
        if(error != FSE_OK) {
            sd_notify_error(notification);
        } else {

thinking
**Investigating filesystem options**
exec
/bin/zsh -lc 'rg -n "FM_" applications services furi lib drivers -g"*.h"' in /Users/x/x/Momentum-Firmware exited 2 in 291ms:
rg: services: No such file or directory (os error 2)
lib/stm32wb_hal/Inc/stm32wbxx_ll_ipcc.h:291:  CLEAR_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
lib/stm32wb_hal/Inc/stm32wbxx_ll_ipcc.h:314:  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
lib/stm32wb_hal/Inc/stm32wbxx_ll_ipcc.h:337:  return ((READ_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos) != (Channel << IPCC_C1MR_CH1FM_Pos)) ? 1UL : 0UL);
lib/stm32wb_hal/Inc/stm32wbxx_ll_ipcc.h:429:  CLEAR_BIT(IPCCx->C2MR, Channel << IPCC_C2MR_CH1FM_Pos);
lib/stm32wb_hal/Inc/stm32wbxx_ll_ipcc.h:452:  SET_BIT(IPCCx->C2MR, Channel << (IPCC_C2MR_CH1FM_Pos));
lib/stm32wb_hal/Inc/stm32wbxx_ll_ipcc.h:475:  return ((READ_BIT(IPCCx->C2MR, Channel << IPCC_C2MR_CH1FM_Pos) != (Channel << IPCC_C2MR_CH1FM_Pos)) ? 1UL : 0UL);
lib/stm32wb_hal/Inc/stm32wbxx_hal_ipcc.h:168:                ((__HANDLE__)->Instance->C1MR |= (IPCC_C1MR_CH1FM_Msk << (__CHINDEX__))))
lib/stm32wb_hal/Inc/stm32wbxx_hal_ipcc.h:189:                ((__HANDLE__)->Instance->C1MR &= ~(IPCC_C1MR_CH1FM_Msk << (__CHINDEX__))))
lib/fatfs/ff.h:337:#define FM_FAT		0x01
lib/fatfs/ff.h:338:#define FM_FAT32	0x02
lib/fatfs/ff.h:339:#define FM_EXFAT	0x04
lib/fatfs/ff.h:340:#define FM_ANY		0x07
lib/fatfs/ff.h:341:#define FM_SFD		0x08
lib/drivers/bq25896_reg.h:175:    bool PFM_OTG_DIS  : 1; // PFM mode allowed in boost mode
lib/stm32wb_cmsis/Include/stm32wb55xx.h:12152:#define IPCC_C1MR_CH1FM_Pos      (16U)
lib/stm32wb_cmsis/Include/stm32wb55xx.h:12153:#define IPCC_C1MR_CH1FM_Msk      (0x1UL << IPCC_C1MR_CH1FM_Pos)                /*!< 0x00010000 */
lib/stm32wb_cmsis/Include/stm32wb55xx.h:12154:#define IPCC_C1MR_CH1FM          IPCC_C1MR_CH1FM_Msk                           /*!< M4 Transmit Channel1 free interrupt mask */
lib/stm32wb_cmsis/Include/stm32wb55xx.h:12155:#define IPCC_C1MR_CH2FM_Pos      (17U)
lib/stm32wb_cmsis/Include/stm32wb55xx.h:12156:#define IPCC_C1MR_CH2FM_Msk      (0x1UL << IPCC_C1MR_CH2FM_Pos)                /*!< 0x00020000 */

thinking
**Checking storage formatting options**
exec
/bin/zsh -lc "sed -n '1,220p' applications/settings/storage_settings/scenes/storage_settings_scene_start.c" in /Users/x/x/Momentum-Firmware succeeded in 120ms:
#include "../storage_settings.h"

void storage_settings_scene_start_on_enter(void* context) {
    StorageSettings* app = context;

    FS_Error sd_status = storage_sd_status(app->fs_api);
    app->helper_descriptor->options[STORAGE_SETTINGS_MOUNT_INDEX].name =
        (sd_status != FSE_OK) ? "Mount SD Card" : "Unmount SD Card";
    submenu_settings_helpers_scene_enter(app->settings_helper);
}

bool storage_settings_scene_start_on_event(void* context, SceneManagerEvent event) {
    StorageSettings* app = context;
    return submenu_settings_helpers_scene_event(app->settings_helper, event);
}

void storage_settings_scene_start_on_exit(void* context) {
    StorageSettings* app = context;
    submenu_settings_helpers_scene_exit(app->settings_helper);
}

thinking
**Searching for storage_settings.h**
exec
/bin/zsh -lc "sed -n '1,260p' applications/settings/storage_settings/storage_settings.h" in /Users/x/x/Momentum-Firmware succeeded in 108ms:
#pragma once
#include <furi.h>
#include <gui/gui.h>
#include <gui/view.h>
#include <gui/view_dispatcher.h>
#include <gui/scene_manager.h>
#include <assets_icons.h>
#include <notification/notification_messages.h>

#include <gui/modules/submenu.h>
#include <gui/modules/dialog_ex.h>
#include <gui/modules/popup.h>

#include <storage/storage.h>
#include <storage/storage_sd_api.h>

#include "scenes/storage_settings_scene.h"

#include <settings_helpers/submenu_based.h>


thinking
**Checking storage_settings.c for helper descriptor**
exec
/bin/zsh -lc "sed -n '1,260p' applications/settings/storage_settings/storage_settings.c" in /Users/x/x/Momentum-Firmware succeeded in 92ms:
#include "storage_settings.h"

const SubmenuSettingsHelperDescriptor descriptor_template = {
    .app_name = "Storage",
    .options_cnt = 7,
    .options =
        {
            {.name = "About Internal Storage", .scene_id = StorageSettingsInternalInfo},
            {.name = "About SD Card", .scene_id = StorageSettingsSDInfo},
            {.name = "Unmount SD Card", .scene_id = StorageSettingsUnmountConfirm},
            {.name = "Format SD Card", .scene_id = StorageSettingsFormatConfirm},
            {.name = "Benchmark SD Card", .scene_id = StorageSettingsBenchmarkConfirm},
            {.name = "Factory Reset", .scene_id = StorageSettingsFactoryReset},
            {.name = "Wipe Device", .scene_id = StorageSettingsWipeDevice},
        },
};

static bool storage_settings_custom_event_callback(void* context, uint32_t event) {
    furi_assert(context);
    StorageSettings* app = context;

thinking
**Investigating filesystem options for formatting**
exec
/bin/zsh -lc "sed -n '1000,1110p' applications/services/storage/storage_external_api.c" in /Users/x/x/Momentum-Firmware succeeded in 113ms:
    return storage_common_stat(storage, path, &file_info) == FSE_OK;
}

static bool storage_internal_equivalent_path(
    Storage* storage,
    const char* path1,
    const char* path2,
    bool check_subdir) {
    furi_check(storage);

    S_API_PROLOGUE;

    SAData data = {
        .cequivpath = {
            .path1 = path1,
            .path2 = path2,
            .check_subdir = check_subdir,
            .thread_id = furi_thread_get_current_id(),
        }};


thinking
**Planning new filesystem API**
exec
/bin/zsh -lc 'cat applications/services/storage/storage_sd_api.h' in /Users/x/x/Momentum-Firmware succeeded in 116ms:
#pragma once
#include <furi.h>
#include "filesystem_api_defines.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SD_LABEL_LENGTH 34

typedef enum {
    FST_UNKNOWN,
    FST_FAT12,
    FST_FAT16,
    FST_FAT32,
    FST_EXFAT,
} SDFsType;

typedef struct {
    SDFsType fs_type;

thinking
**Checking storage_processing.c for filesystem handling**
exec
/bin/zsh -lc "sed -n '440,560p' applications/services/storage/storage_processing.c" in /Users/x/x/Momentum-Firmware succeeded in 116ms:
    uint64_t* free_space) {
    StorageData* storage;
    FS_Error ret = storage_get_data(app, path, &storage);

    if(ret == FSE_OK) {
        FS_CALL(
            storage,
            common.fs_info(storage, cstr_path_without_vfs_prefix(path), total_space, free_space));
    }

    return ret;
}

static bool
    storage_process_common_equivalent_path(Storage* app, FuriString* path1, FuriString* path2) {
    bool ret = false;

    do {
        const StorageType storage_type1 = storage_get_type_by_path(path1);
        const StorageType storage_type2 = storage_get_type_by_path(path2);

thinking
**Preparing to update filesystem type handling**
exec
/bin/zsh -lc 'rg -n "StorageCommandSDFormat|SDFormat" applications/services/storage -g"*.h" -g"*.c"' in /Users/x/x/Momentum-Firmware succeeded in 123ms:
applications/services/storage/storage_external_api.c:1062:    S_API_MESSAGE(StorageCommandSDFormat);
applications/services/storage/storage_processing.c:787:    case StorageCommandSDFormat:
applications/services/storage/storage_message.h:166:    StorageCommandSDFormat,
exec
/bin/zsh -lc "sed -n '130,220p' applications/services/storage/storage_message.h" in /Users/x/x/Momentum-Firmware succeeded in 113ms:
    SADataPath path;
    SADataRename rename;

    SAInfo sdinfo;

    SAVirtualInit virtualinit;
} SAData;

typedef union {
    bool bool_value;
    uint16_t uint16_value;
    uint64_t uint64_value;
    FS_Error error_value;
    const char* cstring_value;
} SAReturn;

typedef enum {
    StorageCommandFileOpen,
    StorageCommandFileClose,
    StorageCommandFileRead,

thinking
**Designing filesystem selection for SD formatting**

I'm considering how to add filesystem options like FAT32 and exFAT to the SD formatting flow. Theres a balance between simplicity and UI clarityperhaps adding a new scene or dialog to let the user pick the filesystem before confirming format. Im also thinking about storing the selected filesystem type in scene state to integrate cleanly with existing formatting logic and reboot handling. This needs careful planning with scenes, states, and the UI components like DialogEx or Submenu.
exec
/bin/zsh -lc 'cat applications/settings/storage_settings/scenes/storage_settings_scene_config.h' in /Users/x/x/Momentum-Firmware succeeded in 110ms:
ADD_SCENE(storage_settings, start, Start)
ADD_SCENE(storage_settings, unmount_confirm, UnmountConfirm)
ADD_SCENE(storage_settings, unmounted, Unmounted)
ADD_SCENE(storage_settings, format_confirm, FormatConfirm)
ADD_SCENE(storage_settings, formatting, Formatting)
ADD_SCENE(storage_settings, sd_info, SDInfo)
ADD_SCENE(storage_settings, internal_info, InternalInfo)
ADD_SCENE(storage_settings, benchmark_confirm, BenchmarkConfirm)
ADD_SCENE(storage_settings, benchmark, Benchmark)
ADD_SCENE(storage_settings, factory_reset, FactoryReset)
ADD_SCENE(storage_settings, wipe_device, WipeDevice)

thinking
**Planning filesystem type integration**
exec
/bin/zsh -lc "sed -n '60,120p' applications/services/loader/loader_menu_storage.c" in /Users/x/x/Momentum-Firmware succeeded in 105ms:
        FormatFlag flag = furi_thread_flags_wait(FormatFlagAll, FuriFlagWaitAny, FuriWaitForever);
        if(flag == FormatFlagContinue) {
            char text[39];
            dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
            dialog_ex_set_icon(dialog_ex, 0, 0, NULL);
            dialog_ex_set_left_button_text(dialog_ex, "Cancel");
            dialog_ex_set_right_button_text(dialog_ex, "Format");
            for(uint8_t counter = 5; counter > 0; counter--) {
                snprintf(text, sizeof(text), "All data will be lost!\n%d presses left", counter);
                dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
                flag = furi_thread_flags_wait(FormatFlagAll, FuriFlagWaitAny, FuriWaitForever);
                if(flag != FormatFlagContinue) break;

                if(counter == 1) {
                    dialog_ex_set_header(
                        dialog_ex, "Formatting...", 70, 32, AlignCenter, AlignCenter);
                    dialog_ex_set_text(dialog_ex, NULL, 0, 0, AlignCenter, AlignCenter);
                    dialog_ex_set_icon(dialog_ex, 15, 20, &I_LoadingHourglass_24x24);
                    dialog_ex_set_left_button_text(dialog_ex, NULL);
                    dialog_ex_set_right_button_text(dialog_ex, NULL);

thinking
**Checking for other calls in storage_cli.c**
exec
/bin/zsh -lc "sed -n '60,120p' applications/services/storage/storage_cli.c" in /Users/x/x/Momentum-Firmware succeeded in 107ms:
                sd_info.oem_id,
                sd_info.product_name,
                sd_info.product_revision_major,
                sd_info.product_revision_minor,
                sd_info.product_serial_number,
                sd_info.manufacturing_month,
                sd_info.manufacturing_year);
        }
    } else {
        storage_cli_print_usage();
    }

    furi_record_close(RECORD_STORAGE);
}

static void storage_cli_format(PipeSide* pipe, FuriString* path, FuriString* args) {
    UNUSED(pipe);
    UNUSED(args);
    if(furi_string_cmp_str(path, STORAGE_INT_PATH_PREFIX) == 0) {
        storage_cli_print_error(FSE_NOT_IMPLEMENTED);

thinking
**Checking related file reference**
exec
/bin/zsh -lc "sed -n '1,120p' applications/services/desktop/scenes/desktop_scene_pin_input.c" in /Users/x/x/Momentum-Firmware succeeded in 107ms:
#include <furi.h>
#include <furi_hal.h>
#include <gui/scene_manager.h>
#include <gui/view_stack.h>
#include <stdint.h>
#include <notification/notification.h>
#include <notification/notification_messages.h>
#include <momentum/momentum.h>

#include "../desktop.h"
#include "../desktop_i.h"
#include "../views/desktop_events.h"
#include "../views/desktop_view_pin_input.h"
#include "../helpers/pin_code.h"
#include "desktop_scene.h"

#define WRONG_PIN_HEADER_TIMEOUT 3000
#define INPUT_PIN_VIEW_TIMEOUT   15000

typedef struct {

thinking
**Checking storage_sd_format function**
exec
/bin/zsh -lc "sed -n '480,540p' applications/services/storage/storage.h" in /Users/x/x/Momentum-Firmware succeeded in 115ms:
 */
const char* storage_error_get_desc(FS_Error error_id);

/**
 * @brief Get the numeric error identifier from a file instance.
 *
 * @warning It is not possible to get the error identifier after the file has been closed.
 *
 * @param file pointer to the file instance in question (must NOT be NULL).
 * @return numeric identifier of the last error associated with the file instance.
 */
FS_Error storage_file_get_error(File* file);

/**
 * @brief Get the internal (storage-specific) numeric error identifier from a file instance.
 *
 * @warning It is not possible to get the internal error identifier after the file has been closed.
 *
 * @param file pointer to the file instance in question (must NOT be NULL).
 * @return numeric identifier of the last internal error associated with the file instance.

thinking
**Planning filesystem type addition**

I'm figuring out how to let the user choose the filesystem type when formatting an SD card, adding a new enum for Auto, FAT32, and exFAT options, updating the UI to cycle these choices, and modifying the format function signature carefully to keep compatibility while passing the selected type through scene state.
exec
/bin/zsh -lc "rg -n \"storage_sd_format\\(\" -g\"*.c\" -g\"*.h\"" in /Users/x/x/Momentum-Firmware succeeded in 407ms:
applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c:42:    error = storage_sd_format(app->fs_api);
applications/services/loader/loader_menu_storage.c:81:                    FS_Error error = storage_sd_format(storage);
applications/services/storage/storage.h:521:FS_Error storage_sd_format(Storage* storage);
applications/services/storage/storage_external_api.c:1057:FS_Error storage_sd_format(Storage* storage) {
applications/services/storage/storage_cli.c:87:            FS_Error error = storage_sd_format(api);
applications/services/desktop/scenes/desktop_scene_pin_input.c:63:            storage_sd_format(storage);

thinking
**Planning SD format integration**
exec
/bin/zsh -lc "sed -n '1,140p' applications/services/storage/storage_message.h" in /Users/x/x/Momentum-Firmware succeeded in 82ms:
#pragma once
#include <furi.h>
#include <toolbox/api_lock.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    File* file;
    const char* path;
    FS_AccessMode access_mode;
    FS_OpenMode open_mode;
    FuriThreadId thread_id;
} SADataFOpen;

typedef struct {
    File* file;
    void* buff;
    uint16_t bytes_to_read;

thinking
**Analyzing storage and format dependencies**
exec
/bin/zsh -lc "sed -n '1,60p' applications/services/storage/storage_processing.c" in /Users/x/x/Momentum-Firmware succeeded in 96ms:
#include <m-list.h>
#include <m-dict.h>

#include "storage_processing.h"
#include "storage_internal_dirname_i.h"

#define TAG "Storage"

#define STORAGE_PATH_PREFIX_LEN 4u
_Static_assert(
    sizeof(STORAGE_ANY_PATH_PREFIX) == STORAGE_PATH_PREFIX_LEN + 1,
    "Any path prefix len mismatch");
_Static_assert(
    sizeof(STORAGE_EXT_PATH_PREFIX) == STORAGE_PATH_PREFIX_LEN + 1,
    "Ext path prefix len mismatch");
_Static_assert(
    sizeof(STORAGE_INT_PATH_PREFIX) == STORAGE_PATH_PREFIX_LEN + 1,
    "Int path prefix len mismatch");

#define FS_CALL(_storage, _fn) ret = _storage->fs_api->_fn;

thinking
**Tracing header dependencies**
exec
/bin/zsh -lc "sed -n '1,80p' applications/services/storage/storage_processing.h" in /Users/x/x/Momentum-Firmware succeeded in 112ms:
#pragma once
#include <furi.h>
#include "storage.h"
#include "storage_i.h"
#include "storage_message.h"
#include "storage_glue.h"

#ifdef __cplusplus
extern "C" {
#endif

FS_Error storage_get_data(Storage* app, FuriString* path, StorageData** storage);

void storage_process_message(Storage* app, StorageMessage* message);

#ifdef __cplusplus
}
#endif

thinking
**Checking include dependencies**
exec
/bin/zsh -lc "sed -n '1,40p' applications/services/storage/storage.h" in /Users/x/x/Momentum-Firmware succeeded in 105ms:
/**
 * @file storage.h
 * @brief APIs for working with storages, directories and files.
 */
#pragma once

#include <stdint.h>
#include "filesystem_api_defines.h"
#include "storage_sd_api.h"

#ifdef __cplusplus
extern "C" {
#endif

#define STORAGE_INT_PATH_PREFIX        "/int"
#define STORAGE_EXT_PATH_PREFIX        "/ext"
#define STORAGE_ANY_PATH_PREFIX        "/any"
#define STORAGE_MNT_PATH_PREFIX        "/mnt"
#define STORAGE_APP_DATA_PATH_PREFIX   "/data"
#define STORAGE_APP_ASSETS_PATH_PREFIX "/assets"

thinking
**Verifying header dependencies**
exec
/bin/zsh -lc 'rg -n "storage_message.h" applications/services/storage -g"*.c" -g"*.h"' in /Users/x/x/Momentum-Firmware succeeded in 94ms:
applications/services/storage/storage_processing.h:5:#include "storage_message.h"
applications/services/storage/storage.c:3:#include "storage_message.h"
applications/services/storage/storage_external_api.c:5:#include "storage_message.h"

thinking
**Checking header inclusion**
exec
/bin/zsh -lc "sed -n '1,40p' applications/services/storage/storage.c" in /Users/x/x/Momentum-Firmware succeeded in 107ms:
#include "storage.h"
#include "storage_i.h"
#include "storage_message.h"
#include "storage_processing.h"
#include "storage/storage_glue.h"
#include "storages/storage_ext.h"
#include <assets_icons.h>

#define STORAGE_TICK 1000

#define ICON_SD_MOUNTED &I_SDcardMounted_11x8
#define ICON_SD_ERROR   &I_SDcardFail_11x8

#define TAG "Storage"

static void storage_app_sd_icon_draw_callback(Canvas* canvas, void* context) {
    furi_assert(canvas);
    furi_assert(context);
    Storage* app = context;


thinking
**Updating SDFormatType integration**
exec
/bin/zsh -lc "sed -n '740,840p' applications/services/storage/storage_processing.c" in /Users/x/x/Momentum-Firmware succeeded in 112ms:
        message->return_data->error_value = storage_process_common_mkdir(app, path);
        break;
    case StorageCommandCommonFSInfo:
        path = furi_string_alloc_set(message->data->cfsinfo.fs_path);
        storage_process_alias(app, path, message->data->cfsinfo.thread_id, false);
        message->return_data->error_value = storage_process_common_fs_info(
            app, path, message->data->cfsinfo.total_space, message->data->cfsinfo.free_space);
        break;
    case StorageCommandCommonResolvePath:
        storage_process_alias(
            app, message->data->cresolvepath.path, message->data->cresolvepath.thread_id, true);
        break;

    case StorageCommandCommonEquivalentPath: {
        FuriString* path1 = furi_string_alloc_set(message->data->cequivpath.path1);
        FuriString* path2 = furi_string_alloc_set(message->data->cequivpath.path2);
        storage_path_trim_trailing_slashes(path1);
        storage_path_trim_trailing_slashes(path2);
        storage_process_alias(app, path1, message->data->cequivpath.thread_id, false);
        storage_process_alias(app, path2, message->data->cequivpath.thread_id, false);

thinking
**Updating format type handling**
exec
/bin/zsh -lc 'rg -n "FF_FS_EXFAT|EXFAT" lib/fatfs/ffconf.h' in /Users/x/x/Momentum-Firmware exited 2 in 108ms:
rg: lib/fatfs/ffconf.h: IO error for operation on lib/fatfs/ffconf.h: No such file or directory (os error 2)

thinking
**Checking configuration in ffconf.h**
exec
/bin/zsh -lc 'ls lib/fatfs' in /Users/x/x/Momentum-Firmware succeeded in 114ms:
SConscript
diskio.c
diskio.h
ff.c
ff.h
ff_gen_drv.c
ff_gen_drv.h
ffconf_template.h
integer.h
option

thinking
**Checking for build configuration files**
exec
/bin/zsh -lc 'rg -n "FF_FS_EXFAT|EXFAT" lib/fatfs -g"*.h" -g"*.c"' in /Users/x/x/Momentum-Firmware succeeded in 108ms:
lib/fatfs/ff.h:72:#if _FS_EXFAT
lib/fatfs/ff.h:100:#if _FS_EXFAT
lib/fatfs/ff.h:112:#if _FS_EXFAT
lib/fatfs/ff.h:139:#if _FS_EXFAT
lib/fatfs/ff.h:339:#define FM_EXFAT	0x04
lib/fatfs/ff.h:347:#define FS_EXFAT	4
lib/fatfs/ffconf_template.h:233:#define _FS_EXFAT	0
lib/fatfs/ff.c:330:#define	MAX_EXFAT	0x7FFFFFFD		/* Max exFAT clusters (differs from specs, implementation limit) */
lib/fatfs/ff.c:556:#if _FS_EXFAT
lib/fatfs/ff.c:565:#if _FS_EXFAT
lib/fatfs/ff.c:576:#if _FS_EXFAT
lib/fatfs/ff.c:634:#if _FS_EXFAT
lib/fatfs/ff.c:669:#if _FS_EXFAT
lib/fatfs/ff.c:1036:#if _FS_EXFAT
lib/fatfs/ff.c:1037:		case FS_EXFAT :
lib/fatfs/ff.c:1115:#if _FS_EXFAT
lib/fatfs/ff.c:1116:		case FS_EXFAT :
lib/fatfs/ff.c:1120:			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
lib/fatfs/ff.c:1136:#if _FS_EXFAT && !_FS_READONLY
lib/fatfs/ff.c:1262:#endif	/* _FS_EXFAT && !_FS_READONLY */

thinking
**Investigating exFAT support configuration**
exec
/bin/zsh -lc 'rg -n "_FS_EXFAT" -g"*.h" -g"*.c"' in /Users/x/x/Momentum-Firmware succeeded in 367ms:
targets/f7/fatfs/ffconf.h:221:#define _FS_EXFAT 1
lib/fatfs/ff.h:72:#if _FS_EXFAT
lib/fatfs/ff.h:100:#if _FS_EXFAT
lib/fatfs/ff.h:112:#if _FS_EXFAT
lib/fatfs/ff.h:139:#if _FS_EXFAT
lib/fatfs/ffconf_template.h:233:#define _FS_EXFAT	0
lib/fatfs/ff.c:556:#if _FS_EXFAT
lib/fatfs/ff.c:565:#if _FS_EXFAT
lib/fatfs/ff.c:576:#if _FS_EXFAT
lib/fatfs/ff.c:634:#if _FS_EXFAT
lib/fatfs/ff.c:669:#if _FS_EXFAT
lib/fatfs/ff.c:1036:#if _FS_EXFAT
lib/fatfs/ff.c:1115:#if _FS_EXFAT
lib/fatfs/ff.c:1120:			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
lib/fatfs/ff.c:1136:#if _FS_EXFAT && !_FS_READONLY
lib/fatfs/ff.c:1262:#endif	/* _FS_EXFAT && !_FS_READONLY */
lib/fatfs/ff.c:1280:#if _FS_EXFAT || _USE_TRIM
lib/fatfs/ff.c:1290:	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
lib/fatfs/ff.c:1301:		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
lib/fatfs/ff.c:1309:#if _FS_EXFAT || _USE_TRIM

thinking
**Designing exFAT support integration**

I'm mapping out how to expose exFAT format options in the UI based on the build config flag, while keeping CLI and loader defaults untouched. I plan to extend storage APIs and scene states to pass format types cleanly, updating dialog behavior to cycle format choices. I'll add new fields, enums, and helper functions to tie together format selection and actual formatting calls without breaking legacy code. This also involves careful management of scene states and app-level storage to avoid conflicting uses. Lots of moving parts, but this should neatly surface format choice to the user while maintaining backward compatibility.
exec
/bin/zsh -lc "sed -n '1,40p' applications/services/storage/storage_external_api.c" in /Users/x/x/Momentum-Firmware succeeded in 110ms:
#include <core/log.h>
#include <core/record.h>
#include "storage.h"
#include "storage_i.h" // IWYU pragma: keep
#include "storage_message.h"
#include <toolbox/stream/file_stream.h>
#include <toolbox/dir_walk.h>
#include "toolbox/path.h"

#define MAX_NAME_LENGTH  254
#define FILE_BUFFER_SIZE 512

#define TAG "StorageApi"

#define S_API_PROLOGUE FuriApiLock lock = api_lock_alloc_locked();

#define S_FILE_API_PROLOGUE           \
    furi_check(file);                 \
    Storage* storage = file->storage; \
    furi_check(storage);

thinking
**Planning SDFormatType integration**

I'm mapping out how to add an SDFormatType enum and propagate it through storage headers and source files. I'll update function signatures, data structures, and UI dialogs to handle the different SD format types consistently, making sure to check SD readiness before toggling format options. This involves careful header includes and updating call sites to maintain compatibility.
exec
/bin/zsh -lc "sed -n '1,20p' applications/services/loader/loader_menu_storage.c" in /Users/x/x/Momentum-Firmware succeeded in 112ms:
#include "loader_menu_storage_i.h"

#include <core/thread.h>
#include <storage/storage.h>
#include <gui/modules/dialog_ex.h>
#include <gui/view_holder.h>
#include <assets_icons.h>

#include "loader.h"

typedef enum {
    FormatFlagContinue = (1 << 0),
    FormatFlagCancel = (1 << 1),
    FormatFlagAll = (FormatFlagContinue | FormatFlagCancel),
} FormatFlag;

static void loader_menu_storage_settings_callback(DialogExResult result, void* context) {
    FuriThread* thread = context;
    furi_thread_flags_set(
        furi_thread_get_id(thread),

thinking
**Checking header inclusions**
exec
/bin/zsh -lc "sed -n '1,20p' applications/services/storage/storage_cli.c" in /Users/x/x/Momentum-Firmware succeeded in 118ms:
#include <furi.h>
#include <furi_hal.h>

#include <toolbox/cli/cli_command.h>
#include <toolbox/cli/cli_ansi.h>
#include <cli/cli_main_commands.h>
#include <lib/toolbox/args.h>
#include <lib/toolbox/dir_walk.h>
#include <lib/toolbox/md5_calc.h>
#include <lib/toolbox/strint.h>
#include <lib/toolbox/tar/tar_archive.h>
#include <storage/storage.h>
#include <storage/storage_sd_api.h>
#include <power/power_service/power.h>
#include <toolbox/pipe.h>

#define MAX_NAME_LENGTH 254

static void storage_cli_print_usage(void);


thinking
**Reviewing header includes for storage dependencies**
exec
/bin/zsh -lc 'rg -n "storage_sd_format" -n applications/services/desktop -g"*.h"' in /Users/x/x/Momentum-Firmware exited 1 in 117ms:


thinking
**Checking header inclusions for storage usage**
exec
/bin/zsh -lc "sed -n '1,40p' applications/services/desktop/desktop.h" in /Users/x/x/Momentum-Firmware succeeded in 118ms:
#pragma once

#include <furi.h>

#include "desktop_settings.h"

#define RECORD_DESKTOP "desktop"

typedef struct Desktop Desktop;

typedef struct {
    bool locked;
} DesktopStatus;

bool desktop_api_is_locked(Desktop* instance);

void desktop_api_unlock(Desktop* instance);

FuriPubSub* desktop_api_get_status_pubsub(Desktop* instance);


thinking
**Investigating storage inclusion**
exec
/bin/zsh -lc "sed -n '1,40p' applications/services/desktop/desktop_i.h" in /Users/x/x/Momentum-Firmware succeeded in 81ms:
#pragma once

#include "desktop.h"
#include "desktop_settings.h"
#include "desktop_keybinds.h"

#include "animations/animation_manager.h"
#include "views/desktop_view_pin_timeout.h"
#include "views/desktop_view_pin_input.h"
#include "views/desktop_view_locked.h"
#include "views/desktop_view_main.h"
#include "views/desktop_view_lock_menu.h"
#include "views/desktop_view_debug.h"
#include "views/desktop_view_slideshow.h"

#include <gui/gui.h>
#include <gui/view_stack.h>
#include <gui/view_dispatcher.h>
#include <gui/modules/popup.h>
#include <gui/scene_manager.h>

thinking
**Tracing header inclusions**
exec
/bin/zsh -lc "sed -n '1,40p' applications/services/desktop/scenes/desktop_scene.h" in /Users/x/x/Momentum-Firmware succeeded in 110ms:
#pragma once

#include <gui/scene_manager.h>

// Generate scene id and total number
#define ADD_SCENE(prefix, name, id) DesktopScene##id,
typedef enum {
#include "desktop_scene_config.h"
    DesktopSceneNum,
} DesktopScene;
#undef ADD_SCENE

extern const SceneManagerHandlers desktop_scene_handlers;

// Generate scene on_enter handlers declaration
#define ADD_SCENE(prefix, name, id) void prefix##_scene_##name##_on_enter(void*);
#include "desktop_scene_config.h"
#undef ADD_SCENE

// Generate scene on_event handlers declaration

thinking
**Verifying storage header includes**
exec
/bin/zsh -lc "rg -n \"#include \\\"storage.h\\\"|storage.h\" furi/furi.h" in /Users/x/x/Momentum-Firmware exited 1 in 126ms:


thinking
**Investigating header dependencies**
exec
/bin/zsh -lc 'rg -n "storage_sd_format|storage.h" applications/services/desktop -g"*.h" -g"*.c"' in /Users/x/x/Momentum-Firmware succeeded in 117ms:
applications/services/desktop/animations/animation_manager.c:8:#include <storage/storage.h>
applications/services/desktop/animations/animation_manager.c:13:#include "animation_storage.h"
applications/services/desktop/animations/animation_storage_i.h:2:#include "animation_storage.h"
applications/services/desktop/views/desktop_view_slideshow.h:7:#include <storage/storage.h>
applications/services/desktop/desktop.c:8:#include <storage/storage.h>
applications/services/desktop/animations/animation_storage.c:6:#include <storage/storage.h>
applications/services/desktop/animations/animation_storage.c:10:#include "animation_storage.h"
applications/services/desktop/desktop_settings.c:5:#include <storage/storage.h>
applications/services/desktop/desktop_keybinds.c:7:#include <storage/storage.h>
applications/services/desktop/helpers/slideshow.c:3:#include <storage/storage.h>
applications/services/desktop/scenes/desktop_scene_slideshow.c:1:#include <storage/storage.h>
applications/services/desktop/scenes/desktop_scene_pin_input.c:63:            storage_sd_format(storage);

thinking
**Preparing comprehensive storage format changes**

I'm planning to carefully adjust multiple storage-related files to support a new format type parameter for SD card formatting. This involves adding the appropriate header includes, updating function signatures and calls across CLI, UI scenes, APIs, and the formatting logic itself, while ensuring default behaviors and UI elements reflect the changes smoothly. I'll handle these incremental updates methodically, including enums, dialog interactions, and format options, to keep the behavior consistent and backward compatible.
file update
M /Users/x/x/Momentum-Firmware/applications/services/storage/storage_sd_api.h
@@ -18,2 +18,8 @@
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
apply_patch(auto_approved=true) exited 0 in 37ms:
Success. Updated the following files:
M applications/services/storage/storage_sd_api.h
file update:
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;

file update:
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;


thinking
**Modifying storage.h function signature**
file update
M /Users/x/x/Momentum-Firmware/applications/services/storage/storage.h
@@ -518,5 +518,6 @@
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
apply_patch(auto_approved=true) exited 0 in 47ms:
Success. Updated the following files:
M applications/services/storage/storage.h
file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;

file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;


thinking
**Adding sdformat struct and SAData to storage_message.h**
file update
M /Users/x/x/Momentum-Firmware/applications/services/storage/storage_message.h
@@ -110,2 +110,6 @@
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
@@ -132,2 +136,3 @@
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
apply_patch(auto_approved=true) exited 0 in 57ms:
Success. Updated the following files:
M applications/services/storage/storage_message.h
file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;

file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;


thinking
**Updating storage API includes and signatures**
file update
M /Users/x/x/Momentum-Firmware/applications/services/storage/storage_external_api.c
@@ -1056,3 +1056,3 @@
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
@@ -1060,3 +1060,6 @@
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
apply_patch(auto_approved=true) exited 0 in 63ms:
Success. Updated the following files:
M applications/services/storage/storage_external_api.c
file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;

file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;


thinking
**Updating storage_process_sd_format function**
file update
M /Users/x/x/Momentum-Firmware/applications/services/storage/storage_processing.c
@@ -481,3 +481,3 @@
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
@@ -487,3 +487,3 @@
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
@@ -787,3 +787,4 @@
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
apply_patch(auto_approved=true) exited 0 in 75ms:
Success. Updated the following files:
M applications/services/storage/storage_processing.c
file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;

file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;


thinking
**Modifying storage_ext.h signature**
file update
M /Users/x/x/Momentum-Firmware/applications/services/storage/storages/storage_ext.h
@@ -12,3 +12,3 @@
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
apply_patch(auto_approved=true) exited 0 in 83ms:
Success. Updated the following files:
M applications/services/storage/storages/storage_ext.h
file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);

file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);


thinking
**Updating storage_ext.c**
file update
M /Users/x/x/Momentum-Firmware/applications/services/storage/storages/storage_ext.c
@@ -207,5 +207,18 @@
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
@@ -217,3 +230,3 @@
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
apply_patch(auto_approved=true) exited 0 in 89ms:
Success. Updated the following files:
M applications/services/storage/storages/storage_ext.c
file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);

file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);


thinking
**Updating storage settings struct**
file update
M /Users/x/x/Momentum-Firmware/applications/settings/storage_settings/storage_settings.h
@@ -31,2 +31,3 @@
     Storage* fs_api;
+    SDFormatType format_type;
 
apply_patch(auto_approved=true) exited 0 in 101ms:
Success. Updated the following files:
M applications/settings/storage_settings/storage_settings.h
file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;

file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Setting default value in storage settings**
file update
M /Users/x/x/Momentum-Firmware/applications/settings/storage_settings/storage_settings.c
@@ -35,2 +35,3 @@
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
apply_patch(auto_approved=true) exited 0 in 110ms:
Success. Updated the following files:
M applications/settings/storage_settings/storage_settings.c
file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;

file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Updating storage settings scene format**
file update
M /Users/x/x/Momentum-Firmware/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -9,7 +9,18 @@
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
@@ -20,10 +31,27 @@
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
@@ -42,5 +70,28 @@
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
apply_patch(auto_approved=true) exited 0 in 156ms:
Success. Updated the following files:
M applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..a80995be6812504f94490c68c1d44f0f1cc4f562
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -7,25 +7,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +68,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;

file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..a80995be6812504f94490c68c1d44f0f1cc4f562
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -7,25 +7,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +68,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Adding stdio include for snprintf**
file update
M /Users/x/x/Momentum-Firmware/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,2 +1,3 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
apply_patch(auto_approved=true) exited 0 in 122ms:
Success. Updated the following files:
M applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;

file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Updating scene formatting to use app format_type**
file update
M /Users/x/x/Momentum-Firmware/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -41,3 +41,3 @@
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
apply_patch(auto_approved=true) exited 0 in 132ms:
Success. Updated the following files:
M applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;

file update:
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Updating call sites for SDFormatTypeAuto**
file update
M /Users/x/x/Momentum-Firmware/applications/services/loader/loader_menu_storage.c
@@ -80,3 +80,3 @@
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
apply_patch(auto_approved=true) exited 0 in 134ms:
Success. Updated the following files:
M applications/services/loader/loader_menu_storage.c
file update:
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;

file update:
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Updating storage_cli.c**
file update
M /Users/x/x/Momentum-Firmware/applications/services/storage/storage_cli.c
@@ -86,3 +86,3 @@
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
apply_patch(auto_approved=true) exited 0 in 112ms:
Success. Updated the following files:
M applications/services/storage/storage_cli.c
file update:
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;

file update:
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Updating includes and function calls**
file update
M /Users/x/x/Momentum-Firmware/applications/services/desktop/scenes/desktop_scene_pin_input.c
@@ -7,2 +7,3 @@
 #include <notification/notification_messages.h>
+#include <storage/storage.h>
 #include <momentum/momentum.h>
@@ -62,3 +63,3 @@
             Storage* storage = furi_record_open(RECORD_STORAGE);
-            storage_sd_format(storage);
+            storage_sd_format(storage, SDFormatTypeAuto);
             furi_record_close(RECORD_STORAGE);
apply_patch(auto_approved=true) exited 0 in 159ms:
Success. Updated the following files:
M applications/services/desktop/scenes/desktop_scene_pin_input.c
file update:
diff --git a/applications/services/desktop/scenes/desktop_scene_pin_input.c b/applications/services/desktop/scenes/desktop_scene_pin_input.c
index a7a05667fb64a24681da3e2d543eb3caf5826c5d..2533a8baac330312be00081d2bddc0cf10d9a02b
--- a/applications/services/desktop/scenes/desktop_scene_pin_input.c
+++ b/applications/services/desktop/scenes/desktop_scene_pin_input.c
@@ -5,6 +5,7 @@
 #include <stdint.h>
 #include <notification/notification.h>
 #include <notification/notification_messages.h>
+#include <storage/storage.h>
 #include <momentum/momentum.h>
 
 #include "../desktop.h"
@@ -60,7 +61,7 @@
         uint32_t pin_fails = furi_hal_rtc_get_pin_fails() + 1;
         if(pin_fails >= 10 && momentum_settings.bad_pins_format) {
             Storage* storage = furi_record_open(RECORD_STORAGE);
-            storage_sd_format(storage);
+            storage_sd_format(storage, SDFormatTypeAuto);
             furi_record_close(RECORD_STORAGE);
             furi_hal_rtc_reset_registers();
             Power* power = furi_record_open(RECORD_POWER);
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;

file update:
diff --git a/applications/services/desktop/scenes/desktop_scene_pin_input.c b/applications/services/desktop/scenes/desktop_scene_pin_input.c
index a7a05667fb64a24681da3e2d543eb3caf5826c5d..2533a8baac330312be00081d2bddc0cf10d9a02b
--- a/applications/services/desktop/scenes/desktop_scene_pin_input.c
+++ b/applications/services/desktop/scenes/desktop_scene_pin_input.c
@@ -5,6 +5,7 @@
 #include <stdint.h>
 #include <notification/notification.h>
 #include <notification/notification_messages.h>
+#include <storage/storage.h>
 #include <momentum/momentum.h>
 
 #include "../desktop.h"
@@ -60,7 +61,7 @@
         uint32_t pin_fails = furi_hal_rtc_get_pin_fails() + 1;
         if(pin_fails >= 10 && momentum_settings.bad_pins_format) {
             Storage* storage = furi_record_open(RECORD_STORAGE);
-            storage_sd_format(storage);
+            storage_sd_format(storage, SDFormatTypeAuto);
             furi_record_close(RECORD_STORAGE);
             furi_hal_rtc_reset_registers();
             Power* power = furi_record_open(RECORD_POWER);
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Updating storage format references**
exec
/bin/zsh -lc "rg -n \"storage_sd_format\\(\" -g\"*.c\" -g\"*.h\"" in /Users/x/x/Momentum-Firmware succeeded in 365ms:
applications/services/storage/storage.h:522:FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
applications/services/storage/storage_external_api.c:1057:FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
applications/services/storage/storage_cli.c:87:            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
applications/services/loader/loader_menu_storage.c:81:                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c:42:    error = storage_sd_format(app->fs_api, app->format_type);
applications/services/desktop/scenes/desktop_scene_pin_input.c:64:            storage_sd_format(storage, SDFormatTypeAuto);
file update:
diff --git a/applications/services/desktop/scenes/desktop_scene_pin_input.c b/applications/services/desktop/scenes/desktop_scene_pin_input.c
index a7a05667fb64a24681da3e2d543eb3caf5826c5d..2533a8baac330312be00081d2bddc0cf10d9a02b
--- a/applications/services/desktop/scenes/desktop_scene_pin_input.c
+++ b/applications/services/desktop/scenes/desktop_scene_pin_input.c
@@ -5,6 +5,7 @@
 #include <stdint.h>
 #include <notification/notification.h>
 #include <notification/notification_messages.h>
+#include <storage/storage.h>
 #include <momentum/momentum.h>
 
 #include "../desktop.h"
@@ -60,7 +61,7 @@
         uint32_t pin_fails = furi_hal_rtc_get_pin_fails() + 1;
         if(pin_fails >= 10 && momentum_settings.bad_pins_format) {
             Storage* storage = furi_record_open(RECORD_STORAGE);
-            storage_sd_format(storage);
+            storage_sd_format(storage, SDFormatTypeAuto);
             furi_record_close(RECORD_STORAGE);
             furi_hal_rtc_reset_registers();
             Power* power = furi_record_open(RECORD_POWER);
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Checking for sd_format_card usage**
exec
/bin/zsh -lc "rg -n \"sd_format_card\\(\" applications/services/storage -g\"*.c\" -g\"*.h\"" in /Users/x/x/Momentum-Firmware succeeded in 123ms:
applications/services/storage/storage_processing.c:488:        ret = sd_format_card(&app->storage[ST_EXT], format_type);
applications/services/storage/storages/storage_ext.h:13:FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
applications/services/storage/storages/storage_ext.c:220:FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
file update:
diff --git a/applications/services/desktop/scenes/desktop_scene_pin_input.c b/applications/services/desktop/scenes/desktop_scene_pin_input.c
index a7a05667fb64a24681da3e2d543eb3caf5826c5d..2533a8baac330312be00081d2bddc0cf10d9a02b
--- a/applications/services/desktop/scenes/desktop_scene_pin_input.c
+++ b/applications/services/desktop/scenes/desktop_scene_pin_input.c
@@ -5,6 +5,7 @@
 #include <stdint.h>
 #include <notification/notification.h>
 #include <notification/notification_messages.h>
+#include <storage/storage.h>
 #include <momentum/momentum.h>
 
 #include "../desktop.h"
@@ -60,7 +61,7 @@
         uint32_t pin_fails = furi_hal_rtc_get_pin_fails() + 1;
         if(pin_fails >= 10 && momentum_settings.bad_pins_format) {
             Storage* storage = furi_record_open(RECORD_STORAGE);
-            storage_sd_format(storage);
+            storage_sd_format(storage, SDFormatTypeAuto);
             furi_record_close(RECORD_STORAGE);
             furi_hal_rtc_reset_registers();
             Power* power = furi_record_open(RECORD_POWER);
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Checking and updating storage includes and text size**
exec
/bin/zsh -lc "sed -n '1,30p' applications/services/storage/storages/storage_ext.c" in /Users/x/x/Momentum-Firmware succeeded in 114ms:
#include <fatfs.h>
#include <furi_hal.h>
#include <furi_hal_sd.h>
#include <toolbox/path.h>

#include "sd_notify.h"
#include "storage_ext.h"

#include "../filesystem_api_internal.h"
#include "../storage_internal_dirname_i.h"

typedef FIL SDFile;
typedef DIR SDDir;
typedef FILINFO SDFileInfo;
typedef FRESULT SDError;

#define TAG "StorageExt"

/********************* Definitions ********************/

file update:
diff --git a/applications/services/desktop/scenes/desktop_scene_pin_input.c b/applications/services/desktop/scenes/desktop_scene_pin_input.c
index a7a05667fb64a24681da3e2d543eb3caf5826c5d..2533a8baac330312be00081d2bddc0cf10d9a02b
--- a/applications/services/desktop/scenes/desktop_scene_pin_input.c
+++ b/applications/services/desktop/scenes/desktop_scene_pin_input.c
@@ -5,6 +5,7 @@
 #include <stdint.h>
 #include <notification/notification.h>
 #include <notification/notification_messages.h>
+#include <storage/storage.h>
 #include <momentum/momentum.h>
 
 #include "../desktop.h"
@@ -60,7 +61,7 @@
         uint32_t pin_fails = furi_hal_rtc_get_pin_fails() + 1;
         if(pin_fails >= 10 && momentum_settings.bad_pins_format) {
             Storage* storage = furi_record_open(RECORD_STORAGE);
-            storage_sd_format(storage);
+            storage_sd_format(storage, SDFormatTypeAuto);
             furi_record_close(RECORD_STORAGE);
             furi_hal_rtc_reset_registers();
             Power* power = furi_record_open(RECORD_POWER);
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Checking includes in storage_ext.h**
exec
/bin/zsh -lc "sed -n '1,40p' applications/services/storage/storages/storage_ext.h" in /Users/x/x/Momentum-Firmware succeeded in 110ms:
#pragma once
#include <furi.h>
#include "../storage_glue.h"
#include "../storage_sd_api.h"

#ifdef __cplusplus
extern "C" {
#endif

void storage_ext_init(StorageData* storage);
FS_Error sd_mount_card(StorageData* storage, bool notify);
FS_Error sd_unmount_card(StorageData* storage);
FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);

void storage_mnt_init(StorageData* storage);
FS_Error
    storage_process_virtual_init(StorageData* storage, File* image, StorageData* image_storage);
FS_Error storage_process_virtual_format(StorageData* storage);
FS_Error storage_process_virtual_mount(StorageData* storage);
file update:
diff --git a/applications/services/desktop/scenes/desktop_scene_pin_input.c b/applications/services/desktop/scenes/desktop_scene_pin_input.c
index a7a05667fb64a24681da3e2d543eb3caf5826c5d..2533a8baac330312be00081d2bddc0cf10d9a02b
--- a/applications/services/desktop/scenes/desktop_scene_pin_input.c
+++ b/applications/services/desktop/scenes/desktop_scene_pin_input.c
@@ -5,6 +5,7 @@
 #include <stdint.h>
 #include <notification/notification.h>
 #include <notification/notification_messages.h>
+#include <storage/storage.h>
 #include <momentum/momentum.h>
 
 #include "../desktop.h"
@@ -60,7 +61,7 @@
         uint32_t pin_fails = furi_hal_rtc_get_pin_fails() + 1;
         if(pin_fails >= 10 && momentum_settings.bad_pins_format) {
             Storage* storage = furi_record_open(RECORD_STORAGE);
-            storage_sd_format(storage);
+            storage_sd_format(storage, SDFormatTypeAuto);
             furi_record_close(RECORD_STORAGE);
             furi_hal_rtc_reset_registers();
             Power* power = furi_record_open(RECORD_POWER);
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..3b7138ba6f04f793266c637bcc6a586bb24b4573
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,53 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
+
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
     DialogEx* dialog_ex = app->dialog_ex;
-
-    FS_Error sd_status = storage_sd_status(app->fs_api);
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +69,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Refining dialog icon handling and formatting in storage settings scene**

I'll update the storage_settings_scene_format_confirm.c to ensure it uses snprintf properly and includes stdio. I want to improve dialog behavior by clearing the icon when in the ready state to avoid leftover icons from the not ready state. This involves calling dialog_ex_set_icon with null values when the SD card is ready. Also, I'll make sure text alignment and length are handled correctly for both ready and not ready states. The goal is to keep the dialog display clean and consistent as the SD card status changes.
file update
M /Users/x/x/Momentum-Firmware/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -43,2 +43,3 @@
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
+        dialog_ex_set_icon(dialog_ex, 0, 0, NULL);
         dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
apply_patch(auto_approved=true) exited 0 in 152ms:
Success. Updated the following files:
M applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
file update:
diff --git a/applications/services/desktop/scenes/desktop_scene_pin_input.c b/applications/services/desktop/scenes/desktop_scene_pin_input.c
index a7a05667fb64a24681da3e2d543eb3caf5826c5d..2533a8baac330312be00081d2bddc0cf10d9a02b
--- a/applications/services/desktop/scenes/desktop_scene_pin_input.c
+++ b/applications/services/desktop/scenes/desktop_scene_pin_input.c
@@ -5,6 +5,7 @@
 #include <stdint.h>
 #include <notification/notification.h>
 #include <notification/notification_messages.h>
+#include <storage/storage.h>
 #include <momentum/momentum.h>
 
 #include "../desktop.h"
@@ -60,7 +61,7 @@
         uint32_t pin_fails = furi_hal_rtc_get_pin_fails() + 1;
         if(pin_fails >= 10 && momentum_settings.bad_pins_format) {
             Storage* storage = furi_record_open(RECORD_STORAGE);
-            storage_sd_format(storage);
+            storage_sd_format(storage, SDFormatTypeAuto);
             furi_record_close(RECORD_STORAGE);
             furi_hal_rtc_reset_registers();
             Power* power = furi_record_open(RECORD_POWER);
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..cef306a1092f899c3b13662d7a24151649538fd8
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,54 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
-    DialogEx* dialog_ex = app->dialog_ex;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
 
-    FS_Error sd_status = storage_sd_status(app->fs_api);
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
+    DialogEx* dialog_ex = app->dialog_ex;
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_icon(dialog_ex, 0, 0, NULL);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +70,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;

file update:
diff --git a/applications/services/desktop/scenes/desktop_scene_pin_input.c b/applications/services/desktop/scenes/desktop_scene_pin_input.c
index a7a05667fb64a24681da3e2d543eb3caf5826c5d..2533a8baac330312be00081d2bddc0cf10d9a02b
--- a/applications/services/desktop/scenes/desktop_scene_pin_input.c
+++ b/applications/services/desktop/scenes/desktop_scene_pin_input.c
@@ -5,6 +5,7 @@
 #include <stdint.h>
 #include <notification/notification.h>
 #include <notification/notification_messages.h>
+#include <storage/storage.h>
 #include <momentum/momentum.h>
 
 #include "../desktop.h"
@@ -60,7 +61,7 @@
         uint32_t pin_fails = furi_hal_rtc_get_pin_fails() + 1;
         if(pin_fails >= 10 && momentum_settings.bad_pins_format) {
             Storage* storage = furi_record_open(RECORD_STORAGE);
-            storage_sd_format(storage);
+            storage_sd_format(storage, SDFormatTypeAuto);
             furi_record_close(RECORD_STORAGE);
             furi_hal_rtc_reset_registers();
             Power* power = furi_record_open(RECORD_POWER);
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..1e346e8409025262996bf66bc86a16a70b42fa4e
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -108,6 +108,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +134,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..cef306a1092f899c3b13662d7a24151649538fd8
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,54 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
-    DialogEx* dialog_ex = app->dialog_ex;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
 
-    FS_Error sd_status = storage_sd_status(app->fs_api);
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
+    DialogEx* dialog_ex = app->dialog_ex;
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_icon(dialog_ex, 0, 0, NULL);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +70,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Considering header inclusion for storage_message.h**
file update
M /Users/x/x/Momentum-Firmware/applications/services/storage/storage_message.h
@@ -3,2 +3,3 @@
 #include <toolbox/api_lock.h>
+#include "storage_sd_api.h"
 
apply_patch(auto_approved=true) exited 0 in 146ms:
Success. Updated the following files:
M applications/services/storage/storage_message.h
file update:
diff --git a/applications/services/desktop/scenes/desktop_scene_pin_input.c b/applications/services/desktop/scenes/desktop_scene_pin_input.c
index a7a05667fb64a24681da3e2d543eb3caf5826c5d..2533a8baac330312be00081d2bddc0cf10d9a02b
--- a/applications/services/desktop/scenes/desktop_scene_pin_input.c
+++ b/applications/services/desktop/scenes/desktop_scene_pin_input.c
@@ -5,6 +5,7 @@
 #include <stdint.h>
 #include <notification/notification.h>
 #include <notification/notification_messages.h>
+#include <storage/storage.h>
 #include <momentum/momentum.h>
 
 #include "../desktop.h"
@@ -60,7 +61,7 @@
         uint32_t pin_fails = furi_hal_rtc_get_pin_fails() + 1;
         if(pin_fails >= 10 && momentum_settings.bad_pins_format) {
             Storage* storage = furi_record_open(RECORD_STORAGE);
-            storage_sd_format(storage);
+            storage_sd_format(storage, SDFormatTypeAuto);
             furi_record_close(RECORD_STORAGE);
             furi_hal_rtc_reset_registers();
             Power* power = furi_record_open(RECORD_POWER);
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..f972ab908f022f18da82bf395233f24630973087
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -1,6 +1,7 @@
 #pragma once
 #include <furi.h>
 #include <toolbox/api_lock.h>
+#include "storage_sd_api.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -108,6 +109,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +135,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..cef306a1092f899c3b13662d7a24151649538fd8
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,54 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
-    DialogEx* dialog_ex = app->dialog_ex;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
 
-    FS_Error sd_status = storage_sd_status(app->fs_api);
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
+    DialogEx* dialog_ex = app->dialog_ex;
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_icon(dialog_ex, 0, 0, NULL);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +70,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;

file update:
diff --git a/applications/services/desktop/scenes/desktop_scene_pin_input.c b/applications/services/desktop/scenes/desktop_scene_pin_input.c
index a7a05667fb64a24681da3e2d543eb3caf5826c5d..2533a8baac330312be00081d2bddc0cf10d9a02b
--- a/applications/services/desktop/scenes/desktop_scene_pin_input.c
+++ b/applications/services/desktop/scenes/desktop_scene_pin_input.c
@@ -5,6 +5,7 @@
 #include <stdint.h>
 #include <notification/notification.h>
 #include <notification/notification_messages.h>
+#include <storage/storage.h>
 #include <momentum/momentum.h>
 
 #include "../desktop.h"
@@ -60,7 +61,7 @@
         uint32_t pin_fails = furi_hal_rtc_get_pin_fails() + 1;
         if(pin_fails >= 10 && momentum_settings.bad_pins_format) {
             Storage* storage = furi_record_open(RECORD_STORAGE);
-            storage_sd_format(storage);
+            storage_sd_format(storage, SDFormatTypeAuto);
             furi_record_close(RECORD_STORAGE);
             furi_hal_rtc_reset_registers();
             Power* power = furi_record_open(RECORD_POWER);
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..f972ab908f022f18da82bf395233f24630973087
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -1,6 +1,7 @@
 #pragma once
 #include <furi.h>
 #include <toolbox/api_lock.h>
+#include "storage_sd_api.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -108,6 +109,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +135,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..9acf9d585f7c0c753acd7d91e84b9fe63fe3200a
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,7 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..cef306a1092f899c3b13662d7a24151649538fd8
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,54 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
-    DialogEx* dialog_ex = app->dialog_ex;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
 
-    FS_Error sd_status = storage_sd_status(app->fs_api);
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
+    DialogEx* dialog_ex = app->dialog_ex;
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_icon(dialog_ex, 0, 0, NULL);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +70,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;


thinking
**Planning storage format type updates**
file update
M /Users/x/x/Momentum-Firmware/applications/services/storage/storages/storage_ext.c
@@ -230,3 +230,4 @@
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
+    error = f_mkfs(
+        sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
apply_patch(auto_approved=true) exited 0 in 141ms:
Success. Updated the following files:
M applications/services/storage/storages/storage_ext.c
file update:
diff --git a/applications/services/desktop/scenes/desktop_scene_pin_input.c b/applications/services/desktop/scenes/desktop_scene_pin_input.c
index a7a05667fb64a24681da3e2d543eb3caf5826c5d..2533a8baac330312be00081d2bddc0cf10d9a02b
--- a/applications/services/desktop/scenes/desktop_scene_pin_input.c
+++ b/applications/services/desktop/scenes/desktop_scene_pin_input.c
@@ -5,6 +5,7 @@
 #include <stdint.h>
 #include <notification/notification.h>
 #include <notification/notification_messages.h>
+#include <storage/storage.h>
 #include <momentum/momentum.h>
 
 #include "../desktop.h"
@@ -60,7 +61,7 @@
         uint32_t pin_fails = furi_hal_rtc_get_pin_fails() + 1;
         if(pin_fails >= 10 && momentum_settings.bad_pins_format) {
             Storage* storage = furi_record_open(RECORD_STORAGE);
-            storage_sd_format(storage);
+            storage_sd_format(storage, SDFormatTypeAuto);
             furi_record_close(RECORD_STORAGE);
             furi_hal_rtc_reset_registers();
             Power* power = furi_record_open(RECORD_POWER);
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..f972ab908f022f18da82bf395233f24630973087
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -1,6 +1,7 @@
 #pragma once
 #include <furi.h>
 #include <toolbox/api_lock.h>
+#include "storage_sd_api.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -108,6 +109,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +135,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..e1556f3425a1832e508e3a1d021ae40c4e756efc
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,8 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(
+        sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..cef306a1092f899c3b13662d7a24151649538fd8
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,54 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
-    DialogEx* dialog_ex = app->dialog_ex;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
 
-    FS_Error sd_status = storage_sd_status(app->fs_api);
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
+    DialogEx* dialog_ex = app->dialog_ex;
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_icon(dialog_ex, 0, 0, NULL);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +70,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;

file update:
diff --git a/applications/services/desktop/scenes/desktop_scene_pin_input.c b/applications/services/desktop/scenes/desktop_scene_pin_input.c
index a7a05667fb64a24681da3e2d543eb3caf5826c5d..2533a8baac330312be00081d2bddc0cf10d9a02b
--- a/applications/services/desktop/scenes/desktop_scene_pin_input.c
+++ b/applications/services/desktop/scenes/desktop_scene_pin_input.c
@@ -5,6 +5,7 @@
 #include <stdint.h>
 #include <notification/notification.h>
 #include <notification/notification_messages.h>
+#include <storage/storage.h>
 #include <momentum/momentum.h>
 
 #include "../desktop.h"
@@ -60,7 +61,7 @@
         uint32_t pin_fails = furi_hal_rtc_get_pin_fails() + 1;
         if(pin_fails >= 10 && momentum_settings.bad_pins_format) {
             Storage* storage = furi_record_open(RECORD_STORAGE);
-            storage_sd_format(storage);
+            storage_sd_format(storage, SDFormatTypeAuto);
             furi_record_close(RECORD_STORAGE);
             furi_hal_rtc_reset_registers();
             Power* power = furi_record_open(RECORD_POWER);
diff --git a/applications/services/loader/loader_menu_storage.c b/applications/services/loader/loader_menu_storage.c
index 755ee12430af40ce7c3eb2e55137149aa1f83c3f..d4ba7bc5e15457bfe7a67878cea02414fb73a935
--- a/applications/services/loader/loader_menu_storage.c
+++ b/applications/services/loader/loader_menu_storage.c
@@ -78,7 +78,7 @@
                     dialog_ex_set_left_button_text(dialog_ex, NULL);
                     dialog_ex_set_right_button_text(dialog_ex, NULL);
 
-                    FS_Error error = storage_sd_format(storage);
+                    FS_Error error = storage_sd_format(storage, SDFormatTypeAuto);
                     if(error != FSE_OK) {
                         dialog_ex_set_header(
                             dialog_ex, "Cannot Format SD Card", 64, 10, AlignCenter, AlignCenter);
diff --git a/applications/services/storage/storage.h b/applications/services/storage/storage.h
index 4bb064b761856067f0d2012c0b690e9f0ca20903..2e0c98f80ad1b3f2db02bd47582ab13eaecfd03e
--- a/applications/services/storage/storage.h
+++ b/applications/services/storage/storage.h
@@ -516,9 +516,10 @@
  * @brief Format the SD Card.
  *
  * @param storage pointer to a storage API instance.
+ * @param format_type filesystem type to use for formatting.
  * @return FSE_OK if the card was successfully formatted, any other error code on failure.
  */
-FS_Error storage_sd_format(Storage* storage);
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type);
 
 /**
  * @brief Unmount the SD card.
diff --git a/applications/services/storage/storage_cli.c b/applications/services/storage/storage_cli.c
index 21bb3153bccdfbd27b783783d1d9e804b433376a..e4185cd450774ddeac1fa5f627244bc4dffc1287
--- a/applications/services/storage/storage_cli.c
+++ b/applications/services/storage/storage_cli.c
@@ -84,7 +84,7 @@
             Storage* api = furi_record_open(RECORD_STORAGE);
             printf("Formatting, please wait...\r\n");
 
-            FS_Error error = storage_sd_format(api);
+            FS_Error error = storage_sd_format(api, SDFormatTypeAuto);
 
             if(error != FSE_OK) {
                 storage_cli_print_error(error);
diff --git a/applications/services/storage/storage_external_api.c b/applications/services/storage/storage_external_api.c
index 7cfb70ad0a8db7c5e64170d9d8f977df9c5ccbc4..83d83c0e40001ce4309c132149b73637a9525ce4
--- a/applications/services/storage/storage_external_api.c
+++ b/applications/services/storage/storage_external_api.c
@@ -1054,11 +1054,14 @@
 
 /****************** Raw SD API ******************/
 
-FS_Error storage_sd_format(Storage* storage) {
+FS_Error storage_sd_format(Storage* storage, SDFormatType format_type) {
     furi_check(storage);
 
     S_API_PROLOGUE;
-    SAData data = {};
+    SAData data = {
+        .sdformat = {
+            .format_type = format_type,
+        }};
     S_API_MESSAGE(StorageCommandSDFormat);
     S_API_EPILOGUE;
     return S_RETURN_ERROR;
diff --git a/applications/services/storage/storage_message.h b/applications/services/storage/storage_message.h
index cbd0951443170ab0411a4040706777d86a4f6947..f972ab908f022f18da82bf395233f24630973087
--- a/applications/services/storage/storage_message.h
+++ b/applications/services/storage/storage_message.h
@@ -1,6 +1,7 @@
 #pragma once
 #include <furi.h>
 #include <toolbox/api_lock.h>
+#include "storage_sd_api.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -108,6 +109,10 @@
     File* image;
 } SAVirtualInit;
 
+typedef struct {
+    SDFormatType format_type;
+} SASDFormat;
+
 typedef union {
     SADataFOpen fopen;
     SADataFRead fread;
@@ -130,6 +135,7 @@
     SADataPath path;
     SADataRename rename;
 
+    SASDFormat sdformat;
     SAInfo sdinfo;
 
     SAVirtualInit virtualinit;
diff --git a/applications/services/storage/storage_processing.c b/applications/services/storage/storage_processing.c
index 642d986a4c207672fe4a855dd1eedd5f2422982c..b095e3983a43da51ae980e3f1eb08d40fda3afad
--- a/applications/services/storage/storage_processing.c
+++ b/applications/services/storage/storage_processing.c
@@ -479,13 +479,13 @@
 // TODO FL-3521: think about implementing a custom storage API to split that kind of api linkage
 #include "storages/storage_ext.h"
 
-static FS_Error storage_process_sd_format(Storage* app) {
+static FS_Error storage_process_sd_format(Storage* app, SDFormatType format_type) {
     FS_Error ret = FSE_OK;
 
     if(storage_data_status(&app->storage[ST_EXT]) == StorageStatusNotReady) {
         ret = FSE_NOT_READY;
     } else {
-        ret = sd_format_card(&app->storage[ST_EXT]);
+        ret = sd_format_card(&app->storage[ST_EXT], format_type);
         storage_data_timestamp(&app->storage[ST_EXT]);
     }
 
@@ -785,7 +785,8 @@
 
     // SD operations
     case StorageCommandSDFormat:
-        message->return_data->error_value = storage_process_sd_format(app);
+        message->return_data->error_value =
+            storage_process_sd_format(app, message->data->sdformat.format_type);
         break;
     case StorageCommandSDUnmount:
         message->return_data->error_value = storage_process_sd_unmount(app);
diff --git a/applications/services/storage/storage_sd_api.h b/applications/services/storage/storage_sd_api.h
index 842334d50db797d17d6020bd71bd4ae2af83b7b1..0949a97f7fb6cd36601cc6bbe0984c6d86109d84
--- a/applications/services/storage/storage_sd_api.h
+++ b/applications/services/storage/storage_sd_api.h
@@ -16,6 +16,12 @@
     FST_EXFAT,
 } SDFsType;
 
+typedef enum {
+    SDFormatTypeAuto,
+    SDFormatTypeFAT32,
+    SDFormatTypeExFAT,
+} SDFormatType;
+
 typedef struct {
     SDFsType fs_type;
     uint32_t kb_total;
diff --git a/applications/services/storage/storages/storage_ext.c b/applications/services/storage/storages/storage_ext.c
index d8bd4b12fd12cf4553ddc7bf76689a84f56d7062..e1556f3425a1832e508e3a1d021ae40c4e756efc
--- a/applications/services/storage/storages/storage_ext.c
+++ b/applications/services/storage/storages/storage_ext.c
@@ -205,9 +205,22 @@
     return error;
 }
 
-FS_Error sd_format_card(StorageData* storage) {
+static BYTE sd_format_type_to_mkfs_option(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return FM_FAT32;
+    case SDFormatTypeExFAT:
+        return FM_EXFAT;
+    case SDFormatTypeAuto:
+    default:
+        return FM_ANY;
+    }
+}
+
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type) {
 #ifdef FURI_RAM_EXEC
     UNUSED(storage);
+    UNUSED(format_type);
     return FSE_NOT_READY;
 #else
     uint8_t* work_area;
@@ -215,7 +228,8 @@
     SDError error;
 
     work_area = malloc(_MAX_SS);
-    error = f_mkfs(sd_data->path, FM_ANY, 0, work_area, _MAX_SS);
+    error = f_mkfs(
+        sd_data->path, sd_format_type_to_mkfs_option(format_type), 0, work_area, _MAX_SS);
     free(work_area);
 
     do {
diff --git a/applications/services/storage/storages/storage_ext.h b/applications/services/storage/storages/storage_ext.h
index dc5c40bcc19e4cd9218a120c6c8ea0cddc137778..a262c531de77a7330c07c7de922fed53773e9cec
--- a/applications/services/storage/storages/storage_ext.h
+++ b/applications/services/storage/storages/storage_ext.h
@@ -10,7 +10,7 @@
 void storage_ext_init(StorageData* storage);
 FS_Error sd_mount_card(StorageData* storage, bool notify);
 FS_Error sd_unmount_card(StorageData* storage);
-FS_Error sd_format_card(StorageData* storage);
+FS_Error sd_format_card(StorageData* storage, SDFormatType format_type);
 FS_Error sd_card_info(StorageData* storage, SDInfo* sd_info);
 
 void storage_mnt_init(StorageData* storage);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
index c79647ad2a7706e50f2dff838faa1cbd8c97aa28..cef306a1092f899c3b13662d7a24151649538fd8
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_format_confirm.c
@@ -1,4 +1,5 @@
 #include "../storage_settings.h"
+#include <stdio.h>
 
 static void
     storage_settings_scene_format_confirm_dialog_callback(DialogExResult result, void* context) {
@@ -7,25 +8,54 @@
     view_dispatcher_send_custom_event(app->view_dispatcher, result);
 }
 
-void storage_settings_scene_format_confirm_on_enter(void* context) {
-    StorageSettings* app = context;
-    DialogEx* dialog_ex = app->dialog_ex;
+static const char* storage_settings_format_type_to_text(SDFormatType format_type) {
+    switch(format_type) {
+    case SDFormatTypeFAT32:
+        return "FAT32";
+    case SDFormatTypeExFAT:
+        return "exFAT";
+    case SDFormatTypeAuto:
+    default:
+        return "Auto";
+    }
+}
 
-    FS_Error sd_status = storage_sd_status(app->fs_api);
+static void storage_settings_scene_format_confirm_update_dialog(
+    StorageSettings* app,
+    FS_Error sd_status) {
+    DialogEx* dialog_ex = app->dialog_ex;
 
     if(sd_status == FSE_NOT_READY) {
         dialog_ex_set_icon(dialog_ex, 83, 22, &I_WarningDolphinFlip_45x42);
         dialog_ex_set_header(dialog_ex, "SD Card Not Mounted", 64, 3, AlignCenter, AlignTop);
         dialog_ex_set_text(
             dialog_ex, "Try to reinsert\nor format SD\ncard.", 3, 19, AlignLeft, AlignTop);
+        dialog_ex_set_left_button_text(dialog_ex, NULL);
         dialog_ex_set_center_button_text(dialog_ex, "Ok");
+        dialog_ex_set_right_button_text(dialog_ex, NULL);
     } else {
+        char text[48];
+        snprintf(
+            text,
+            sizeof(text),
+            "All data will be lost!\nFilesystem: %s",
+            storage_settings_format_type_to_text(app->format_type));
         dialog_ex_set_header(dialog_ex, "Format SD Card?", 64, 0, AlignCenter, AlignTop);
-        dialog_ex_set_text(dialog_ex, "All data will be lost!", 64, 12, AlignCenter, AlignTop);
+        dialog_ex_set_icon(dialog_ex, 0, 0, NULL);
+        dialog_ex_set_text(dialog_ex, text, 64, 12, AlignCenter, AlignTop);
         dialog_ex_set_left_button_text(dialog_ex, "Cancel");
+        dialog_ex_set_center_button_text(dialog_ex, "Type");
         dialog_ex_set_right_button_text(dialog_ex, "Format");
     }
+}
 
+void storage_settings_scene_format_confirm_on_enter(void* context) {
+    StorageSettings* app = context;
+    DialogEx* dialog_ex = app->dialog_ex;
+    FS_Error sd_status = storage_sd_status(app->fs_api);
+
+    storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+
     dialog_ex_set_context(dialog_ex, app);
     dialog_ex_set_result_callback(
         dialog_ex, storage_settings_scene_format_confirm_dialog_callback);
@@ -40,9 +70,32 @@
     if(event.type == SceneManagerEventTypeCustom) {
         switch(event.event) {
         case DialogExResultLeft:
-        case DialogExResultCenter:
             consumed = scene_manager_previous_scene(app->scene_manager);
             break;
+        case DialogExResultCenter: {
+            FS_Error sd_status = storage_sd_status(app->fs_api);
+            if(sd_status == FSE_NOT_READY) {
+                consumed = scene_manager_previous_scene(app->scene_manager);
+                break;
+            }
+
+            switch(app->format_type) {
+            case SDFormatTypeAuto:
+                app->format_type = SDFormatTypeFAT32;
+                break;
+            case SDFormatTypeFAT32:
+                app->format_type = SDFormatTypeExFAT;
+                break;
+            case SDFormatTypeExFAT:
+            default:
+                app->format_type = SDFormatTypeAuto;
+                break;
+            }
+
+            storage_settings_scene_format_confirm_update_dialog(app, sd_status);
+            consumed = true;
+            break;
+        }
         case DialogExResultRight:
             scene_manager_set_scene_state(app->scene_manager, StorageSettingsFormatting, false);
             scene_manager_next_scene(app->scene_manager, StorageSettingsFormatting);
diff --git a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
index d1652fa20749a2275a2f103aad1137e1f08f5af6..7c9cb2c47f2a56b8180ccd587fa8d5865c1a460a
--- a/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
+++ b/applications/settings/storage_settings/scenes/storage_settings_scene_formatting.c
@@ -39,7 +39,7 @@
     view_dispatcher_switch_to_view(app->view_dispatcher, StorageSettingsViewDialogEx);
 
     notification_message_block(app->notification, &sequence_set_formatting_leds);
-    error = storage_sd_format(app->fs_api);
+    error = storage_sd_format(app->fs_api, app->format_type);
     notification_message(app->notification, &sequence_reset_formatting_leds);
     notification_message(app->notification, &sequence_blink_green_100);
 
diff --git a/applications/settings/storage_settings/storage_settings.c b/applications/settings/storage_settings/storage_settings.c
index 3808c42e284d64f752ad58dcd4b0fc9a949152bc..d98ea48189b24a9c09846078c86903c408d22121
--- a/applications/settings/storage_settings/storage_settings.c
+++ b/applications/settings/storage_settings/storage_settings.c
@@ -33,6 +33,7 @@
     app->gui = furi_record_open(RECORD_GUI);
     app->fs_api = furi_record_open(RECORD_STORAGE);
     app->notification = furi_record_open(RECORD_NOTIFICATION);
+    app->format_type = SDFormatTypeAuto;
 
     app->view_dispatcher = view_dispatcher_alloc();
     app->scene_manager = scene_manager_alloc(&storage_settings_scene_handlers, app);
diff --git a/applications/settings/storage_settings/storage_settings.h b/applications/settings/storage_settings/storage_settings.h
index 5f4c6404ee04190e4f8a278fad6c5f87e998484d..f14709e18200513eb89c1b803e3f7d87e148b04c
--- a/applications/settings/storage_settings/storage_settings.h
+++ b/applications/settings/storage_settings/storage_settings.h
@@ -29,6 +29,7 @@
     Gui* gui;
     NotificationApp* notification;
     Storage* fs_api;
+    SDFormatType format_type;
 
     // view management
     SceneManager* scene_manager;

