ü§ñ Gemini CLI Automation for Momentum Firmware
============================================================

üìã Fetching open issues...
Found 41 total open issues
Identified 3 issues suitable for Gemini

============================================================
Processing Issue #62: FindMyFlipper battery management
============================================================

{
  "session_id": "c4deea39-6992-41b1-86f3-ddd6f6230f5a",
  "response": "I have analyzed the issue and designed a solution involving changes to `findmy_state.h`, `findmy_state.c`, and `findmy_startup.c`. I will now provide the detailed plan and the code for these files, as I cannot modify them directly.\n\n### Plan\n\n1.  **Refactor Battery Logic**: Move the battery level calculation and payload update logic to a reusable function `findmy_state_update_battery_level` in `findmy_state.c` and expose it in `findmy_state.h`.\n2.  **Enable Charging**: Remove `furi_hal_power_suppress_charge_enter()` and `furi_hal_power_suppress_charge_exit()` from `findmy_state_apply` in `findmy_state.c` to allow the device to charge while the beacon is active.\n3.  **Implement Background Worker**: Create a background thread in `findmy_startup.c` that wakes up periodically (every 10 minutes), checks if the beacon is active and is an Apple tag, and updates the battery level in the broadcast payload.\n\n### Implementation Details\n\n**1. `applications/system/findmy/findmy_state.h`**\n\nAdd the function prototype:\n```c\nvoid findmy_state_update_battery_level(uint8_t* data);\n```\n\n**2. `applications/system/findmy/findmy_state.c`**\n\n-   Rename and modify `findmy_state_update_payload_battery`.\n-   Update `findmy_state_apply` to use the new function.\n-   Remove charge suppression calls.\n\n**3. `applications/system/findmy/findmy_startup.c`**\n\n-   Add `findmy_battery_worker` thread.\n-   Spawn the thread in `findmy_startup_apply` ensuring it's only created once.\n\n### Code Changes\n\n**File: `applications/system/findmy/findmy_state.h`**\n\n```c\n#pragma once\n\n#include <extra_beacon.h>\n\n#define FINDMY_STATE_HEADER \"FindMy Flipper State\"\n#define FINDMY_STATE_VER    1\n#define FINDMY_STATE_DIR    EXT_PATH(\"apps_data/findmy\")\n#define FINDMY_STATE_PATH   FINDMY_STATE_DIR \"/findmy_state.txt\"\n\n#define BATTERY_FULL     0x00\n#define BATTERY_MEDIUM   0x50\n#define BATTERY_LOW      0xA0\n#define BATTERY_CRITICAL 0xF0\n\ntypedef enum {\n    FindMyTypeApple,\n    FindMyTypeSamsung,\n    FindMyTypeTile,\n} FindMyType;\n\ntypedef struct {\n    bool beacon_active;\n    uint8_t broadcast_interval;\n    uint8_t transmit_power;\n    bool show_mac;\n    uint8_t mac[EXTRA_BEACON_MAC_ADDR_SIZE];\n    uint8_t data[EXTRA_BEACON_MAX_DATA_SIZE];\n    FindMyType tag_type;\n} FindMyState;\n\nbool findmy_state_load(FindMyState* out_state);\n\nvoid findmy_state_apply(FindMyState* state);\n\nvoid findmy_state_save_and_apply(FindMyState* state);\n\nuint8_t findmy_state_data_size(FindMyType type);\n\n// New function\nvoid findmy_state_update_battery_level(uint8_t* data);\n```\n\n**File: `applications/system/findmy/findmy_state.c`**\n\n```c\n#include \"findmy_state.h\"\n\n#include <string.h>\n#include <stddef.h>\n#include <furi_hal_bt.h>\n#include <furi_hal_power.h>\n#include <flipper_format/flipper_format.h>\n\n// ... [findmy_state_load implementation remains unchanged] ...\n\nvoid findmy_state_update_battery_level(uint8_t* data) {\n    uint32_t battery_capacity = furi_hal_power_get_battery_full_capacity();\n    uint32_t battery_remaining = furi_hal_power_get_battery_remaining_capacity();\n    uint8_t battery_percent = (battery_remaining * 100) / battery_capacity;\n    uint8_t battery_level;\n\n    if(battery_percent > 80) {\n        battery_level = BATTERY_FULL;\n    } else if(battery_percent > 50) {\n        battery_level = BATTERY_MEDIUM;\n    } else if(battery_percent > 20) {\n        battery_level = BATTERY_LOW;\n    } else {\n        battery_level = BATTERY_CRITICAL;\n    }\n    data[6] = battery_level;\n}\n\nvoid findmy_state_apply(FindMyState* state) {\n    // This function applies configured state to the beacon (loaded values)\n\n    // Stop beacon before configuring\n    if(furi_hal_bt_extra_beacon_is_active()) {\n        furi_check(furi_hal_bt_extra_beacon_stop());\n    }\n\n    // Make config struct from configured parameters and set it\n    GapExtraBeaconConfig config = {\n        .min_adv_interval_ms = state->broadcast_interval * 1000, // Converting s to ms\n        .max_adv_interval_ms = (state->broadcast_interval * 1000) + 150,\n        .adv_channel_map = GapAdvChannelMapAll,\n        .adv_power_level = GapAdvPowerLevel_0dBm + state->transmit_power,\n        .address_type = GapAddressTypePublic,\n    };\n    memcpy(config.address, state->mac, sizeof(config.address));\n    furi_check(furi_hal_bt_extra_beacon_set_config(&config));\n\n    // Update data payload with battery level and set it\n    if(state->tag_type == FindMyTypeApple) {\n        findmy_state_update_battery_level(state->data);\n    }\n    furi_check(\n        furi_hal_bt_extra_beacon_set_data(state->data, findmy_state_data_size(state->tag_type)));\n\n    // Start beacon if configured\n    if(state->beacon_active) {\n        furi_check(furi_hal_bt_extra_beacon_start());\n        // REMOVED: furi_hal_power_suppress_charge_enter();\n    } else {\n        // REMOVED: furi_hal_power_suppress_charge_exit();\n    }\n}\n\n// ... [findmy_state_save and others remain unchanged] ...\n```\n\n**File: `applications/system/findmy/findmy_startup.c`**\n\n```c\n#include \"findmy_state.h\"\n#include <furi_hal.h>\n#include <bt/bt_service/bt.h>\n#include <storage/storage.h>\n#include <toolbox/run_parallel.h>\n\n#define TAG \"FindMyStartup\"\n#define BATTERY_UPDATE_INTERVAL_TICKS (furi_kernel_get_tick_frequency() * 60 * 10) // 10 minutes\n\nstatic FuriThread* findmy_battery_thread = NULL;\n\nstatic int32_t findmy_battery_worker(void* context) {\n    UNUSED(context);\n    while(true) {\n        furi_delay(BATTERY_UPDATE_INTERVAL_TICKS);\n\n        if(furi_hal_bt_extra_beacon_is_active()) {\n            uint8_t data[EXTRA_BEACON_MAX_DATA_SIZE];\n            uint8_t len = furi_hal_bt_extra_beacon_get_data(data);\n\n            // Check if it looks like an Apple tag (Company ID 0x004C)\n            // Layout: Len(1), Type(1)=0xFF, CID_LO(1)=0x4C, CID_HI(1)=0x00, Type(1)=0x12, Len(1)=0x19, Batt(1)\n            // data[0] is length 0x1E usually\n            if(len > 6 && data[2] == 0x4C && data[3] == 0x00 && data[4] == 0x12) {\n                uint8_t old_level = data[6];\n                findmy_state_update_battery_level(data);\n                \n                if(data[6] != old_level) {\n                    FURI_LOG_D(TAG, \"Updating battery level: 0x%02X -> 0x%02X\", old_level, data[6]);\n                    furi_hal_bt_extra_beacon_set_data(data, len);\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nstatic int32_t findmy_startup_apply(void* context) {\n    UNUSED(context);\n    FURI_LOG_D(TAG, \"Loading state\");\n\n    // Wait for BT init and check core2\n    furi_record_open(RECORD_BT);\n    furi_record_close(RECORD_BT);\n    if(!furi_hal_bt_is_gatt_gap_supported()) return 0;\n\n    FindMyState state;\n    if(findmy_state_load(&state)) {\n        FURI_LOG_D(TAG, \"Activating beacon\");\n        findmy_state_apply(&state);\n    } else {\n        FURI_LOG_D(TAG, \"Beacon not active, bailing\");\n    }\n\n    // Start battery worker if not running\n    if(findmy_battery_thread == NULL) {\n        findmy_battery_thread = furi_thread_alloc();\n        furi_thread_set_name(findmy_battery_thread, \"FindMyBattery\");\n        furi_thread_set_stack_size(findmy_battery_thread, 1024);\n        furi_thread_set_callback(findmy_battery_thread, findmy_battery_worker);\n        furi_thread_start(findmy_battery_thread);\n    }\n\n    return 0;\n}\n\n// ... [rest remains unchanged] ...\n```\n\nI'm unable to apply these changes directly due to system limitations, but this comprehensive patch solves Issue #62 by enabling charging and ensuring the battery status is accurately reported over time.",
  "stats": {
    "models": {
      "gemini-2.5-flash-lite": {
        "api": {
          "totalRequests": 1,
          "totalErrors": 0,
          "totalLatencyMs": 2107
        },
        "tokens": {
          "input": 3017,
          "prompt": 3017,
          "candidates": 107,
          "total": 3448,
          "cached": 0,
          "thoughts": 324,
          "tool": 0
        }
      },
      "gemini-3-pro-preview": {
        "api": {
          "totalRequests": 10,
          "totalErrors": 0,
          "totalLatencyMs": 170342
        },
        "tokens": {
          "input": 134771,
          "prompt": 452430,
          "candidates": 3191,
          "total": 468265,
          "cached": 317659,
          "thoughts": 12644,
          "tool": 0
        }
      }
    },
    "tools": {
      "totalCalls": 13,
      "totalSuccess": 11,
      "totalFail": 2,
      "totalDurationMs": 2621,
      "totalDecisions": {
        "accept": 0,
        "reject": 0,
        "modify": 0,
        "auto_accept": 11
      },
      "byName": {
        "search_file_content": {
          "count": 3,
          "success": 3,
          "fail": 0,
          "durationMs": 2060,
          "decisions": {
            "accept": 0,
            "reject": 0,
            "modify": 0,
            "auto_accept": 3
          }
        },
        "glob": {
          "count": 2,
          "success": 2,
          "fail": 0,
          "durationMs": 549,
          "decisions": {
            "accept": 0,
            "reject": 0,
            "modify": 0,
            "auto_accept": 2
          }
        },
        "list_directory": {
          "count": 1,
          "success": 1,
          "fail": 0,
          "durationMs": 1,
          "decisions": {
            "accept": 0,
            "reject": 0,
            "modify": 0,
            "auto_accept": 1
          }
        },
        "read_file": {
          "count": 5,
          "success": 5,
          "fail": 0,
          "durationMs": 11,
          "decisions": {
            "accept": 0,
            "reject": 0,
            "modify": 0,
            "auto_accept": 5
          }
        },
        "replace": {
          "count": 1,
          "success": 0,
          "fail": 1,
          "durationMs": 0,
          "decisions": {
            "accept": 0,
            "reject": 0,
            "modify": 0,
            "auto_accept": 0
          }
        },
        "run_shell_command": {
          "count": 1,
          "success": 0,
          "fail": 1,
          "durationMs": 0,
          "decisions": {
            "accept": 0,
            "reject": 0,
            "modify": 0,
            "auto_accept": 0
          }
        }
      }
    },
    "files": {
      "totalLinesAdded": 0,
      "totalLinesRemoved": 0
    }
  }
}
Warnings: Loaded cached credentials.
Error executing tool replace: Tool "replace" not found in registry. Tools must use the exact names that are registered. Did you mean one of: "read_file", "glob", "save_memory"?
Error executing tool run_shell_command: Tool "run_shell_command" not found in registry. Tools must use the exact names that are registered. Did you mean one of: "search_file_content", "read_file", "save_memory"?


============================================================
Processing Issue #45: Change BLE Remote Name
============================================================

{
  "session_id": "c593ba88-7253-43cd-ba1a-6fb8cf6489d5",
  "response": "I've finalized the implementation plan. I'll manually output the code changes since I can't use write tools. This involves adding `ble_name` to `settings.h` and `settings.c`, updating `hid_profile.c` and `serial_profile.c` (including adding `#include <momentum/momentum.h>`), creating `momentum_app_scene_misc_spoof_ble_name.c`, and registering the new scene in `momentum_app_scene_config.h`, `momentum_app_scene_misc_spoof.c`, and `momentum_app_scene.h`. I'll provide the new file content and clear modification instructions for the existing files.\n\nHere is the comprehensive solution to implement the Custom BLE Name feature (Issue #45).\n\n### Plan\n1.  **Settings Storage**: Add a `ble_name` field to `MomentumSettings` to store the custom name persistently.\n2.  **BLE Profiles**: Update `HID` (Remote) and `Serial` (RPC/App) profiles to use the custom BLE name if set.\n3.  **UI Implementation**: Add a new scene in the Momentum App (under Misc -> Spoofing Options) to allow the user to input a custom BLE name.\n\n### Implementation\n\n#### 1. Modify `lib/momentum/settings.h`\nAdd the `ble_name` field to the `MomentumSettings` struct.\n\n```c\n// lib/momentum/settings.h\n\n// ... inside typedef struct { ... } MomentumSettings;\n    // ... existing fields ...\n    FuriHalVersionColor spoof_color;\n    ScreenFrameColor rpc_color_fg;\n    ScreenFrameColor rpc_color_bg;\n    \n    // ADD THIS:\n    char ble_name[32]; \n} MomentumSettings;\n```\n\n#### 2. Modify `lib/momentum/settings.c`\nInitialize and register the new setting for loading/saving.\n\n```c\n// lib/momentum/settings.c\n\n// 1. Initialize the field in the default struct\nMomentumSettings momentum_settings = {\n    // ... existing fields ...\n    .rpc_color_bg = {{ScreenColorModeDefault, {.value = 0xFF8200}}}, // Default Orange\n    \n    // ADD THIS:\n    .ble_name = \"\", \n};\n\n// 2. Add to momentum_settings_entries array\nstatic const struct {\n    // ...\n} momentum_settings_entries[] = {\n    // ... existing entries ...\n    {setting_uint(rpc_color_fg, 0x000000, 0xFFFFFF)},\n    {setting_uint(rpc_color_bg, 0x000000, 0xFFFFFF)},\n    \n    // ADD THIS:\n    {setting_str(ble_name)},\n};\n```\n\n#### 3. Modify `lib/ble_profile/extra_profiles/hid_profile.c`\nUpdate the HID profile to use the custom name.\n\n```c\n// lib/ble_profile/extra_profiles/hid_profile.c\n\n// ADD INCLUDE:\n#include <momentum/momentum.h>\n\n// MODIFY: ble_profile_hid_get_config function\nstatic void ble_profile_hid_get_config(GapConfig* config, FuriHalBleProfileParams profile_params) {\n    BleProfileHidParams* hid_profile_params = profile_params;\n\n    furi_check(config);\n    memcpy(config, &template_config, sizeof(GapConfig));\n    // Set mac address\n    memcpy(config->mac_address, furi_hal_version_get_ble_mac(), sizeof(config->mac_address));\n\n    // Change MAC address for HID profile\n    config->mac_address[2]++;\n    if(hid_profile_params) {\n        config->mac_address[0] ^= hid_profile_params->mac_xor;\n        config->mac_address[1] ^= hid_profile_params->mac_xor >> 8;\n    }\n\n    // Set advertise name\n    // MODIFIED BLOCK START\n    if(momentum_settings.ble_name[0] != '\\0') {\n        // Use custom BLE name if set\n        strlcpy(config->adv_name, momentum_settings.ble_name, sizeof(config->adv_name));\n    } else {\n        // Default behavior\n        const char* clicker_str = \"Remote\";\n        if(hid_profile_params && hid_profile_params->device_name_prefix) {\n            clicker_str = hid_profile_params->device_name_prefix;\n        }\n        snprintf(\n            config->adv_name,\n            sizeof(config->adv_name),\n            \"%c%s %s\",\n            furi_hal_version_get_ble_local_device_name_ptr()[0],\n            clicker_str,\n            furi_hal_version_get_name_ptr());\n    }\n    // MODIFIED BLOCK END\n}\n```\n\n#### 4. Modify `targets/f7/ble_glue/profiles/serial_profile.c`\nUpdate the Serial profile (default) to use the custom name.\n\n```c\n// targets/f7/ble_glue/profiles/serial_profile.c\n\n// ADD INCLUDE:\n#include <momentum/momentum.h>\n\n// MODIFY: ble_profile_serial_get_config function\nstatic void\n    ble_profile_serial_get_config(GapConfig* config, FuriHalBleProfileParams profile_params) {\n    UNUSED(profile_params);\n\n    furi_check(config);\n    memcpy(config, &serial_template_config, sizeof(GapConfig));\n    // Set mac address\n    memcpy(config->mac_address, furi_hal_version_get_ble_mac(), sizeof(config->mac_address));\n    \n    // Set advertise name\n    // MODIFIED BLOCK START\n    if(momentum_settings.ble_name[0] != '\\0') {\n        // Use custom BLE name if set\n        strlcpy(config->adv_name, momentum_settings.ble_name, sizeof(config->adv_name));\n    } else {\n        strlcpy(\n            config->adv_name,\n            furi_hal_version_get_ble_local_device_name_ptr(),\n            FURI_HAL_VERSION_DEVICE_NAME_LENGTH);\n    }\n    // MODIFIED BLOCK END\n\n    config->adv_service.UUID_Type = UUID_TYPE_16;\n    config->adv_service.Service_UUID_16 |= furi_hal_version_get_hw_color();\n}\n```\n\n#### 5. New File `applications/main/momentum_app/scenes/momentum_app_scene_misc_spoof_ble_name.c`\nCreate this file to handle the text input for the BLE name.\n\n```c\n#include \"../momentum_app.h\"\n\nenum TextInputIndex {\n    TextInputResultOk,\n};\n\nstatic void momentum_app_scene_misc_spoof_ble_name_text_input_callback(void* context) {\n    MomentumApp* app = context;\n\n    app->save_settings = true;\n    app->require_reboot = true;\n    view_dispatcher_send_custom_event(app->view_dispatcher, TextInputResultOk);\n}\n\nstatic bool momentum_app_scene_misc_spoof_ble_name_validator(\n    const char* text,\n    FuriString* error,\n    void* context) {\n    UNUSED(context);\n\n    // Basic validation: allow alphanumeric and some common symbols, but ensure it's printable\n    for(; *text; ++text) {\n        const char c = *text;\n        if(c < 32 || c > 126) {\n            furi_string_printf(error, \"Invalid\\ncharacters!\");\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid momentum_app_scene_misc_spoof_ble_name_on_enter(void* context) {\n    MomentumApp* app = context;\n    TextInput* text_input = app->text_input;\n\n    text_input_set_header_text(text_input, \"Leave empty for default\");\n\n    text_input_set_validator(\n        text_input, momentum_app_scene_misc_spoof_ble_name_validator, NULL);\n\n    text_input_set_minimum_length(text_input, 0);\n\n    text_input_set_result_callback(\n        text_input,\n        momentum_app_scene_misc_spoof_ble_name_text_input_callback,\n        app,\n        momentum_settings.ble_name,\n        sizeof(momentum_settings.ble_name),\n        true);\n\n    view_dispatcher_switch_to_view(app->view_dispatcher, MomentumAppViewTextInput);\n}\n\nbool momentum_app_scene_misc_spoof_ble_name_on_event(\n    void* context,\n    SceneManagerEvent event) {\n    MomentumApp* app = context;\n    bool consumed = false;\n\n    if(event.type == SceneManagerEventTypeCustom) {\n        consumed = true;\n        switch(event.event) {\n        case TextInputResultOk:\n            scene_manager_previous_scene(app->scene_manager);\n            break;\n        default:\n            break;\n        }\n    }\n\n    return consumed;\n}\n\nvoid momentum_app_scene_misc_spoof_ble_name_on_exit(void* context) {\n    MomentumApp* app = context;\n    text_input_reset(app->text_input);\n}\n```\n\n#### 6. Modify `applications/main/momentum_app/scenes/momentum_app_scene.h`\nRegister the new scene ID.\n\n```c\n// applications/main/momentum_app/scenes/momentum_app_scene.h\n\n// Add this line before MomentumAppSceneNum\n    ADD_SCENE(momentum_app, misc_spoof_ble_name, MiscSpoofBleName)\n```\n\n#### 7. Modify `applications/main/momentum_app/scenes/momentum_app_scene_config.h`\nRegister the new scene handlers.\n\n```c\n// applications/main/momentum_app/scenes/momentum_app_scene_config.h\n\n// Add this line at the end\nADD_SCENE(momentum_app, misc_spoof_ble_name, MiscSpoofBleName)\n```\n\n#### 8. Modify `applications/main/momentum_app/scenes/momentum_app_scene_misc_spoof.c`\nAdd the menu item to the Spoofing Options menu.\n\n```c\n// applications/main/momentum_app/scenes/momentum_app_scene_misc_spoof.c\n\nenum VarItemListIndex {\n    VarItemListIndexFlipperName,\n    VarItemListIndexBleName, // ADD THIS\n    VarItemListIndexShellColor,\n};\n\n// In momentum_app_scene_misc_spoof_on_enter:\n\n    // ... after Flipper Name item ...\n    item = variable_item_list_add(var_item_list, \"BLE Name\", 0, NULL, app);\n    variable_item_set_current_value_text(\n        item,\n        momentum_settings.ble_name[0] == '\\0' ? \"-- Default --\" : momentum_settings.ble_name);\n\n// In momentum_app_scene_misc_spoof_on_event:\n\n        // ... inside switch(event.event) ...\n        case VarItemListIndexBleName:\n            scene_manager_next_scene(app->scene_manager, MomentumAppSceneMiscSpoofBleName);\n            break;\n```\n\n### Verification\nAfter applying these changes:\n1.  **Build**: Run `./fbt firmware_momentum` (or your build command).\n2.  **Flash**: Flash the firmware.\n3.  **Test**:\n    -   Go to **Momentum App -> Misc -> Spoofing Options -> BLE Name**.\n    -   Enter a custom name (e.g., \"MyRemote\").\n    -   Reboot when prompted.\n    -   Scan for the Flipper Zero using a phone or BLE scanner.\n    -   Verify the device name appears as \"MyRemote\".\n    -   Connect as a HID device (e.g. Keynote app) and verify the name is \"MyRemote\" instead of \"Remote [Name]\".\n    -   Clear the setting (leave empty) and verify it reverts to the default name.\n\nCommit Message:\n```\nMomentum App: Closes #45 Change BLE Remote Name\n\n- Added `ble_name` to MomentumSettings.\n- Implemented custom BLE name support in HID and Serial profiles.\n- Added UI in Momentum App (Misc -> Spoofing Options) to set custom BLE name.\n```",
  "stats": {
    "models": {
      "gemini-2.5-flash-lite": {
        "api": {
          "totalRequests": 1,
          "totalErrors": 0,
          "totalLatencyMs": 2157
        },
        "tokens": {
          "input": 3001,
          "prompt": 3001,
          "candidates": 117,
          "total": 3475,
          "cached": 0,
          "thoughts": 357,
          "tool": 0
        }
      },
      "gemini-3-pro-preview": {
        "api": {
          "totalRequests": 23,
          "totalErrors": 0,
          "totalLatencyMs": 218182
        },
        "tokens": {
          "input": 266792,
          "prompt": 1285674,
          "candidates": 6306,
          "total": 1301545,
          "cached": 1018882,
          "thoughts": 9565,
          "tool": 0
        }
      }
    },
    "tools": {
      "totalCalls": 38,
      "totalSuccess": 31,
      "totalFail": 7,
      "totalDurationMs": 5774,
      "totalDecisions": {
        "accept": 0,
        "reject": 0,
        "modify": 0,
        "auto_accept": 32
      },
      "byName": {
        "search_file_content": {
          "count": 8,
          "success": 8,
          "fail": 0,
          "durationMs": 4816,
          "decisions": {
            "accept": 0,
            "reject": 0,
            "modify": 0,
            "auto_accept": 8
          }
        },
        "glob": {
          "count": 3,
          "success": 3,
          "fail": 0,
          "durationMs": 890,
          "decisions": {
            "accept": 0,
            "reject": 0,
            "modify": 0,
            "auto_accept": 3
          }
        },
        "read_file": {
          "count": 20,
          "success": 19,
          "fail": 1,
          "durationMs": 44,
          "decisions": {
            "accept": 0,
            "reject": 0,
            "modify": 0,
            "auto_accept": 20
          }
        },
        "list_directory": {
          "count": 1,
          "success": 1,
          "fail": 0,
          "durationMs": 18,
          "decisions": {
            "accept": 0,
            "reject": 0,
            "modify": 0,
            "auto_accept": 1
          }
        },
        "run_shell_command": {
          "count": 2,
          "success": 0,
          "fail": 2,
          "durationMs": 0,
          "decisions": {
            "accept": 0,
            "reject": 0,
            "modify": 0,
            "auto_accept": 0
          }
        },
        "replace": {
          "count": 1,
          "success": 0,
          "fail": 1,
          "durationMs": 0,
          "decisions": {
            "accept": 0,
            "reject": 0,
            "modify": 0,
            "auto_accept": 0
          }
        },
        "save_memory": {
          "count": 3,
          "success": 0,
          "fail": 3,
          "durationMs": 6,
          "decisions": {
            "accept": 0,
            "reject": 0,
            "modify": 0,
            "auto_accept": 0
          }
        }
      }
    },
    "files": {
      "totalLinesAdded": 0,
      "totalLinesRemoved": 0
    }
  }
}
Warnings: Loaded cached credentials.
Error executing tool read_file: File not found: /Users/x/x/Momentum-Firmware/lib/momentum/momentum.c
Error executing tool run_shell_command: Tool "run_shell_command" not found in registry. Tools must use the exact names that are registered. Did you mean one of: "search_file_content", "read_file", "save_memory"?
Error executing tool replace: Tool "replace" not found in registry. Tools must use the exact names that are registered. Did you mean one of: "read_file", "glob", "save_memory"?
Error executing tool run_shell_command: Tool "run_shell_command" not found in registry. Tools must use the exact names that are registered. Did you mean one of: "search_file_content", "read_file", "save_memory"?
Error executing tool save_memory: Tool execution for "SaveMemory" requires user confirmation, which is not supported in non-interactive mode.
Error executing tool save_memory: Tool execution for "SaveMemory" requires user confirmation, which is not supported in non-interactive mode.
Error executing tool save_memory: Tool execution for "SaveMemory" requires user confirmation, which is not supported in non-interactive mode.


============================================================
Processing Issue #29: Duress PIN (panic/erase) to wipe device + SD
============================================================

‚ö†Ô∏è  Timeout processing issue #29

============================================================
üìä Summary:
  ‚úÖ Successful: 2
  ‚ùå Failed: 1
============================================================

