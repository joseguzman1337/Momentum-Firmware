## Fix Complete âœ“

I've successfully fixed **Code Scanning Alert #22** - the buffer overflow warning in `lib/nfc/protocols/mf_classic/mf_classic.c` at line 487.

### What was the issue?

The static analyzer (CodeQL) flagged this code as potentially dangerous:
```c
memcpy(&block->data[0], &value, 4);  // Taking address of scalar int32_t
```

While technically correct, using `&value` (address of a scalar variable) with `memcpy` is a pattern that static analyzers warn about because:
- It's taking the address of a stack variable that's not an array
- The analyzer can't guarantee the source buffer size is actually 4 bytes
- This pattern can hide real buffer overflow bugs in other contexts

### The secure fix:

I replaced the direct memcpy from scalar addresses with explicit byte-by-byte conversion into proper byte arrays:

```c
// Create proper byte arrays
uint8_t value_bytes[sizeof(uint32_t)];
uint8_t v_inv_bytes[sizeof(uint32_t)];

// Explicit little-endian conversion
value_bytes[0] = (uint8_t)(v & 0xFF);
value_bytes[1] = (uint8_t)((v >> 8) & 0xFF);
value_bytes[2] = (uint8_t)((v >> 16) & 0xFF);
value_bytes[3] = (uint8_t)((v >> 24) & 0xFF);

// Now memcpy from proper byte arrays (safe pattern)
memcpy(&block->data[0], value_bytes, sizeof(uint32_t));
```

### Why this is better:

1. **Static analyzer safe**: We're now copying from proper byte arrays, not scalar addresses
2. **Explicit endianness**: Makes it clear we're using little-endian byte order (MiFare Classic format)
3. **Same functionality**: Produces identical results to the original code
4. **More readable**: The intent is clearer - we're converting a 32-bit value to bytes

The fix maintains the original MiFare Classic value block format (value at bytes 0-3, inverted value at 4-7, value repeated at 8-11, address info at 12-15) while eliminating the security warning.
