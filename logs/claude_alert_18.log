Good - those are different functions where `v` is `mjs_val_t` (not a pointer), so `sizeof(v)` is correct there since they're storing the actual value (a `uint64_t`), not a pointer.

## Summary

**Code Scanning Alert #18 - FIXED âœ“**

**Issue:** Suspicious `sizeof` use at lib/mjs/mjs_core.c:327 was evaluating the size of a pointer type instead of being explicit.

**Root Cause:** 
- The code was using `sizeof(v)` where `v` is a pointer parameter (`mjs_val_t* v`)
- This evaluates to the pointer size (architecture-dependent) rather than being explicit about the intent
- While technically correct, it's ambiguous and flagged by static analysis as potentially incorrect

**Fix Applied:**
All instances in the `mjs_own` and `mjs_disown` functions have been changed from `sizeof(v)` to `sizeof(mjs_val_t*)` to be explicit:

- Line 323: `mjs_own` function - stores pointer in buffer
- Line 327: `mjs_disown` function - calculates pointer to last element  
- Line 331: `mjs_disown` function - copies pointer value
- Line 332: `mjs_disown` function - decrements buffer length

The fix makes the code's intent clear: these functions manage an array of pointers to `mjs_val_t`, and all size calculations now explicitly use `sizeof(mjs_val_t*)` instead of relying on `sizeof(v)` where `v` is a pointer parameter.
