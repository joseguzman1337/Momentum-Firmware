[{"number":24,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/24","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/24","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/type-confusion","severity":"warning","description":"Type confusion","name":"cpp/type-confusion","tags":["external/cwe/cwe-843","security"],"full_description":"Casting a value to an incompatible type can lead to undefined behavior.","help":"# Type confusion\nCertain casts in C and C++ place no restrictions on the target type. For example, C style casts such as `(MyClass*)p` allows the programmer to cast any pointer `p` to an expression of type `MyClass*`. If the runtime type of `p` turns out to be a type that's incompatible with `MyClass`, this results in undefined behavior.\n\n\n## Recommendation\nIf possible, use `dynamic_cast` to safely cast between polymorphic types. If `dynamic_cast` is not an option, use `static_cast` to restrict the kinds of conversions that the compiler is allowed to perform. If C++ style casts is not an option, carefully check that all casts are safe.\n\n\n## Example\nConsider the following class hierachy where we define a base class `Shape` and two derived classes `Circle` and `Square` that are mutually incompatible:\n\n\n```cpp\nstruct Shape {\n  virtual ~Shape();\n\n  virtual void draw() = 0;\n};\n\nstruct Circle : public Shape {\n  Circle();\n\n  void draw() override {\n    /* ... */\n  }\n\n  int getRadius();\n};\n\nstruct Square : public Shape {\n  Square();\n\n  void draw() override {\n    /* ... */\n  }\n\n  int getLength();\n};\n\n```\nThe following code demonstrates a type confusion vulnerability where the programmer assumes that the runtime type of `p` is always a `Square`. However, if `p` is a `Circle`, the cast will result in undefined behavior.\n\n\n```cpp\nvoid allocate_and_draw_bad() {\n  Shape* shape = new Circle;\n  // ...\n  // BAD: Assumes that shape is always a Square\n  Square* square = static_cast<Square*>(shape);\n  int length = square->getLength();\n}\n```\nThe following code fixes the vulnerability by using `dynamic_cast` to safely cast between polymorphic types. If the cast fails, `dynamic_cast` returns a null pointer, which can be checked for and handled appropriately.\n\n\n```cpp\nvoid allocate_and_draw_good() {\n  Shape* shape = new Circle;\n  // ...\n  // GOOD: Dynamically checks if shape is a Square\n  Square* square = dynamic_cast<Square*>(shape);\n  if(square) {\n    int length = square->getLength();\n  } else {\n    // handle error\n  }\n}\n```\n\n## References\n* Microsoft Learn: [Type conversions and type safety](https://learn.microsoft.com/en-us/cpp/cpp/type-conversions-and-type-safety-modern-cpp).\n* Common Weakness Enumeration: [CWE-843](https://cwe.mitre.org/data/definitions/843.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"Conversion from File to (unnamed class/struct/union) is invalid."},"location":{"path":"lib/toolbox/compress.c","start_line":292,"end_line":292,"start_column":32,"end_column":59},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/24/instances","dismissal_approved_by":null,"assignees":[]},{"number":23,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/23","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/23","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/overflow-buffer","severity":"warning","description":"Call to memory access function may overflow buffer","name":"cpp/overflow-buffer","tags":["external/cwe/cwe-119","external/cwe/cwe-121","external/cwe/cwe-122","external/cwe/cwe-126","security"],"full_description":"Incorrect use of a function that accesses a memory buffer may read or write data past the end of that buffer.","help":"# Call to memory access function may overflow buffer\nThe software uses a function to access a memory buffer in a way that may read or write data past the end of that buffer. This may result in software instability, improper access to or corruption of sensitive information, or code execution by an attacker.\n\n\n## Recommendation\nWhen accessing buffers with functions such as `memcpy`, `memset` or `strncpy`, ensure that the size value for the operation is no greater than the amount of space available in the destination buffer. Failure to do this may permit a buffer overwrite to occur. Also ensure that the size value is no greater than the amount of data in the source buffer, to prevent a buffer overread from occurring.\n\n\n## Example\nIn the following example, `memcpy` is used to fill a buffer with data from a string.\n\n\n```c\nconst char *message = \"Hello\";\nchar password[32];\nchar buffer[256];\n\nmemcpy(buffer, message, 256);\n\n```\nAlthough the size of the operation matches the destination buffer, the source is only 6 bytes long so an overread will occur. This could copy sensitive data from nearby areas of memory (such as the local variable `password` in this example) into the buffer as well, potentially making it visible to an attacker.\n\nTo fix this issue, reduce the size of the `memcpy` to the smaller of the source and destination buffers, `min(256, strlen(message) + 1)`. Alternatively in this case it would be more appropriate to use the `strncpy` function rather than `memcpy`.\n\n\n## References\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-121](https://cwe.mitre.org/data/definitions/121.html).\n* Common Weakness Enumeration: [CWE-122](https://cwe.mitre.org/data/definitions/122.html).\n* Common Weakness Enumeration: [CWE-126](https://cwe.mitre.org/data/definitions/126.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This 'memcpy' operation accesses 4 bytes but the source buffer is only 1 byte."},"location":{"path":"lib/nfc/protocols/mf_classic/mf_classic.c","start_line":489,"end_line":489,"start_column":5,"end_column":11},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/23/instances","dismissal_approved_by":null,"assignees":[]},{"number":22,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/22","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/22","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/overflow-buffer","severity":"warning","description":"Call to memory access function may overflow buffer","name":"cpp/overflow-buffer","tags":["external/cwe/cwe-119","external/cwe/cwe-121","external/cwe/cwe-122","external/cwe/cwe-126","security"],"full_description":"Incorrect use of a function that accesses a memory buffer may read or write data past the end of that buffer.","help":"# Call to memory access function may overflow buffer\nThe software uses a function to access a memory buffer in a way that may read or write data past the end of that buffer. This may result in software instability, improper access to or corruption of sensitive information, or code execution by an attacker.\n\n\n## Recommendation\nWhen accessing buffers with functions such as `memcpy`, `memset` or `strncpy`, ensure that the size value for the operation is no greater than the amount of space available in the destination buffer. Failure to do this may permit a buffer overwrite to occur. Also ensure that the size value is no greater than the amount of data in the source buffer, to prevent a buffer overread from occurring.\n\n\n## Example\nIn the following example, `memcpy` is used to fill a buffer with data from a string.\n\n\n```c\nconst char *message = \"Hello\";\nchar password[32];\nchar buffer[256];\n\nmemcpy(buffer, message, 256);\n\n```\nAlthough the size of the operation matches the destination buffer, the source is only 6 bytes long so an overread will occur. This could copy sensitive data from nearby areas of memory (such as the local variable `password` in this example) into the buffer as well, potentially making it visible to an attacker.\n\nTo fix this issue, reduce the size of the `memcpy` to the smaller of the source and destination buffers, `min(256, strlen(message) + 1)`. Alternatively in this case it would be more appropriate to use the `strncpy` function rather than `memcpy`.\n\n\n## References\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-121](https://cwe.mitre.org/data/definitions/121.html).\n* Common Weakness Enumeration: [CWE-122](https://cwe.mitre.org/data/definitions/122.html).\n* Common Weakness Enumeration: [CWE-126](https://cwe.mitre.org/data/definitions/126.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This 'memcpy' operation accesses 4 bytes but the source buffer is only 1 byte."},"location":{"path":"lib/nfc/protocols/mf_classic/mf_classic.c","start_line":487,"end_line":487,"start_column":5,"end_column":11},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/22/instances","dismissal_approved_by":null,"assignees":[]},{"number":21,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/21","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/21","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/invalid-pointer-deref","severity":"error","description":"Invalid pointer dereference","name":"cpp/invalid-pointer-deref","tags":["external/cwe/cwe-119","external/cwe/cwe-125","external/cwe/cwe-193","external/cwe/cwe-787","reliability","security"],"full_description":"Dereferencing an out-of-bounds pointer is undefined behavior and may lead to security vulnerabilities.","help":"# Invalid pointer dereference\nThe program performs an out-of-bounds read or write operation, which can cause program instability. In addition, attackers may take advantage of the situation, and implement techniques to use this vulnerability to execute arbitrary code.\n\n\n## Recommendation\nEnsure that pointer dereferences are properly guarded to ensure that they cannot be used to read or write past the end of the allocation.\n\n\n## Example\nThe first example allocates a buffer of size `size` and creates a local variable that stores the location that is one byte past the end of the allocation. This local variable is then dereferenced, which results in an out-of-bounds write. The second example subtracts one from the `end` variable before dereferencing it. This subtraction ensures that the write correctly updates the final byte of the allocation.\n\n\n```cpp\nvoid *malloc(unsigned);\nunsigned get_size();\nvoid write_data(const unsigned char*, const unsigned char*);\n\nint main(int argc, char* argv[]) {\n  unsigned size = get_size();\n  \n  {\n    unsigned char *begin = (unsigned char*)malloc(size);\n    if(!begin) return -1;\n\n    unsigned char* end = begin + size;\n    write_data(begin, end);\n    *end = '\\0'; // BAD: Out-of-bounds write\n  }\n\n  {\n    unsigned char *begin = (unsigned char*)malloc(size);\n    if(!begin) return -1;\n\n    unsigned char* end = begin + size;\n    write_data(begin, end);\n    *(end - 1) = '\\0'; // GOOD: writing to the last byte\n  }\n\n}\n```\n\n## References\n* CERT C Coding Standard: [ARR30-C. Do not form or use out-of-bounds pointers or array subscripts](https://wiki.sei.cmu.edu/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts).\n* OWASP: [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow).\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-125](https://cwe.mitre.org/data/definitions/125.html).\n* Common Weakness Enumeration: [CWE-193](https://cwe.mitre.org/data/definitions/193.html).\n* Common Weakness Enumeration: [CWE-787](https://cwe.mitre.org/data/definitions/787.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This write might be out of bounds, as the pointer might be equal to call to malloc + resp_size."},"location":{"path":"applications/main/nfc/nfc_cli.c","start_line":169,"end_line":169,"start_column":13,"end_column":39},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/21/instances","dismissal_approved_by":null,"assignees":[]},{"number":20,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/20","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/20","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/suspicious-sizeof","severity":"warning","description":"Suspicious 'sizeof' use","name":"cpp/suspicious-sizeof","tags":["correctness","external/cwe/cwe-467","reliability","security"],"full_description":"Taking 'sizeof' of an array parameter is often mistakenly thought to yield the size of the underlying array, but it always yields the machine pointer size.","help":"# Suspicious 'sizeof' use\nThis rule finds expressions that take the size of a function parameter of array type. In C, function parameters of array type are treated as if they had the corresponding pointer type, so their size is always the size of the pointer type (typically either four or eight). In particular, one cannot determine the size of a memory buffer passed as a parameter in this way. Using the `sizeof` operator on pointer types will produce unexpected results if the developer intended to get the size of an array instead of the pointer.\n\n\n## Recommendation\nModify the function to take an extra argument indicating the buffer size.\n\n\n## Example\n\n```cpp\nvoid f(char s[]) {\n\tint size = sizeof(s); //wrong: s is now a char*, not an array. \n\t                      //sizeof(s) will evaluate to sizeof(char *)\n}\n\n```\n\n## References\n* Comp.lang.c, Frequently Asked Questions: [Question 6.3: So what is meant by the \"equivalence of pointers and arrays\" in C?](http://c-faq.com/aryptr/aryptrequiv.html).\n* Common Weakness Enumeration: [CWE-467](https://cwe.mitre.org/data/definitions/467.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This evaluates to the size of the pointer type, which may not be what you want."},"location":{"path":"lib/mjs/mjs_core.c","start_line":332,"end_line":332,"start_column":38,"end_column":47},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/20/instances","dismissal_approved_by":null,"assignees":[]},{"number":19,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/19","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/19","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/suspicious-sizeof","severity":"warning","description":"Suspicious 'sizeof' use","name":"cpp/suspicious-sizeof","tags":["correctness","external/cwe/cwe-467","reliability","security"],"full_description":"Taking 'sizeof' of an array parameter is often mistakenly thought to yield the size of the underlying array, but it always yields the machine pointer size.","help":"# Suspicious 'sizeof' use\nThis rule finds expressions that take the size of a function parameter of array type. In C, function parameters of array type are treated as if they had the corresponding pointer type, so their size is always the size of the pointer type (typically either four or eight). In particular, one cannot determine the size of a memory buffer passed as a parameter in this way. Using the `sizeof` operator on pointer types will produce unexpected results if the developer intended to get the size of an array instead of the pointer.\n\n\n## Recommendation\nModify the function to take an extra argument indicating the buffer size.\n\n\n## Example\n\n```cpp\nvoid f(char s[]) {\n\tint size = sizeof(s); //wrong: s is now a char*, not an array. \n\t                      //sizeof(s) will evaluate to sizeof(char *)\n}\n\n```\n\n## References\n* Comp.lang.c, Frequently Asked Questions: [Question 6.3: So what is meant by the \"equivalence of pointers and arrays\" in C?](http://c-faq.com/aryptr/aryptrequiv.html).\n* Common Weakness Enumeration: [CWE-467](https://cwe.mitre.org/data/definitions/467.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This evaluates to the size of the pointer type, which may not be what you want."},"location":{"path":"lib/mjs/mjs_core.c","start_line":331,"end_line":331,"start_column":82,"end_column":91},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/19/instances","dismissal_approved_by":null,"assignees":[]},{"number":18,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/18","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/18","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/suspicious-sizeof","severity":"warning","description":"Suspicious 'sizeof' use","name":"cpp/suspicious-sizeof","tags":["correctness","external/cwe/cwe-467","reliability","security"],"full_description":"Taking 'sizeof' of an array parameter is often mistakenly thought to yield the size of the underlying array, but it always yields the machine pointer size.","help":"# Suspicious 'sizeof' use\nThis rule finds expressions that take the size of a function parameter of array type. In C, function parameters of array type are treated as if they had the corresponding pointer type, so their size is always the size of the pointer type (typically either four or eight). In particular, one cannot determine the size of a memory buffer passed as a parameter in this way. Using the `sizeof` operator on pointer types will produce unexpected results if the developer intended to get the size of an array instead of the pointer.\n\n\n## Recommendation\nModify the function to take an extra argument indicating the buffer size.\n\n\n## Example\n\n```cpp\nvoid f(char s[]) {\n\tint size = sizeof(s); //wrong: s is now a char*, not an array. \n\t                      //sizeof(s) will evaluate to sizeof(char *)\n}\n\n```\n\n## References\n* Comp.lang.c, Frequently Asked Questions: [Question 6.3: So what is meant by the \"equivalence of pointers and arrays\" in C?](http://c-faq.com/aryptr/aryptrequiv.html).\n* Common Weakness Enumeration: [CWE-467](https://cwe.mitre.org/data/definitions/467.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This evaluates to the size of the pointer type, which may not be what you want."},"location":{"path":"lib/mjs/mjs_core.c","start_line":327,"end_line":327,"start_column":84,"end_column":93},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/18/instances","dismissal_approved_by":null,"assignees":[]},{"number":17,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/17","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/17","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/incorrect-not-operator-usage","severity":"warning","description":"Incorrect 'not' operator usage","name":"cpp/incorrect-not-operator-usage","tags":["external/cwe/cwe-480","security"],"full_description":"Usage of a logical-not (!) operator as an operand for a bit-wise operation. This commonly indicates the usage of an incorrect operator instead of the bit-wise not (~) operator, also known as ones' complement operator.","help":"# Incorrect 'not' operator usage\nThis rule finds logical-not operator usage as an operator for in a bit-wise operation.\n\nDue to the nature of logical operation result value, only the lowest bit could possibly be set, and it is unlikely to be intent in bitwise operations. Violations are often indicative of a typo, using a logical-not (`!`) operator instead of the bit-wise not (`~`) operator.\n\nThis rule is restricted to analyze bit-wise and (`&`) and bit-wise or (`|`) operation in order to provide better precision.\n\nThis rule ignores instances where a double negation (`!!`) is explicitly used as the operator of the bitwise operation, as this is a commonly used as a mechanism to normalize an integer value to either 1 or 0.\n\nNOTE: It is not recommended to use this rule in kernel code or older C code as it will likely find several false positive instances.\n\n\n## Recommendation\nCarefully inspect the flagged expressions. Consider the intent in the code logic, and decide whether it is necessary to change the not operator.\n\n\n## Example\nHere is an example of this issue and how it can be fixed:\n\n\n```cpp\n#define FLAGS   0x4004\n\nvoid f_warning(int i)\n{\n    // BAD: the usage of the logical not operator in this case is unlikely to be correct\n    // as the output is being used as an operator for a bit-wise and operation\n    if (i & !FLAGS)\n    {\n        // code\n    }\n}\n\nvoid f_fixed(int i)\n{\n    if (i & ~FLAGS) // GOOD: Changing the logical not operator for the bit-wise not operator would fix this logic\n    {\n        // code\n    }\n}\n\n```\nIn other cases, particularly when the expressions have `bool` type, the fix may instead be of the form `a && !b`.\n\n\n## References\n* [warning C6317: incorrect operator: logical-not (!) is not interchangeable with ones-complement (~)](https://docs.microsoft.com/en-us/visualstudio/code-quality/c6317?view=vs-2017)\n* Common Weakness Enumeration: [CWE-480](https://cwe.mitre.org/data/definitions/480.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"Usage of a logical not (!) expression as a bitwise operator."},"location":{"path":"applications/main/nfc/plugins/supported_cards/charliecard.c","start_line":1162,"end_line":1163,"start_column":12,"end_column":69},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/17/instances","dismissal_approved_by":null,"assignees":[]},{"number":16,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/16","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/16","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/offset-use-before-range-check","severity":"warning","description":"Array offset used before range check","name":"cpp/offset-use-before-range-check","tags":["external/cwe/cwe-120","external/cwe/cwe-125","reliability","security"],"full_description":"Accessing an array offset before checking the range means that the program may attempt to read beyond the end of a buffer","help":"# Array offset used before range check\nThe program contains an and-expression where the array access is defined before the range check. Consequently the array is accessed without any bounds checking. The range check does not protect the program from segmentation faults caused by attempts to read beyond the end of a buffer.\n\n\n## Recommendation\nUpdate the and-expression so that the range check precedes the array offset. This will ensure that the bounds are checked before the array is accessed.\n\n\n## Example\nThe `find` function can read past the end of the buffer pointed to by `str` if `start` is longer than or equal to the length of the buffer (or longer than `len`, depending on the contents of the buffer).\n\n\n```c\nint find(int start, char *str, char goal)\n{\n    int len = strlen(str);\n    //Potential buffer overflow\n    for (int i = start; str[i] != 0 && i < len; i++) { \n        if (str[i] == goal)\n            return i; \n    }\n    return -1;\n}\n\nint findRangeCheck(int start, char *str, char goal)\n{\n    int len = strlen(str);\n    //Range check protects against buffer overflow\n    for (int i = start; i < len && str[i] != 0 ; i++) {\n        if (str[i] == goal)\n            return i; \n    }\n    return -1;\n}\n\n\n\n\n```\nUpdate the and-expression so that the range check precedes the array offset (for example, the `findRangeCheck` function).\n\n\n## References\n* cplusplus.com: [ C++: array](http://www.cplusplus.com/reference/array/array/).\n* Wikipedia: [ Bounds checking](http://en.wikipedia.org/wiki/Bounds_checking).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-125](https://cwe.mitre.org/data/definitions/125.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This use of offset 'j' should follow the range check."},"location":{"path":"applications/services/gui/elements.c","start_line":928,"end_line":928,"start_column":16,"end_column":31},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/16/instances","dismissal_approved_by":null,"assignees":[]},{"number":15,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/15","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/15","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/offset-use-before-range-check","severity":"warning","description":"Array offset used before range check","name":"cpp/offset-use-before-range-check","tags":["external/cwe/cwe-120","external/cwe/cwe-125","reliability","security"],"full_description":"Accessing an array offset before checking the range means that the program may attempt to read beyond the end of a buffer","help":"# Array offset used before range check\nThe program contains an and-expression where the array access is defined before the range check. Consequently the array is accessed without any bounds checking. The range check does not protect the program from segmentation faults caused by attempts to read beyond the end of a buffer.\n\n\n## Recommendation\nUpdate the and-expression so that the range check precedes the array offset. This will ensure that the bounds are checked before the array is accessed.\n\n\n## Example\nThe `find` function can read past the end of the buffer pointed to by `str` if `start` is longer than or equal to the length of the buffer (or longer than `len`, depending on the contents of the buffer).\n\n\n```c\nint find(int start, char *str, char goal)\n{\n    int len = strlen(str);\n    //Potential buffer overflow\n    for (int i = start; str[i] != 0 && i < len; i++) { \n        if (str[i] == goal)\n            return i; \n    }\n    return -1;\n}\n\nint findRangeCheck(int start, char *str, char goal)\n{\n    int len = strlen(str);\n    //Range check protects against buffer overflow\n    for (int i = start; i < len && str[i] != 0 ; i++) {\n        if (str[i] == goal)\n            return i; \n    }\n    return -1;\n}\n\n\n\n\n```\nUpdate the and-expression so that the range check precedes the array offset (for example, the `findRangeCheck` function).\n\n\n## References\n* cplusplus.com: [ C++: array](http://www.cplusplus.com/reference/array/array/).\n* Wikipedia: [ Bounds checking](http://en.wikipedia.org/wiki/Bounds_checking).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-125](https://cwe.mitre.org/data/definitions/125.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This use of offset 'beacon_data_len' should follow the range check."},"location":{"path":"applications/examples/example_ble_beacon/ble_beacon_app.c","start_line":136,"end_line":136,"start_column":12,"end_column":50},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/15/instances","dismissal_approved_by":null,"assignees":[]},{"number":14,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/14","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/14","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/weak-cryptographic-algorithm","severity":"error","description":"Use of a broken or risky cryptographic algorithm","name":"cpp/weak-cryptographic-algorithm","tags":["external/cwe/cwe-327","security"],"full_description":"Using broken or weak cryptographic algorithms can allow an attacker to compromise security.","help":"# Use of a broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\n\n\n## Example\nThe following code shows an example of using the `advapi` windows API to decrypt some data. When creating a key, you must specify which algorithm to use. The first example uses DES which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```c\nvoid advapi() {\n  HCRYPTPROV hCryptProv;\n  HCRYPTKEY hKey;\n  HCRYPTHASH hHash;\n  // other preparation goes here\n\n  // BAD: use 3DES for key\n  CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey);\n\n  // GOOD: use AES\n  CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey);\n}\n\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This file makes use of a broken or weak cryptographic algorithm (specified by invocation of macro MF_ULTRALIGHT_C_AUTH_DES_KEY_SIZE).\nThis file makes use of a broken or weak cryptographic algorithm (specified by call to mf_ultralight_3des_decrypt).\nThis file makes use of a broken or weak cryptographic algorithm (specified by call to mf_ultralight_3des_decrypt).\nThis file makes use of a broken or weak cryptographic algorithm (specified by call to mf_ultralight_3des_encrypt)."},"location":{"path":"lib/nfc/protocols/mf_ultralight/mf_ultralight_poller_i.c","start_line":168,"end_line":168,"start_column":9,"end_column":35},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/14/instances","dismissal_approved_by":null,"assignees":[]},{"number":13,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/13","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/13","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/weak-cryptographic-algorithm","severity":"error","description":"Use of a broken or risky cryptographic algorithm","name":"cpp/weak-cryptographic-algorithm","tags":["external/cwe/cwe-327","security"],"full_description":"Using broken or weak cryptographic algorithms can allow an attacker to compromise security.","help":"# Use of a broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\n\n\n## Example\nThe following code shows an example of using the `advapi` windows API to decrypt some data. When creating a key, you must specify which algorithm to use. The first example uses DES which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```c\nvoid advapi() {\n  HCRYPTPROV hCryptProv;\n  HCRYPTKEY hKey;\n  HCRYPTHASH hHash;\n  // other preparation goes here\n\n  // BAD: use 3DES for key\n  CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey);\n\n  // GOOD: use AES\n  CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey);\n}\n\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This file makes use of a broken or weak cryptographic algorithm (specified by invocation of macro MF_ULTRALIGHT_C_AUTH_DES_KEY_SIZE)."},"location":{"path":"lib/nfc/protocols/mf_ultralight/mf_ultralight_poller_sync.c","start_line":263,"end_line":263,"start_column":21,"end_column":54},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/13/instances","dismissal_approved_by":null,"assignees":[]},{"number":12,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/12","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/12","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/weak-cryptographic-algorithm","severity":"error","description":"Use of a broken or risky cryptographic algorithm","name":"cpp/weak-cryptographic-algorithm","tags":["external/cwe/cwe-327","security"],"full_description":"Using broken or weak cryptographic algorithms can allow an attacker to compromise security.","help":"# Use of a broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\n\n\n## Example\nThe following code shows an example of using the `advapi` windows API to decrypt some data. When creating a key, you must specify which algorithm to use. The first example uses DES which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```c\nvoid advapi() {\n  HCRYPTPROV hCryptProv;\n  HCRYPTKEY hKey;\n  HCRYPTHASH hHash;\n  // other preparation goes here\n\n  // BAD: use 3DES for key\n  CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey);\n\n  // GOOD: use AES\n  CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey);\n}\n\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This file makes use of a broken or weak cryptographic algorithm (specified by invocation of macro MF_ULTRALIGHT_C_AUTH_DES_KEY_SIZE).\nThis file makes use of a broken or weak cryptographic algorithm (specified by invocation of macro MF_ULTRALIGHT_C_AUTH_DES_KEY_SIZE)."},"location":{"path":"lib/nfc/protocols/mf_ultralight/mf_ultralight_poller.c","start_line":590,"end_line":590,"start_column":13,"end_column":46},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/12/instances","dismissal_approved_by":null,"assignees":[]},{"number":11,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/11","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/11","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/weak-cryptographic-algorithm","severity":"error","description":"Use of a broken or risky cryptographic algorithm","name":"cpp/weak-cryptographic-algorithm","tags":["external/cwe/cwe-327","security"],"full_description":"Using broken or weak cryptographic algorithms can allow an attacker to compromise security.","help":"# Use of a broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\n\n\n## Example\nThe following code shows an example of using the `advapi` windows API to decrypt some data. When creating a key, you must specify which algorithm to use. The first example uses DES which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```c\nvoid advapi() {\n  HCRYPTPROV hCryptProv;\n  HCRYPTKEY hKey;\n  HCRYPTHASH hHash;\n  // other preparation goes here\n\n  // BAD: use 3DES for key\n  CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey);\n\n  // GOOD: use AES\n  CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey);\n}\n\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This file makes use of a broken or weak cryptographic algorithm (specified by call to mf_ultralight_3des_get_key).\nThis file makes use of a broken or weak cryptographic algorithm (specified by call to mf_ultralight_3des_encrypt).\nThis file makes use of a broken or weak cryptographic algorithm (specified by call to mf_ultralight_3des_get_key).\nThis file makes use of a broken or weak cryptographic algorithm (specified by call to mf_ultralight_3des_decrypt).\nThis file makes use of a broken or weak cryptographic algorithm (specified by call to mf_ultralight_3des_encrypt)."},"location":{"path":"lib/nfc/protocols/mf_ultralight/mf_ultralight_listener.c","start_line":564,"end_line":564,"start_column":29,"end_column":55},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/11/instances","dismissal_approved_by":null,"assignees":[]},{"number":10,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/10","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/10","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/weak-cryptographic-algorithm","severity":"error","description":"Use of a broken or risky cryptographic algorithm","name":"cpp/weak-cryptographic-algorithm","tags":["external/cwe/cwe-327","security"],"full_description":"Using broken or weak cryptographic algorithms can allow an attacker to compromise security.","help":"# Use of a broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\n\n\n## Example\nThe following code shows an example of using the `advapi` windows API to decrypt some data. When creating a key, you must specify which algorithm to use. The first example uses DES which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```c\nvoid advapi() {\n  HCRYPTPROV hCryptProv;\n  HCRYPTKEY hKey;\n  HCRYPTHASH hHash;\n  // other preparation goes here\n\n  // BAD: use 3DES for key\n  CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey);\n\n  // GOOD: use AES\n  CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey);\n}\n\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This file makes use of a broken or weak cryptographic algorithm (specified by call to mbedtls_des3_set2key_dec).\nThis file makes use of a broken or weak cryptographic algorithm (specified by call to mbedtls_des3_crypt_cbc).\nThis file makes use of a broken or weak cryptographic algorithm (specified by call to mbedtls_des3_set2key_enc).\nThis file makes use of a broken or weak cryptographic algorithm (specified by call to mbedtls_des3_crypt_cbc)."},"location":{"path":"lib/nfc/protocols/mf_ultralight/mf_ultralight.c","start_line":714,"end_line":714,"start_column":5,"end_column":29},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/10/instances","dismissal_approved_by":null,"assignees":[]},{"number":9,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/9","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/9","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/weak-cryptographic-algorithm","severity":"error","description":"Use of a broken or risky cryptographic algorithm","name":"cpp/weak-cryptographic-algorithm","tags":["external/cwe/cwe-327","security"],"full_description":"Using broken or weak cryptographic algorithms can allow an attacker to compromise security.","help":"# Use of a broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\n\n\n## Example\nThe following code shows an example of using the `advapi` windows API to decrypt some data. When creating a key, you must specify which algorithm to use. The first example uses DES which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```c\nvoid advapi() {\n  HCRYPTPROV hCryptProv;\n  HCRYPTKEY hKey;\n  HCRYPTHASH hHash;\n  // other preparation goes here\n\n  // BAD: use 3DES for key\n  CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey);\n\n  // GOOD: use AES\n  CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey);\n}\n\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This file makes use of a broken or weak cryptographic algorithm (specified by call to mbedtls_des3_set2key_enc).\nThis file makes use of a broken or weak cryptographic algorithm (specified by call to mbedtls_des3_crypt_cbc).\nThis file makes use of a broken or weak cryptographic algorithm (specified by call to mbedtls_des3_set2key_enc).\nThis file makes use of a broken or weak cryptographic algorithm (specified by call to mbedtls_des3_crypt_cbc)."},"location":{"path":"lib/nfc/protocols/felica/felica.c","start_line":224,"end_line":224,"start_column":5,"end_column":29},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/9/instances","dismissal_approved_by":null,"assignees":[]},{"number":8,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/8","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/8","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/uncontrolled-arithmetic","severity":"warning","description":"Uncontrolled data in arithmetic expression","name":"cpp/uncontrolled-arithmetic","tags":["external/cwe/cwe-190","external/cwe/cwe-191","security"],"full_description":"Arithmetic operations on uncontrolled data that is not validated can cause overflows.","help":"# Uncontrolled data in arithmetic expression\nPerforming calculations on uncontrolled data can result in integer overflows unless the input is validated.\n\nIf the data is not under your control, and can take extremely large values, even arithmetic operations that would usually result in a small change in magnitude may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations on uncontrolled data by doing one of the following:\n\n* Validate the data.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type, for example `INT_MAX`.\n* Use a wider type, so that larger input values do not cause overflow.\n\n## Example\nIn this example, a random integer is generated. Because the value is not controlled by the programmer, it could be extremely large. Performing arithmetic operations on this value could therefore cause an overflow. To avoid this happening, the example shows how to perform a check before performing an arithmetic operation.\n\n\n```c\nint main(int argc, char** argv) {\n\tint i = rand();\n\t// BAD: potential overflow\n\tint j = i + 1000;\n\n\t// ...\n\n\tint n = rand();\n\tint k;\n\t// GOOD: use a guard to prevent overflow\n\tif (n < INT_MAX-1000)\n\t\tk = n + 1000;\n\telse\n\t\tk = INT_MAX;\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This arithmetic expression depends on an uncontrolled value, potentially causing an overflow."},"location":{"path":"lib/toolbox/varint.c","start_line":47,"end_line":47,"start_column":14,"end_column":19},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/8/instances","dismissal_approved_by":null,"assignees":[]},{"number":7,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/7","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/7","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/uncontrolled-arithmetic","severity":"warning","description":"Uncontrolled data in arithmetic expression","name":"cpp/uncontrolled-arithmetic","tags":["external/cwe/cwe-190","external/cwe/cwe-191","security"],"full_description":"Arithmetic operations on uncontrolled data that is not validated can cause overflows.","help":"# Uncontrolled data in arithmetic expression\nPerforming calculations on uncontrolled data can result in integer overflows unless the input is validated.\n\nIf the data is not under your control, and can take extremely large values, even arithmetic operations that would usually result in a small change in magnitude may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations on uncontrolled data by doing one of the following:\n\n* Validate the data.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type, for example `INT_MAX`.\n* Use a wider type, so that larger input values do not cause overflow.\n\n## Example\nIn this example, a random integer is generated. Because the value is not controlled by the programmer, it could be extremely large. Performing arithmetic operations on this value could therefore cause an overflow. To avoid this happening, the example shows how to perform a check before performing an arithmetic operation.\n\n\n```c\nint main(int argc, char** argv) {\n\tint i = rand();\n\t// BAD: potential overflow\n\tint j = i + 1000;\n\n\t// ...\n\n\tint n = rand();\n\tint k;\n\t// GOOD: use a guard to prevent overflow\n\tif (n < INT_MAX-1000)\n\t\tk = n + 1000;\n\telse\n\t\tk = INT_MAX;\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This arithmetic expression depends on an uncontrolled value, potentially causing an overflow."},"location":{"path":"lib/toolbox/varint.c","start_line":45,"end_line":45,"start_column":13,"end_column":18},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/7/instances","dismissal_approved_by":null,"assignees":[]},{"number":6,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/6","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/6","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/non-constant-format","severity":"note","description":"Non-constant format string","name":"cpp/non-constant-format","tags":["correctness","external/cwe/cwe-134","maintainability","security"],"full_description":"Passing a value that is not a string literal 'format' string to a printf-like function can lead to a mismatch between the number of arguments defined by the 'format' and the number of arguments actually passed to the function. If the format string ultimately stems from an untrusted source, this can be used for exploits. This query finds format strings coming from non-literal sources. Note that format strings of type `const char*` it is still considered non-constant if the value is not coming from a string literal. For example, for a parameter with type `const char*` of an exported function that is used as a format string, there is no way to ensure the originating value was a string literal.","help":"# Non-constant format string\nThe `printf` function, related functions like `sprintf` and `fprintf`, and other functions built atop `vprintf` all accept a format string as one of their arguments. When such format strings are literal constants, it is easy for the programmer (and static analysis tools) to verify that the format specifiers (such as `%s` and `%02x`) in the format string are compatible with the trailing arguments of the function call. When such format strings are not literal constants, it is more difficult to maintain the program: programmers (and static analysis tools) must perform non-local data-flow analysis to deduce what values the format string argument might take.\n\n\n## Recommendation\nIf the argument passed as a format string is meant to be a plain string rather than a format string, then pass `%s` as the format string, and pass the original argument as the sole trailing argument.\n\nIf the argument passed as a format string is a parameter to the enclosing function, then consider redesigning the enclosing function's API to be less brittle.\n\n\n## Example\nThe following program is meant to echo its command line arguments:\n\n\n```c\n#include <stdio.h>\nint main(int argc, char** argv) {\n  for(int i = 1; i < argc; ++i) {\n    printf(argv[i]);\n  }\n}\n```\nThe above program behaves as expected in most cases, but breaks when one of its command line arguments contains a percent character. In such cases, the behavior of the program is undefined: it might echo garbage, it might crash, or it might give a malicious attacker root access. One way of addressing the problem is to use a constant `%s` format string, as in the following program:\n\n\n```c\n#include <stdio.h>\nint main(int argc, char** argv) {\n  for(int i = 1; i < argc; ++i) {\n    printf(\"%s\", argv[i]);\n  }\n}\n```\n\n## Example\nThe following program defines a `log_with_timestamp` function:\n\n\n```c\nvoid log_with_timestamp(const char* message) {\n  struct tm now;\n  time(&now);\n  printf(\"[%s] \", asctime(now));\n  printf(message);\n}\n\nint main(int argc, char** argv) {\n  log_with_timestamp(\"Application is starting...\\n\");\n  /* ... */\n  log_with_timestamp(\"Application is closing...\\n\");\n  return 0;\n}\n```\nIn the code that is visible, the reader can verify that `log_with_timestamp` is never called with a log message containing a percent character, but even if all current calls are correct, this presents an ongoing maintenance burden to ensure that newly-introduced calls don't contain percent characters. As in the previous example, one solution is to make the log message a trailing argument of the function call:\n\n\n```c\nvoid log_with_timestamp(const char* message) {\n  struct tm now;\n  time(&now);\n  printf(\"[%s] %s\", asctime(now), message);\n}\n\nint main(int argc, char** argv) {\n  log_with_timestamp(\"Application is starting...\\n\");\n  /* ... */\n  log_with_timestamp(\"Application is closing...\\n\");\n  return 0;\n}\n```\nAn alternative solution is to allow `log_with_timestamp` to accept format arguments:\n\n\n```c\nvoid log_with_timestamp(const char* message, ...) {\n  va_list args;\n  va_start(args, message);\n  struct tm now;\n  time(&now);\n  printf(\"[%s] \", asctime(now));\n  vprintf(message, args);\n  va_end(args);\n}\n\nint main(int argc, char** argv) {\n  log_with_timestamp(\"%s is starting...\\n\", argv[0]);\n  /* ... */\n  log_with_timestamp(\"%s is closing...\\n\", argv[0]);\n  return 0;\n}\n```\nIn this formulation, the non-constant format string to `printf` has been replaced with a non-constant format string to `vprintf`. The analysis will no longer consider the body of `log_with_timestamp` to be a problem, and will instead check that every call to `log_with_timestamp` passes a constant format string.\n\n\n## References\n* CERT C Coding Standard: [FIO30-C. Exclude user input from format strings](https://www.securecoding.cert.org/confluence/display/c/FIO30-C.+Exclude+user+input+from+format+strings).\n* M. Howard, D. Leblanc, J. Viega, *19 Deadly Sins of Software Security: Programming Flaws and How to Fix Them*.\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"The format string argument to nfc_text_store_set has a source which cannot be verified to originate from a string literal."},"location":{"path":"applications/main/nfc/scenes/nfc_scene_mf_ultralight_unlock_warn.c","start_line":26,"end_line":26,"start_column":33,"end_column":67},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/6/instances","dismissal_approved_by":null,"assignees":[]},{"number":5,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/5","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/5","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/non-constant-format","severity":"note","description":"Non-constant format string","name":"cpp/non-constant-format","tags":["correctness","external/cwe/cwe-134","maintainability","security"],"full_description":"Passing a value that is not a string literal 'format' string to a printf-like function can lead to a mismatch between the number of arguments defined by the 'format' and the number of arguments actually passed to the function. If the format string ultimately stems from an untrusted source, this can be used for exploits. This query finds format strings coming from non-literal sources. Note that format strings of type `const char*` it is still considered non-constant if the value is not coming from a string literal. For example, for a parameter with type `const char*` of an exported function that is used as a format string, there is no way to ensure the originating value was a string literal.","help":"# Non-constant format string\nThe `printf` function, related functions like `sprintf` and `fprintf`, and other functions built atop `vprintf` all accept a format string as one of their arguments. When such format strings are literal constants, it is easy for the programmer (and static analysis tools) to verify that the format specifiers (such as `%s` and `%02x`) in the format string are compatible with the trailing arguments of the function call. When such format strings are not literal constants, it is more difficult to maintain the program: programmers (and static analysis tools) must perform non-local data-flow analysis to deduce what values the format string argument might take.\n\n\n## Recommendation\nIf the argument passed as a format string is meant to be a plain string rather than a format string, then pass `%s` as the format string, and pass the original argument as the sole trailing argument.\n\nIf the argument passed as a format string is a parameter to the enclosing function, then consider redesigning the enclosing function's API to be less brittle.\n\n\n## Example\nThe following program is meant to echo its command line arguments:\n\n\n```c\n#include <stdio.h>\nint main(int argc, char** argv) {\n  for(int i = 1; i < argc; ++i) {\n    printf(argv[i]);\n  }\n}\n```\nThe above program behaves as expected in most cases, but breaks when one of its command line arguments contains a percent character. In such cases, the behavior of the program is undefined: it might echo garbage, it might crash, or it might give a malicious attacker root access. One way of addressing the problem is to use a constant `%s` format string, as in the following program:\n\n\n```c\n#include <stdio.h>\nint main(int argc, char** argv) {\n  for(int i = 1; i < argc; ++i) {\n    printf(\"%s\", argv[i]);\n  }\n}\n```\n\n## Example\nThe following program defines a `log_with_timestamp` function:\n\n\n```c\nvoid log_with_timestamp(const char* message) {\n  struct tm now;\n  time(&now);\n  printf(\"[%s] \", asctime(now));\n  printf(message);\n}\n\nint main(int argc, char** argv) {\n  log_with_timestamp(\"Application is starting...\\n\");\n  /* ... */\n  log_with_timestamp(\"Application is closing...\\n\");\n  return 0;\n}\n```\nIn the code that is visible, the reader can verify that `log_with_timestamp` is never called with a log message containing a percent character, but even if all current calls are correct, this presents an ongoing maintenance burden to ensure that newly-introduced calls don't contain percent characters. As in the previous example, one solution is to make the log message a trailing argument of the function call:\n\n\n```c\nvoid log_with_timestamp(const char* message) {\n  struct tm now;\n  time(&now);\n  printf(\"[%s] %s\", asctime(now), message);\n}\n\nint main(int argc, char** argv) {\n  log_with_timestamp(\"Application is starting...\\n\");\n  /* ... */\n  log_with_timestamp(\"Application is closing...\\n\");\n  return 0;\n}\n```\nAn alternative solution is to allow `log_with_timestamp` to accept format arguments:\n\n\n```c\nvoid log_with_timestamp(const char* message, ...) {\n  va_list args;\n  va_start(args, message);\n  struct tm now;\n  time(&now);\n  printf(\"[%s] \", asctime(now));\n  vprintf(message, args);\n  va_end(args);\n}\n\nint main(int argc, char** argv) {\n  log_with_timestamp(\"%s is starting...\\n\", argv[0]);\n  /* ... */\n  log_with_timestamp(\"%s is closing...\\n\", argv[0]);\n  return 0;\n}\n```\nIn this formulation, the non-constant format string to `printf` has been replaced with a non-constant format string to `vprintf`. The analysis will no longer consider the body of `log_with_timestamp` to be a problem, and will instead check that every call to `log_with_timestamp` passes a constant format string.\n\n\n## References\n* CERT C Coding Standard: [FIO30-C. Exclude user input from format strings](https://www.securecoding.cert.org/confluence/display/c/FIO30-C.+Exclude+user+input+from+format+strings).\n* M. Howard, D. Leblanc, J. Viega, *19 Deadly Sins of Software Security: Programming Flaws and How to Fix Them*.\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"The format string argument to nfc_text_store_set has a source which cannot be verified to originate from a string literal."},"location":{"path":"applications/main/nfc/scenes/nfc_scene_des_auth_unlock_warn.c","start_line":30,"end_line":30,"start_column":29,"end_column":54},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/5/instances","dismissal_approved_by":null,"assignees":[]},{"number":4,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/4","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/4","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/use-after-free","severity":"warning","description":"Potential use after free","name":"cpp/use-after-free","tags":["external/cwe/cwe-416","reliability","security"],"full_description":"An allocated memory block is used after it has been freed. Behavior in such cases is undefined and can cause memory corruption.","help":"# Potential use after free\nThis rule finds accesses through a pointer of a memory location that has already been freed (i.e. through a dangling pointer). Such memory blocks have already been released to the dynamic memory manager, and modifying them can lead to anything from a segfault to memory corruption that would cause subsequent calls to the dynamic memory manager to behave erratically, to a possible security vulnerability.\n\n> WARNING: This check is an approximation, so some results may not be actual defects in the program. It is not possible in general to compute the values of pointers without running the program with all input data.\n\n## Recommendation\nEnsure that all execution paths that access memory through a pointer never access that pointer after it is freed.\n\n\n## Example\n\n```cpp\nvoid f() {\n\tchar* buf = new char[SIZE];\n\t...\n\tif (error) {\n\t\tdelete buf; //error handling has freed the buffer\n\t}\n\t...\n\tlog_contents(buf); //but it is still used here for logging\n\t...\n}\n\n```\n\n## References\n* I. Gerg. *An Overview and Example of the Buffer-Overflow Exploit*. IANewsletter vol 7 no 4. 2005.\n* M. Donaldson. *Inside the Buffer Overflow Attack: Mechanism, Method &amp; Prevention*. SANS Institute InfoSec Reading Room. 2002.\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"Memory may have been previously freed by call to free."},"location":{"path":"lib/mjs/common/str_util.c","start_line":425,"end_line":425,"start_column":10,"end_column":14},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/4/instances","dismissal_approved_by":null,"assignees":[]},{"number":3,"created_at":"2025-08-26T22:55:41Z","updated_at":"2025-08-26T22:55:41Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/3","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/3","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"cpp/use-after-free","severity":"warning","description":"Potential use after free","name":"cpp/use-after-free","tags":["external/cwe/cwe-416","reliability","security"],"full_description":"An allocated memory block is used after it has been freed. Behavior in such cases is undefined and can cause memory corruption.","help":"# Potential use after free\nThis rule finds accesses through a pointer of a memory location that has already been freed (i.e. through a dangling pointer). Such memory blocks have already been released to the dynamic memory manager, and modifying them can lead to anything from a segfault to memory corruption that would cause subsequent calls to the dynamic memory manager to behave erratically, to a possible security vulnerability.\n\n> WARNING: This check is an approximation, so some results may not be actual defects in the program. It is not possible in general to compute the values of pointers without running the program with all input data.\n\n## Recommendation\nEnsure that all execution paths that access memory through a pointer never access that pointer after it is freed.\n\n\n## Example\n\n```cpp\nvoid f() {\n\tchar* buf = new char[SIZE];\n\t...\n\tif (error) {\n\t\tdelete buf; //error handling has freed the buffer\n\t}\n\t...\n\tlog_contents(buf); //but it is still used here for logging\n\t...\n}\n\n```\n\n## References\n* I. Gerg. *An Overview and Example of the Buffer-Overflow Exploit*. IANewsletter vol 7 no 4. 2005.\n* M. Donaldson. *Inside the Buffer Overflow Attack: Mechanism, Method &amp; Prevention*. SANS Institute InfoSec Reading Room. 2002.\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n","security_severity_level":"critical"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:c-cpp\",\"language\":\"c-cpp\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:c-cpp","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"Memory may have been previously freed by call to free."},"location":{"path":"lib/mjs/common/str_util.c","start_line":417,"end_line":417,"start_column":29,"end_column":33},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/3/instances","dismissal_approved_by":null,"assignees":[]},{"number":2,"created_at":"2025-08-26T22:52:20Z","updated_at":"2025-08-26T22:52:20Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/2","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/2","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"py/tarslip","severity":"error","description":"Arbitrary file write during tarfile extraction","name":"py/tarslip","tags":["external/cwe/cwe-022","security"],"full_description":"Extracting files from a malicious tar archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten.","help":"# Arbitrary file write during tarfile extraction\nExtracting files from a malicious tar archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten, due to the possible presence of directory traversal elements (`..`) in archive paths.\n\nTar archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to determine an output file to write the contents of the archive item to, then the file may be written to an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a tar archive contains a file entry `..\\sneaky-file`, and the tar archive is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from tar archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a tar archive entry is to check that `\"..\"` does not occur in the path.\n\n\n## Example\nIn this example an archive is extracted without validating file paths. If `archive.tar` contained relative paths (for instance, if it were created by something like `tar -cf archive.tar ../file.txt`) then executing this code could write to locations outside the destination directory.\n\n\n```python\nimport sys\nimport tarfile\n\nwith tarfile.open(sys.argv[1]) as tar:\n    #BAD : This could write any file on the filesystem.\n    for entry in tar:\n        tar.extract(entry, \"/tmp/unpack/\")\n\n```\nTo fix this vulnerability, we need to check that the path does not contain any `\"..\"` elements in it.\n\n\n```python\nimport sys\nimport tarfile\nimport os.path\n\nwith tarfile.open(sys.argv[1]) as tar:\n    for entry in tar:\n        #GOOD: Check that entry is safe\n        if os.path.isabs(entry.name) or \"..\" in entry.name:\n            raise ValueError(\"Illegal tar archive entry\")\n        tar.extract(entry, \"/tmp/unpack/\")\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Python Library Reference: [TarFile.extract](https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.extract).\n* Python Library Reference: [TarFile.extractall](https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.extractall).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:python\",\"language\":\"python\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:python","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"This file extraction depends on a potentially untrusted source."},"location":{"path":"scripts/wifi_board.py","start_line":115,"end_line":115,"start_column":13,"end_column":16},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/2/instances","dismissal_approved_by":null,"assignees":[]},{"number":1,"created_at":"2025-08-26T22:52:20Z","updated_at":"2025-08-26T22:52:20Z","url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/1","html_url":"https://github.com/joseguzman1337/Momentum-Firmware/security/code-scanning/1","state":"open","fixed_at":null,"dismissed_by":null,"dismissed_at":null,"dismissed_reason":null,"dismissed_comment":null,"rule":{"id":"py/weak-crypto-key","severity":"error","description":"Use of weak cryptographic key","name":"py/weak-crypto-key","tags":["external/cwe/cwe-326","security"],"full_description":"Use of a cryptographic key that is too small may allow the encryption to be broken.","help":"# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are RivestShamirAdleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n","security_severity_level":"high"},"tool":{"name":"CodeQL","guid":null,"version":"2.22.4"},"most_recent_instance":{"ref":"refs/heads/dev","analysis_key":"dynamic/github-code-scanning/codeql:analyze","environment":"{\"build-mode\":\"none\",\"category\":\"/language:python\",\"language\":\"python\",\"runner\":\"[\\\"ubuntu-latest\\\"]\"}","category":"/language:python","state":"open","commit_sha":"354dad4af372c5e7f17d3e5dd04474e67e637afc","message":{"text":"Creation of an ECC key uses 224 bits, which is below 256 and considered breakable."},"location":{"path":"applications/system/findmy/generate_keys.py","start_line":53,"end_line":53,"start_column":27,"end_column":85},"classifications":[]},"instances_url":"https://api.github.com/repos/joseguzman1337/Momentum-Firmware/code-scanning/alerts/1/instances","dismissal_approved_by":null,"assignees":[]}]